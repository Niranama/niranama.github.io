!! NOTE: this file is autogenerated from adjac.f95.in: do not edit manually
! -*-f90-*-
!
! adjac: Automatic Differentiation for generating Jacobians.
!

! Copyright (c) 2014, Pauli Virtanen <pav@iki.fi>
! All rights reserved.
!
! Redistribution and use in source and binary forms, with or without
! modification, are permitted provided that the following conditions
! are met:
!
! 1. Redistributions of source code must retain the above copyright
! notice, this list of conditions and the following disclaimer.
!
! 2. Redistributions in binary form must reproduce the above copyright
! notice, this list of conditions and the following disclaimer in the
! documentation and/or other materials provided with the distribution.
!
! 3. Neither the name of the copyright holder nor the names of its
! contributors may be used to endorse or promote products derived from
! this software without specific prior written permission.
!
! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
! "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
! LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
! FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
! COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
! INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
! BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
! LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
! CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
! LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
! ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
! POSSIBILITY OF SUCH DAMAGE.

MODULE ModLib_AdJac
  PRIVATE

  ! NOTE: WE WOULD LIKE TO USE DERIVED TYPE FINALIZERS FOR MEMORY
  ! DEALLOCATION.  HOWEVER, AS OF 2015-03-12, THESE ARE NOT FULLY
  ! IMPLEMENTED IN GFORTRAN, AND WILL NOT BE CALLED E.G. ON FUNCTION
  ! RETURNS THAT THE CODE HERE EXTENSIVELY RELIES ON.

  TYPE, PUBLIC :: ADJAC_DOUBLE
     DOUBLE PRECISION :: VALUE, VMUL
     INTEGER :: I = 0
  END TYPE ADJAC_DOUBLE

  TYPE, PUBLIC :: ADJAC_COMPLEXAN
     COMPLEX(KIND=KIND(0D0)) :: VALUE, VMUL
     INTEGER :: I = 0
  END TYPE ADJAC_COMPLEXAN

  TYPE, PUBLIC :: ADJAC_COMPLEX
     TYPE(ADJAC_DOUBLE) :: RE, IM
  END TYPE ADJAC_COMPLEX

  LOGICAL :: JAC_PRODUCT_MODE = .FALSE.
  ! DAG OF DIFFERENTIALS
  !
  ! IF (SUM_MAP(1 + 2*(I-1)) .NE. 0) THEN
  !     ! DEPENDENT VARIABLE
  !     D_{I} = SUM_MUL(1+2*(I-1)) * D_{SUM_MAP(1+2*(I-1))} + SUM_MUL(2+2*(I-1)) * D_{SUM_MAP(2+2*(I-1))}
  ! ELSE
  !     ! INDEPENDENT VARIABLE
  !     D_{I} = D_{I}
  !
  INTEGER, PARAMETER :: BLOCK_SIZE = 16
  INTEGER :: FREE_A = 1, FREE_Q = 1
  INTEGER, DIMENSION(:), ALLOCATABLE :: SUM_MAP_A, SUM_MAP_Q
  DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: SUM_MUL_A
  COMPLEX(KIND=KIND(0D0)), DIMENSION(:), ALLOCATABLE :: SUM_MUL_Q

  PUBLIC ASSIGNMENT(=)
  INTERFACE ASSIGNMENT(=)
     MODULE PROCEDURE ASSIGN_AI, ASSIGN_AD
     MODULE PROCEDURE ASSIGN_BI, ASSIGN_BD, ASSIGN_BZ, ASSIGN_BA
     MODULE PROCEDURE ASSIGN_QI, ASSIGN_QD, ASSIGN_QZ
  END INTERFACE

  PUBLIC OPERATOR(+)
  INTERFACE OPERATOR(+)
     MODULE PROCEDURE ADD_AA
     MODULE PROCEDURE ADD_BB
     MODULE PROCEDURE ADD_QQ
     MODULE PROCEDURE ADD_AB
     MODULE PROCEDURE ADD_BA
     MODULE PROCEDURE ADD_AI
     MODULE PROCEDURE ADD_BI
     MODULE PROCEDURE ADD_QI
     MODULE PROCEDURE ADD_IA
     MODULE PROCEDURE ADD_IB
     MODULE PROCEDURE ADD_IQ
     MODULE PROCEDURE ADD_AD
     MODULE PROCEDURE ADD_BD
     MODULE PROCEDURE ADD_QD
     MODULE PROCEDURE ADD_DA
     MODULE PROCEDURE ADD_DB
     MODULE PROCEDURE ADD_DQ
     MODULE PROCEDURE ADD_AZ
     MODULE PROCEDURE ADD_BZ
     MODULE PROCEDURE ADD_QZ
     MODULE PROCEDURE ADD_ZA
     MODULE PROCEDURE ADD_ZB
     MODULE PROCEDURE ADD_ZQ
     MODULE PROCEDURE POS_A, POS_B, POS_Q
  END INTERFACE

  PUBLIC OPERATOR(-)
  INTERFACE OPERATOR(-)
     MODULE PROCEDURE SUB_AA
     MODULE PROCEDURE SUB_BB
     MODULE PROCEDURE SUB_QQ
     MODULE PROCEDURE SUB_AB
     MODULE PROCEDURE SUB_BA
     MODULE PROCEDURE SUB_AI
     MODULE PROCEDURE SUB_BI
     MODULE PROCEDURE SUB_QI
     MODULE PROCEDURE SUB_IA
     MODULE PROCEDURE SUB_IB
     MODULE PROCEDURE SUB_IQ
     MODULE PROCEDURE SUB_AD
     MODULE PROCEDURE SUB_BD
     MODULE PROCEDURE SUB_QD
     MODULE PROCEDURE SUB_DA
     MODULE PROCEDURE SUB_DB
     MODULE PROCEDURE SUB_DQ
     MODULE PROCEDURE SUB_AZ
     MODULE PROCEDURE SUB_BZ
     MODULE PROCEDURE SUB_QZ
     MODULE PROCEDURE SUB_ZA
     MODULE PROCEDURE SUB_ZB
     MODULE PROCEDURE SUB_ZQ
     MODULE PROCEDURE NEG_A, NEG_B, NEG_Q
  END INTERFACE

  PUBLIC OPERATOR(*)
  INTERFACE OPERATOR(*)
     MODULE PROCEDURE MUL_AA
     MODULE PROCEDURE MUL_BB
     MODULE PROCEDURE MUL_QQ
     MODULE PROCEDURE MUL_AB
     MODULE PROCEDURE MUL_BA
     MODULE PROCEDURE MUL_AI
     MODULE PROCEDURE MUL_BI
     MODULE PROCEDURE MUL_QI
     MODULE PROCEDURE MUL_IA
     MODULE PROCEDURE MUL_IB
     MODULE PROCEDURE MUL_IQ
     MODULE PROCEDURE MUL_AD
     MODULE PROCEDURE MUL_BD
     MODULE PROCEDURE MUL_QD
     MODULE PROCEDURE MUL_DA
     MODULE PROCEDURE MUL_DB
     MODULE PROCEDURE MUL_DQ
     MODULE PROCEDURE MUL_AZ
     MODULE PROCEDURE MUL_BZ
     MODULE PROCEDURE MUL_QZ
     MODULE PROCEDURE MUL_ZA
     MODULE PROCEDURE MUL_ZB
     MODULE PROCEDURE MUL_ZQ
  END INTERFACE OPERATOR(*)

  PUBLIC OPERATOR(/)
  INTERFACE OPERATOR(/)
     MODULE PROCEDURE DIV_AA
     MODULE PROCEDURE DIV_BB
     MODULE PROCEDURE DIV_QQ
     MODULE PROCEDURE DIV_AB
     MODULE PROCEDURE DIV_BA
     MODULE PROCEDURE DIV_AI
     MODULE PROCEDURE DIV_BI
     MODULE PROCEDURE DIV_QI
     MODULE PROCEDURE DIV_IA
     MODULE PROCEDURE DIV_IB
     MODULE PROCEDURE DIV_IQ
     MODULE PROCEDURE DIV_AD
     MODULE PROCEDURE DIV_BD
     MODULE PROCEDURE DIV_QD
     MODULE PROCEDURE DIV_DA
     MODULE PROCEDURE DIV_DB
     MODULE PROCEDURE DIV_DQ
     MODULE PROCEDURE DIV_AZ
     MODULE PROCEDURE DIV_BZ
     MODULE PROCEDURE DIV_QZ
     MODULE PROCEDURE DIV_ZA
     MODULE PROCEDURE DIV_ZB
     MODULE PROCEDURE DIV_ZQ
  END INTERFACE OPERATOR(/)

  PUBLIC OPERATOR(**)
  INTERFACE OPERATOR(**)
     MODULE PROCEDURE POW_AI, POW_AD, POW_QI, POW_QD, POW_QZ
  END INTERFACE OPERATOR(**)

  PUBLIC MATMUL
  INTERFACE MATMUL
     MODULE PROCEDURE MATMUL_AA, MATMUL_AI, MATMUL_IA, MATMUL_AD, MATMUL_DA
     MODULE PROCEDURE MATMUL_BB, MATMUL_BZ, MATMUL_ZB
     MODULE PROCEDURE MATMUL_QQ, MATMUL_QI, MATMUL_IQ, MATMUL_QD, MATMUL_DQ, MATMUL_QZ, MATMUL_ZQ
  END INTERFACE MATMUL

  PUBLIC DBLE
  INTERFACE DBLE
     MODULE PROCEDURE DBLE_A, DBLE_B
  END INTERFACE DBLE

  PUBLIC AIMAG
  INTERFACE AIMAG
     MODULE PROCEDURE AIMAG_B
  END INTERFACE AIMAG

  PUBLIC CONJG
  INTERFACE CONJG
     MODULE PROCEDURE CONJG_B
  END INTERFACE CONJG

  PUBLIC EXP
  INTERFACE EXP
     MODULE PROCEDURE EXP_A, EXP_B, EXP_Q
  END INTERFACE EXP

  PUBLIC SIN
  INTERFACE SIN
     MODULE PROCEDURE SIN_A, SIN_B, SIN_Q
  END INTERFACE SIN

  PUBLIC COS
  INTERFACE COS
     MODULE PROCEDURE COS_A, COS_B, COS_Q
  END INTERFACE COS

  PUBLIC LOG
  INTERFACE LOG
     MODULE PROCEDURE LOG_A, LOG_B, LOG_Q
  END INTERFACE LOG

  INTERFACE ADJAC_SET_INDEPENDENT
     MODULE PROCEDURE SET_INDEPENDENT_A, SET_INDEPENDENT_Q
     MODULE PROCEDURE SET_INDEPENDENT_MANY_A, SET_INDEPENDENT_MANY_Q
  END INTERFACE ADJAC_SET_INDEPENDENT

  INTERFACE SUM_TAYLOR
     MODULE PROCEDURE SUM_TAYLOR_A, SUM_TAYLOR_Q
  END INTERFACE SUM_TAYLOR

  INTERFACE ADJAC_GET_VALUE
     MODULE PROCEDURE GET_VALUE_ONE_A, GET_VALUE_ONE_Q
     MODULE PROCEDURE GET_VALUE_MANY_A, GET_VALUE_MANY_Q
  END INTERFACE ADJAC_GET_VALUE

  INTERFACE ADJAC_GET_DENSE_JACOBIAN
     MODULE PROCEDURE GET_DENSE_JACOBIAN_A, GET_DENSE_JACOBIAN_Q
  END INTERFACE ADJAC_GET_DENSE_JACOBIAN

  INTERFACE ADJAC_GET_COO_JACOBIAN
     MODULE PROCEDURE GET_COO_JACOBIAN_A, GET_COO_JACOBIAN_Q
  END INTERFACE ADJAC_GET_COO_JACOBIAN

  PUBLIC ADJAC_SET_INDEPENDENT, ADJAC_GET_VALUE, &
       ADJAC_GET_DENSE_JACOBIAN, ADJAC_GET_COO_JACOBIAN, &
       ADJAC_RESET, ADJAC_FREE
CONTAINS

  SUBROUTINE FATAL_ERROR(MSG)
    IMPLICIT NONE
    CHARACTER(LEN=*), INTENT(IN) :: MSG
    WRITE(*,*) 'ADJAC: ERROR: ', TRIM(MSG)
    STOP
  END SUBROUTINE FATAL_ERROR

  SUBROUTINE ADJAC_RESET(PRODUCT_MODE)
    IMPLICIT NONE
    LOGICAL, OPTIONAL, INTENT(IN) :: PRODUCT_MODE

    IF (PRESENT(PRODUCT_MODE)) THEN
       JAC_PRODUCT_MODE = PRODUCT_MODE
    END IF
    FREE_A = 1
    FREE_Q = 1
  END SUBROUTINE ADJAC_RESET

  SUBROUTINE ADJAC_FREE()
    IMPLICIT NONE
    FREE_A = 1
    FREE_Q = 1
    IF (ALLOCATED(SUM_MAP_A)) THEN
       DEALLOCATE(SUM_MAP_A)
       DEALLOCATE(SUM_MUL_A)
    END IF
    IF (ALLOCATED(SUM_MAP_Q)) THEN
       DEALLOCATE(SUM_MAP_Q)
       DEALLOCATE(SUM_MUL_Q)
    END IF
  END SUBROUTINE ADJAC_FREE
  PURE SUBROUTINE HEAP_SIFTUP(HEAP, NHEAP, INITPOS)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: NHEAP
    INTEGER, DIMENSION(*), INTENT(INOUT) :: HEAP
    INTEGER, INTENT(IN) :: INITPOS

    INTEGER :: POS, ITEM, POS2, POS3

    POS = INITPOS
    POS2 = 2*POS

    ITEM = HEAP(POS)
    DO WHILE (POS2 <= NHEAP)
       POS3 = POS2 + 1
       IF (POS3 <= NHEAP .AND. HEAP(POS3) >= HEAP(POS2)) THEN
          POS2 = POS3
       END IF
       HEAP(POS) = HEAP(POS2)
       POS = POS2
       POS2 = 2*POS
    END DO
    HEAP(POS) = ITEM
    CALL HEAP_SIFTDOWN(HEAP, INITPOS, POS)
  END SUBROUTINE HEAP_SIFTUP

  PURE SUBROUTINE HEAP_SIFTDOWN(HEAP, INITPOS, POS0)
    IMPLICIT NONE
    INTEGER, DIMENSION(*), INTENT(INOUT) :: HEAP
    INTEGER, INTENT(IN) :: INITPOS, POS0

    INTEGER :: ITEM, POS, POS2

    POS = POS0
    ITEM = HEAP(POS)
    DO WHILE (POS > INITPOS)
       POS2 = POS/2
       IF (HEAP(POS2) < ITEM) THEN
          HEAP(POS) = HEAP(POS2)
       ELSE
          EXIT
       END IF
       POS = POS2
    END DO
    HEAP(POS) = ITEM
  END SUBROUTINE HEAP_SIFTDOWN

  PURE SUBROUTINE HEAP_PUSH(HEAP, NHEAP, ITEM)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: NHEAP
    INTEGER, DIMENSION(*), INTENT(INOUT) :: HEAP
    INTEGER, INTENT(IN) :: ITEM

    NHEAP = NHEAP + 1
    HEAP(NHEAP) = ITEM
    CALL HEAP_SIFTDOWN(HEAP, 1, NHEAP)
  END SUBROUTINE HEAP_PUSH

  PURE SUBROUTINE HEAP_POP(HEAP, NHEAP, ITEM)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: NHEAP
    INTEGER, DIMENSION(*), INTENT(INOUT) :: HEAP
    INTEGER, INTENT(OUT) :: ITEM

    ITEM = HEAP(1)
    HEAP(1) = HEAP(NHEAP)
    NHEAP = NHEAP - 1

    IF (NHEAP.GT.1) THEN
       CALL HEAP_SIFTUP(HEAP, NHEAP, 1)
    END IF
  END SUBROUTINE HEAP_POP

  PURE SUBROUTINE HEAP_PUSHPOP(HEAP, NHEAP, ITEM, ITEM_OUT)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: NHEAP
    INTEGER, DIMENSION(*), INTENT(INOUT) :: HEAP
    INTEGER, INTENT(IN) :: ITEM
    INTEGER, INTENT(OUT) :: ITEM_OUT

    IF (NHEAP > 0 .AND. ITEM < HEAP(1)) THEN
       ITEM_OUT = HEAP(1)
       HEAP(1) = ITEM
       IF (NHEAP.GT.1) THEN
          CALL HEAP_SIFTUP(HEAP, NHEAP, 1)
       END IF
    ELSE
       ITEM_OUT = ITEM
    END IF
  END SUBROUTINE HEAP_PUSHPOP
   SUBROUTINE ALLOC_MEM_A(X)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: X
    INTEGER, DIMENSION(:), ALLOCATABLE :: ITMP
    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: TMP
    INTEGER :: SZ

    IF (JAC_PRODUCT_MODE) THEN
       RETURN
    END IF
    IF (.NOT.ALLOCATED(SUM_MAP_A)) THEN
       SZ = 0
    ELSE
       SZ = SIZE(SUM_MAP_A)
    END IF

    IF (SZ < 2*FREE_A + 1) THEN
       ! ENLARGE WORK SPACE
       IF (ALLOCATED(SUM_MAP_A)) THEN
          SZ = SZ + 2*FREE_A + 1
          ALLOCATE(ITMP(SZ), TMP(SZ))
          ITMP(1:SIZE(SUM_MAP_A)) = SUM_MAP_A(:)
          TMP(1:SIZE(SUM_MUL_A)) = SUM_MUL_A(:)
          CALL MOVE_ALLOC(ITMP, SUM_MAP_A)
          CALL MOVE_ALLOC(TMP, SUM_MUL_A)
       ELSE
          ALLOCATE(SUM_MAP_A(100), SUM_MUL_A(100))
       END IF
    END IF

    X%I = FREE_A
    FREE_A = FREE_A + 1
  END SUBROUTINE ALLOC_MEM_A

  PURE SUBROUTINE LINK_MEM_A(DST, SRC)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: DST
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: SRC
    DST%I = SRC%I
  END SUBROUTINE LINK_MEM_A

  PURE SUBROUTINE FREE_MEM_A(X)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: X
    X%I = 0
  END SUBROUTINE FREE_MEM_A

  SUBROUTINE SET_INDEPENDENT_A(X, XVAL, J, DX)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(OUT) :: X
    DOUBLE PRECISION, INTENT(IN) :: XVAL
    DOUBLE PRECISION, OPTIONAL, INTENT(IN) :: DX
    INTEGER, INTENT(IN) :: J

    X%VALUE = XVAL
    IF (JAC_PRODUCT_MODE) THEN
       IF (.NOT.PRESENT(DX)) THEN
          CALL FATAL_ERROR('NO DX GIVEN TO ADJAC_SET_INDEPENDENT WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
       END IF
       X%VMUL = DX
    ELSE
       X%VMUL = 1
       CALL ALLOC_MEM_A(X)
       SUM_MAP_A(1 + 2*(X%I-1)) = 0
       SUM_MAP_A(2 + 2*(X%I-1)) = J
    END IF
  END SUBROUTINE SET_INDEPENDENT_A

  SUBROUTINE SET_INDEPENDENT_MANY_A(X, XVAL, DX)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:), INTENT(INOUT) :: X
    DOUBLE PRECISION, DIMENSION(SIZE(X)), INTENT(IN) :: XVAL
    DOUBLE PRECISION, DIMENSION(SIZE(X)), OPTIONAL, INTENT(IN) :: DX

    INTEGER :: J

    IF (PRESENT(DX)) THEN
       DO J = 1, SIZE(X,1)
          CALL SET_INDEPENDENT_A(X(J), XVAL(J), J, DX(J))
       END DO
    ELSE
       DO J = 1, SIZE(X,1)
          CALL SET_INDEPENDENT_A(X(J), XVAL(J), J)
       END DO
    END IF
  END SUBROUTINE SET_INDEPENDENT_MANY_A

  SUBROUTINE GET_VALUE_ONE_A(Y, VAL, DY)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    DOUBLE PRECISION, INTENT(OUT) :: VAL
    DOUBLE PRECISION, OPTIONAL, INTENT(OUT) :: DY
    VAL = Y%VALUE
    IF (PRESENT(DY)) THEN
       IF (.NOT. JAC_PRODUCT_MODE) THEN
          CALL FATAL_ERROR('CALL TO ADJAC_GET_VALUE WITH DY WHEN JACOBIAN PRODUCT MODE IS NOT ACTIVE')
       END IF
       DY = Y%VMUL
    END IF
  END SUBROUTINE GET_VALUE_ONE_A

  SUBROUTINE GET_VALUE_MANY_A(Y, VAL, DY)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:), INTENT(IN) :: Y
    DOUBLE PRECISION, DIMENSION(SIZE(Y,1)), INTENT(OUT) :: VAL
    DOUBLE PRECISION, DIMENSION(SIZE(Y,1)), OPTIONAL, INTENT(OUT) :: DY
    INTEGER :: J
    DO J = 1, SIZE(VAL,1)
       VAL(J) = Y(J)%VALUE
    END DO
    IF (PRESENT(DY)) THEN
       IF (.NOT. JAC_PRODUCT_MODE) THEN
          CALL FATAL_ERROR('CALL TO ADJAC_GET_VALUE WITH DY WHEN JACOBIAN PRODUCT MODE IS NOT ACTIVE')
       END IF
       DO J = 1, SIZE(VAL,1)
          DY(J) = Y(J)%VMUL
       END DO
    END IF
  END SUBROUTINE GET_VALUE_MANY_A

  SUBROUTINE GET_DENSE_JACOBIAN_A(Y, JAC_DENSE)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:), INTENT(INOUT) :: Y
    DOUBLE PRECISION, DIMENSION(:,:), INTENT(OUT) :: JAC_DENSE
    DOUBLE PRECISION, DIMENSION(BLOCK_SIZE,FREE_A) :: WORK
    INTEGER, DIMENSION(FREE_A) :: IWORK, IMASK
    INTEGER :: K, J, IA, IB, KMIN, KMAX, NWORK, J_NEXT

    IF (JAC_PRODUCT_MODE) THEN
       CALL FATAL_ERROR('CALL TO ADJAC_GET_DENSE_JACOBIAN WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
    END IF

    JAC_DENSE = 0

    WORK = 0
    IMASK = 0

    DO KMIN = 1, SIZE(Y,1), BLOCK_SIZE
       KMAX = MIN(KMIN + BLOCK_SIZE - 1, SIZE(Y,1))

       NWORK = 0
       DO K = KMIN, KMAX, 1
          IF (Y(K)%I == 0) CYCLE
          WORK(K-KMIN+1, Y(K)%I) = Y(K)%VMUL
          CALL HEAP_PUSH(IWORK, NWORK, Y(K)%I)
          IMASK(Y(K)%I) = 1
       END DO


    ! TRAVERSE THE TAPE
    J_NEXT = 0
    IF (NWORK > 0) THEN
       CALL HEAP_POP(IWORK, NWORK, J_NEXT)
    END IF
    DO WHILE (J_NEXT > 0)
       J = J_NEXT
       J_NEXT = 0

       IF (256*NWORK > J) THEN
          ! HEAP IS TOO BIG, PROBABLY CONTAINS NEARLY ALL J VALUES,
          ! AND WE ARE BETTER OFF JUST LOOPING THROUGH THEM
          NWORK = J
          EXIT
       END IF

       IA = SUM_MAP_A(1+2*(J-1))
       IB = SUM_MAP_A(2+2*(J-1))

       IF (IA == 0) THEN
          JAC_DENSE(KMIN:KMAX,IB) = WORK(1:(KMAX-KMIN+1),J)
       ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_A(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_A(2+2*(J-1)) * WORK(K,J)
        END DO

          IF (IMASK(IA) == 0 .AND. IMASK(IB) == 0) THEN
             CALL HEAP_PUSH(IWORK, NWORK, IA)
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IA) = 1
             IMASK(IB) = 1
          ELSE IF (IMASK(IA) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IA, J_NEXT)
             IMASK(IA) = 1
          ELSE IF (IMASK(IB) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IB) = 1
          END IF
       END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

       IMASK(J) = 0

       IF (NWORK > 0 .AND. J_NEXT == 0) THEN
         CALL HEAP_POP(IWORK, NWORK, J_NEXT)
       END IF
    END DO
    DO J = NWORK, 1, -1
      IF (IMASK(J).NE.0) THEN
        IA = SUM_MAP_A(1+2*(J-1))
        IB = SUM_MAP_A(2+2*(J-1))
        IF (IA == 0) THEN
          JAC_DENSE(KMIN:KMAX,IB) = WORK(1:(KMAX-KMIN+1),J)
        ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_A(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_A(2+2*(J-1)) * WORK(K,J)
        END DO

          IMASK(IA) = 1
          IMASK(IB) = 1
        END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

        IMASK(J) = 0
      END IF
    END DO

    END DO
  END SUBROUTINE GET_DENSE_JACOBIAN_A

  SUBROUTINE GET_COO_JACOBIAN_A(Y, NNZ, JAC_VAL, JAC_I, JAC_J)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:), INTENT(INOUT) :: Y
    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: JAC_VAL
    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: JAC_I, JAC_J
    INTEGER, INTENT(OUT) :: NNZ
    DOUBLE PRECISION, DIMENSION(BLOCK_SIZE,FREE_A) :: WORK
    INTEGER, DIMENSION(FREE_A) :: IWORK, IMASK
    INTEGER, DIMENSION(:), ALLOCATABLE :: ITMP
    DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: VTMP
    INTEGER :: KMIN, KMAX, K, J, IA, IB, NWORK, J_NEXT, SZ

    IF (JAC_PRODUCT_MODE) THEN
       CALL FATAL_ERROR('CALL TO ADJAC_GET_COO_JACOBIAN WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
    END IF

    IF (ALLOCATED(JAC_VAL)) DEALLOCATE(JAC_VAL)
    IF (ALLOCATED(JAC_I)) DEALLOCATE(JAC_I)
    IF (ALLOCATED(JAC_J)) DEALLOCATE(JAC_J)

    SZ = FREE_A + 10
    ALLOCATE(JAC_VAL(SZ), JAC_I(SZ), JAC_J(SZ))

    NNZ = 0
    WORK = 0
    IMASK = 0

    DO KMIN = 1, SIZE(Y,1), BLOCK_SIZE
       KMAX = MIN(KMIN + BLOCK_SIZE - 1, SIZE(Y,1))

       NWORK = 0
       DO K = KMIN, KMAX, 1
          IF (Y(K)%I == 0) CYCLE
          WORK(K-KMIN+1, Y(K)%I) = Y(K)%VMUL
          CALL HEAP_PUSH(IWORK, NWORK, Y(K)%I)
          IMASK(Y(K)%I) = 1
       END DO


    ! TRAVERSE THE TAPE
    J_NEXT = 0
    IF (NWORK > 0) THEN
       CALL HEAP_POP(IWORK, NWORK, J_NEXT)
    END IF
    DO WHILE (J_NEXT > 0)
       J = J_NEXT
       J_NEXT = 0

       IF (256*NWORK > J) THEN
          ! HEAP IS TOO BIG, PROBABLY CONTAINS NEARLY ALL J VALUES,
          ! AND WE ARE BETTER OFF JUST LOOPING THROUGH THEM
          NWORK = J
          EXIT
       END IF

       IA = SUM_MAP_A(1+2*(J-1))
       IB = SUM_MAP_A(2+2*(J-1))

       IF (IA == 0) THEN

            IF (NNZ + (KMAX-KMIN) + 1 >= SZ) THEN
               ! EXPONENTIAL OVERALLOCATION
               SZ = 2*SZ + (KMAX-KMIN) + 1

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_I(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_I)

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_J(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_J)

               ALLOCATE(VTMP(SZ))
               VTMP(1:NNZ) = JAC_VAL(1:NNZ)
               CALL MOVE_ALLOC(VTMP, JAC_VAL)
            END IF
            DO K = KMIN, KMAX
               IF (WORK(K-KMIN+1,J).NE.0) THEN
                   NNZ = NNZ + 1
                   JAC_I(NNZ) = K
                   JAC_J(NNZ) = IB
                   JAC_VAL(NNZ) = WORK(K-KMIN+1,J)
                END IF
            END DO

       ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_A(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_A(2+2*(J-1)) * WORK(K,J)
        END DO

          IF (IMASK(IA) == 0 .AND. IMASK(IB) == 0) THEN
             CALL HEAP_PUSH(IWORK, NWORK, IA)
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IA) = 1
             IMASK(IB) = 1
          ELSE IF (IMASK(IA) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IA, J_NEXT)
             IMASK(IA) = 1
          ELSE IF (IMASK(IB) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IB) = 1
          END IF
       END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

       IMASK(J) = 0

       IF (NWORK > 0 .AND. J_NEXT == 0) THEN
         CALL HEAP_POP(IWORK, NWORK, J_NEXT)
       END IF
    END DO
    DO J = NWORK, 1, -1
      IF (IMASK(J).NE.0) THEN
        IA = SUM_MAP_A(1+2*(J-1))
        IB = SUM_MAP_A(2+2*(J-1))
        IF (IA == 0) THEN

            IF (NNZ + (KMAX-KMIN) + 1 >= SZ) THEN
               ! EXPONENTIAL OVERALLOCATION
               SZ = 2*SZ + (KMAX-KMIN) + 1

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_I(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_I)

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_J(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_J)

               ALLOCATE(VTMP(SZ))
               VTMP(1:NNZ) = JAC_VAL(1:NNZ)
               CALL MOVE_ALLOC(VTMP, JAC_VAL)
            END IF
            DO K = KMIN, KMAX
               IF (WORK(K-KMIN+1,J).NE.0) THEN
                   NNZ = NNZ + 1
                   JAC_I(NNZ) = K
                   JAC_J(NNZ) = IB
                   JAC_VAL(NNZ) = WORK(K-KMIN+1,J)
                END IF
            END DO

        ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_A(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_A(2+2*(J-1)) * WORK(K,J)
        END DO

          IMASK(IA) = 1
          IMASK(IB) = 1
        END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

        IMASK(J) = 0
      END IF
    END DO

    END DO

    IF (NNZ .EQ. 0) THEN
       IF (ALLOCATED(JAC_VAL)) DEALLOCATE(JAC_VAL)
       IF (ALLOCATED(JAC_I)) DEALLOCATE(JAC_I)
       IF (ALLOCATED(JAC_J)) DEALLOCATE(JAC_J)
    ELSE IF (NNZ < SZ) THEN
       ! SHRINK TO SIZE
       ALLOCATE(ITMP(NNZ))
       ITMP(1:NNZ) = JAC_I(1:NNZ)
       CALL MOVE_ALLOC(ITMP, JAC_I)
       ALLOCATE(ITMP(NNZ))
       ITMP(1:NNZ) = JAC_J(1:NNZ)
       CALL MOVE_ALLOC(ITMP, JAC_J)
       ALLOCATE(VTMP(NNZ))
       VTMP(1:NNZ) = JAC_VAL(1:NNZ)
       CALL MOVE_ALLOC(VTMP, JAC_VAL)
    END IF
  END SUBROUTINE GET_COO_JACOBIAN_A

   SUBROUTINE SUM_TAYLOR_A(ALPHAP, BETAP, A, B, C)
    ! C := ALPHA*A + BETA*B
    USE ISO_C_BINDING
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: ALPHAP, BETAP
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: A, B
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: C

    IF (JAC_PRODUCT_MODE) THEN
       C%VMUL = ALPHAP * A%VMUL + BETAP * B%VMUL
    ELSE
       IF (A%VMUL == 0 .OR. A%I == 0 .OR. ALPHAP == 0) THEN
          C%VMUL = BETAP * B%VMUL
          C%I = B%I
       ELSE IF (B%VMUL == 0 .OR. B%I == 0 .OR. BETAP == 0) THEN
          C%VMUL = ALPHAP * A%VMUL
          C%I = A%I
       ELSE IF (A%I == B%I) THEN
          C%VMUL = ALPHAP * A%VMUL + BETAP * B%VMUL
          C%I = A%I
       ELSE
          CALL ALLOC_MEM_A(C)
          C%VMUL = 1
          SUM_MAP_A(1 + 2*(C%I-1)) = A%I
          SUM_MAP_A(2 + 2*(C%I-1)) = B%I
          SUM_MUL_A(1 + 2*(C%I-1)) = ALPHAP * A%VMUL
          SUM_MUL_A(2 + 2*(C%I-1)) = BETAP * B%VMUL
       END IF
    END IF
  END SUBROUTINE SUM_TAYLOR_A


  !--------------------------------------------------------------------------
  ! OVERLOADED OPERATORS
  !--------------------------------------------------------------------------

  !!
  !! ASSIGNMENT(=)
  !!

  PURE ELEMENTAL SUBROUTINE ASSIGN_AI(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: X
    INTEGER, INTENT(IN) :: Y
    CALL FREE_MEM_A(X)
    X%VALUE = Y
    X%VMUL = 0
  END SUBROUTINE ASSIGN_AI
  PURE ELEMENTAL SUBROUTINE ASSIGN_AD(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(INOUT) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    CALL FREE_MEM_A(X)
    X%VALUE = Y
    X%VMUL = 0
  END SUBROUTINE ASSIGN_AD
  PURE ELEMENTAL SUBROUTINE ASSIGN_BI(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(INOUT) :: X
    INTEGER, INTENT(IN) :: Y
    X%RE = DBLE(Y)
    X%IM = 0D0
  END SUBROUTINE ASSIGN_BI
  PURE ELEMENTAL SUBROUTINE ASSIGN_BD(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(INOUT) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    X%RE = DBLE(Y)
    X%IM = 0D0
  END SUBROUTINE ASSIGN_BD

  PURE ELEMENTAL SUBROUTINE ASSIGN_BZ(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(INOUT) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    X%RE = DBLE(Y)
    X%IM = AIMAG(Y)
  END SUBROUTINE ASSIGN_BZ

  PURE ELEMENTAL SUBROUTINE ASSIGN_BA(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(INOUT) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    X%RE = Y
    X%IM = 0D0
  END SUBROUTINE ASSIGN_BA

  !!
  !! OPERATOR(+)
  !!

  ! X + Y = X + Y + (X_J + Y_J) DJ

  IMPURE ELEMENTAL FUNCTION ADD_AA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X, Y
    TYPE(ADJAC_DOUBLE) :: Z

    Z%VALUE = X%VALUE + Y%VALUE
    CALL SUM_TAYLOR(REAL(1D0, KIND=KIND(0D0)), REAL(1D0, KIND=KIND(0D0)), X, Y, Z)
  END FUNCTION ADD_AA

  PURE ELEMENTAL FUNCTION ADD_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X%VALUE + Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_A(Z, X)
  END FUNCTION ADD_AI

  PURE ELEMENTAL FUNCTION ADD_IA(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = Y + X
  END FUNCTION ADD_IA
  PURE ELEMENTAL FUNCTION ADD_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X%VALUE + Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_A(Z, X)
  END FUNCTION ADD_AD

  PURE ELEMENTAL FUNCTION ADD_DA(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = Y + X
  END FUNCTION ADD_DA
  PURE ELEMENTAL FUNCTION ADD_AZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X + DBLE(Y)
    Z%IM = AIMAG(Y)
  END FUNCTION ADD_AZ

  PURE ELEMENTAL FUNCTION ADD_ZA(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) + Y
    Z%IM = AIMAG(X)
  END FUNCTION ADD_ZA

  IMPURE ELEMENTAL FUNCTION ADD_BB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE + Y%RE
    Z%IM = X%IM + Y%IM
  END FUNCTION ADD_BB

  PURE ELEMENTAL FUNCTION ADD_BZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE + DBLE(Y)
    Z%IM = X%IM + AIMAG(Y)
  END FUNCTION ADD_BZ

  PURE ELEMENTAL FUNCTION ADD_ZB(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) + Y%RE
    Z%IM = AIMAG(X) + Y%IM
  END FUNCTION ADD_ZB

  IMPURE ELEMENTAL FUNCTION ADD_BA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE + Y
    Z%IM = X%IM
  END FUNCTION ADD_BA

  IMPURE ELEMENTAL FUNCTION ADD_AB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X + Y%RE
    Z%IM = Y%IM
  END FUNCTION ADD_AB

  PURE ELEMENTAL FUNCTION ADD_BI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X + CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION ADD_BI

  PURE ELEMENTAL FUNCTION ADD_IB(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) + Y
  END FUNCTION ADD_IB
  PURE ELEMENTAL FUNCTION ADD_BD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X + CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION ADD_BD

  PURE ELEMENTAL FUNCTION ADD_DB(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) + Y
  END FUNCTION ADD_DB

  !!
  !! OPERATOR(+), UNARY
  !!

  PURE ELEMENTAL FUNCTION POS_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    Z = X
  END FUNCTION POS_A

  PURE ELEMENTAL FUNCTION POS_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X
  END FUNCTION POS_B

  !!
  !! OPERATOR(-)
  !!

  ! X - Y = X - Y + (X_J - Y_J) DJ

  IMPURE ELEMENTAL FUNCTION SUB_AA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X, Y
    TYPE(ADJAC_DOUBLE) :: Z

    Z%VALUE = X%VALUE - Y%VALUE
    CALL SUM_TAYLOR(REAL(1D0, KIND=KIND(0D0)), REAL(-1D0, KIND=KIND(0D0)), X, Y, Z)
  END FUNCTION SUB_AA

  PURE ELEMENTAL FUNCTION SUB_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X%VALUE - Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_A(Z, X)
  END FUNCTION SUB_AI

  PURE ELEMENTAL FUNCTION SUB_IA(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X - Y%VALUE
    Z%VMUL = -Y%VMUL
    CALL LINK_MEM_A(Z, Y)
  END FUNCTION SUB_IA
  PURE ELEMENTAL FUNCTION SUB_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X%VALUE - Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_A(Z, X)
  END FUNCTION SUB_AD

  PURE ELEMENTAL FUNCTION SUB_DA(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X - Y%VALUE
    Z%VMUL = -Y%VMUL
    CALL LINK_MEM_A(Z, Y)
  END FUNCTION SUB_DA
  PURE ELEMENTAL FUNCTION SUB_AZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X - DBLE(Y)
    Z%IM = -AIMAG(Y)
  END FUNCTION SUB_AZ

  PURE ELEMENTAL FUNCTION SUB_ZA(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) - Y
    Z%IM = AIMAG(X)
  END FUNCTION SUB_ZA

  IMPURE ELEMENTAL FUNCTION SUB_BB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE - Y%RE
    Z%IM = X%IM - Y%IM
  END FUNCTION SUB_BB

  PURE ELEMENTAL FUNCTION SUB_BZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE - DBLE(Y)
    Z%IM = X%IM - AIMAG(Y)
  END FUNCTION SUB_BZ

  PURE ELEMENTAL FUNCTION SUB_ZB(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) - Y%RE
    Z%IM = AIMAG(X) - Y%IM
  END FUNCTION SUB_ZB

  IMPURE ELEMENTAL FUNCTION SUB_BA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE - Y
    Z%IM = X%IM
  END FUNCTION SUB_BA

  IMPURE ELEMENTAL FUNCTION SUB_AB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X - Y%RE
    Z%IM = -Y%IM
  END FUNCTION SUB_AB

  PURE ELEMENTAL FUNCTION SUB_BI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X - CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION SUB_BI

  PURE ELEMENTAL FUNCTION SUB_IB(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) - Y
  END FUNCTION SUB_IB
  PURE ELEMENTAL FUNCTION SUB_BD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X - CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION SUB_BD

  PURE ELEMENTAL FUNCTION SUB_DB(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) - Y
  END FUNCTION SUB_DB

  !!
  !! OPERATOR(-), UNARY
  !!

  PURE ELEMENTAL FUNCTION NEG_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    Z = 0D0 - X
  END FUNCTION NEG_A

  PURE ELEMENTAL FUNCTION NEG_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    Z = (0D0,0D0) - X
  END FUNCTION NEG_B

  !!
  !! OPERATOR(*)
  !!

  ! X*Y = X*Y + (X Y_J + Y X_J) DJ

  IMPURE ELEMENTAL FUNCTION MUL_AA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X, Y
    TYPE(ADJAC_DOUBLE) :: Z

    Z%VALUE = X%VALUE * Y%VALUE
    CALL SUM_TAYLOR(Y%VALUE, X%VALUE, X, Y, Z)
  END FUNCTION MUL_AA

  PURE ELEMENTAL FUNCTION MUL_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    IF (Y == 0) THEN
       Z%VALUE = 0
       Z%VMUL = 0
       CALL FREE_MEM_A(Z)
    ELSE
       Z%VALUE = X%VALUE * Y
       Z%VMUL = X%VMUL * Y
       CALL LINK_MEM_A(Z, X)
    END IF
  END FUNCTION MUL_AI

  PURE ELEMENTAL FUNCTION MUL_IA(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = Y * X
  END FUNCTION MUL_IA
  PURE ELEMENTAL FUNCTION MUL_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    IF (Y == 0) THEN
       Z%VALUE = 0
       Z%VMUL = 0
       CALL FREE_MEM_A(Z)
    ELSE
       Z%VALUE = X%VALUE * Y
       Z%VMUL = X%VMUL * Y
       CALL LINK_MEM_A(Z, X)
    END IF
  END FUNCTION MUL_AD

  PURE ELEMENTAL FUNCTION MUL_DA(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = Y * X
  END FUNCTION MUL_DA
  PURE ELEMENTAL FUNCTION MUL_AZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X * DBLE(Y)
    Z%IM = X * AIMAG(Y)
  END FUNCTION MUL_AZ

  PURE ELEMENTAL FUNCTION MUL_ZA(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) * Y
    Z%IM = AIMAG(X) * Y
  END FUNCTION MUL_ZA

  IMPURE ELEMENTAL FUNCTION MUL_BB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE * Y%RE - X%IM * Y%IM
    Z%IM = X%RE * Y%IM + X%IM * Y%RE
  END FUNCTION MUL_BB

  IMPURE ELEMENTAL FUNCTION MUL_BZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE * DBLE(Y) - X%IM * AIMAG(Y)
    Z%IM = X%RE * AIMAG(Y) + X%IM * DBLE(Y)
  END FUNCTION MUL_BZ

  IMPURE ELEMENTAL FUNCTION MUL_ZB(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) * Y%RE - AIMAG(X) * Y%IM
    Z%IM = DBLE(X) * Y%IM + AIMAG(X) * Y%RE
  END FUNCTION MUL_ZB

  IMPURE ELEMENTAL FUNCTION MUL_BA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE * Y
    Z%IM = X%IM * Y
  END FUNCTION MUL_BA

  IMPURE ELEMENTAL FUNCTION MUL_AB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X * Y%RE
    Z%IM = X * Y%IM
  END FUNCTION MUL_AB

  IMPURE ELEMENTAL FUNCTION MUL_BI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION MUL_BI

  IMPURE ELEMENTAL FUNCTION MUL_IB(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) * Y
  END FUNCTION MUL_IB
  IMPURE ELEMENTAL FUNCTION MUL_BD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CMPLX(Y, KIND=KIND(0D0))
  END FUNCTION MUL_BD

  IMPURE ELEMENTAL FUNCTION MUL_DB(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) * Y
  END FUNCTION MUL_DB

  !!
  !! OPERATOR(/)
  !!

  ! X/Y = X/Y + (X_J/Y - X Y_J/Y**2) DJ

  IMPURE ELEMENTAL FUNCTION DIV_AA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X, Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z%VALUE = X%VALUE / Y%VALUE
    CALL SUM_TAYLOR(1D0/Y%VALUE, -X%VALUE/(Y%VALUE**2), X, Y, Z)
  END FUNCTION DIV_AA

  PURE ELEMENTAL FUNCTION DIV_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = (1D0 / Y) * X
  END FUNCTION DIV_AI

  PURE ELEMENTAL FUNCTION DIV_IA(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = (-X / (Y%VALUE**2)) * Y
    Z%VALUE = X / Y%VALUE
  END FUNCTION DIV_IA
  PURE ELEMENTAL FUNCTION DIV_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = (1D0 / Y) * X
  END FUNCTION DIV_AD

  PURE ELEMENTAL FUNCTION DIV_DA(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = (-X / (Y%VALUE**2)) * Y
    Z%VALUE = X / Y%VALUE
  END FUNCTION DIV_DA
  PURE ELEMENTAL FUNCTION DIV_AZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    COMPLEX(KIND=KIND(0D0)) :: Q
    Q = CONJG(Y) / (DBLE(Y)*DBLE(Y) + AIMAG(Y)*AIMAG(Y))
    Z%RE = DBLE(Q) * X
    Z%IM = AIMAG(Q) * X
  END FUNCTION DIV_AZ

  PURE ELEMENTAL FUNCTION DIV_ZA(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = DBLE(X) / Y
    Z%IM = AIMAG(X) / Y
  END FUNCTION DIV_ZA

  IMPURE ELEMENTAL FUNCTION DIV_BB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CONJG(Y) / (DBLE(Y)*DBLE(Y) + AIMAG(Y)*AIMAG(Y))
  END FUNCTION DIV_BB

  IMPURE ELEMENTAL FUNCTION DIV_BZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CONJG(Y) / (DBLE(Y)*DBLE(Y) + AIMAG(Y)*AIMAG(Y))
  END FUNCTION DIV_BZ

  IMPURE ELEMENTAL FUNCTION DIV_ZB(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CONJG(Y) / (DBLE(Y)*DBLE(Y) + AIMAG(Y)*AIMAG(Y))
  END FUNCTION DIV_ZB

  IMPURE ELEMENTAL FUNCTION DIV_BA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE / Y
    Z%IM = X%IM / Y
  END FUNCTION DIV_BA

  IMPURE ELEMENTAL FUNCTION DIV_AB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = X * CONJG(Y) / (DBLE(Y)*DBLE(Y) + AIMAG(Y)*AIMAG(Y))
  END FUNCTION DIV_AB

  IMPURE ELEMENTAL FUNCTION DIV_BI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE / Y
    Z%IM = X%IM / Y
  END FUNCTION DIV_BI

  IMPURE ELEMENTAL FUNCTION DIV_IB(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) / Y
  END FUNCTION DIV_IB
  IMPURE ELEMENTAL FUNCTION DIV_BD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE / Y
    Z%IM = X%IM / Y
  END FUNCTION DIV_BD

  IMPURE ELEMENTAL FUNCTION DIV_DB(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX) :: Z
    Z = CMPLX(X, KIND=KIND(0D0)) / Y
  END FUNCTION DIV_DB

  !!
  !! OPERATOR(**)
  !!

  PURE ELEMENTAL FUNCTION POW_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = EXP(Y * LOG(X))
  END FUNCTION POW_AI
  PURE ELEMENTAL FUNCTION POW_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE) :: Z
    Z = EXP(Y * LOG(X))
  END FUNCTION POW_AD

  !!
  !! MATMUL
  !!

  FUNCTION MATMUL_AA(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:,:), INTENT(IN) :: X, Y
    TYPE(ADJAC_DOUBLE), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_AA

  FUNCTION MATMUL_AI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:,:), INTENT(IN) :: X
    INTEGER, DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_AI

  FUNCTION MATMUL_IA(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_IA
  FUNCTION MATMUL_AD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), DIMENSION(:,:), INTENT(IN) :: X
    DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_AD

  FUNCTION MATMUL_DA(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_DOUBLE), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_DA
  FUNCTION MATMUL_BB(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), DIMENSION(:,:), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEX), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_BB

  FUNCTION MATMUL_BZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), DIMENSION(:,:), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_BZ

  FUNCTION MATMUL_ZB(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEX), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_ZB

  !!
  !! DBLE
  !!

  PURE ELEMENTAL FUNCTION DBLE_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    Z = X
  END FUNCTION DBLE_A

  PURE ELEMENTAL FUNCTION DBLE_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    Z = X%RE
  END FUNCTION DBLE_B

  !!
  !! AIMAG
  !!

  PURE ELEMENTAL FUNCTION AIMAG_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    Z = X%IM
  END FUNCTION AIMAG_B

  !!
  !! CONJG
  !!

  PURE ELEMENTAL FUNCTION CONJG_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    Z%RE = X%RE
    Z%IM = -X%IM
  END FUNCTION CONJG_B

  !!
  !! EXP
  !!

  PURE ELEMENTAL FUNCTION EXP_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    DOUBLE PRECISION :: V, DV
    V = EXP(X%VALUE)
    DV = V
    Z = DV*X
    Z%VALUE = V
  END FUNCTION EXP_A

  IMPURE ELEMENTAL FUNCTION EXP_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = EXP(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    DV = V
    Z = DV*X
    Z%RE%VALUE = DBLE(V)
    Z%IM%VALUE = AIMAG(V)
  END FUNCTION EXP_B

  !!
  !! SIN
  !!

  PURE ELEMENTAL FUNCTION SIN_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    DOUBLE PRECISION :: V, DV
    V = SIN(X%VALUE)
    DV = COS(X%VALUE)
    Z = DV*X
    Z%VALUE = V
  END FUNCTION SIN_A

  IMPURE ELEMENTAL FUNCTION SIN_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = SIN(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    DV = COS(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    Z = DV*X
    Z%RE%VALUE = DBLE(V)
    Z%IM%VALUE = AIMAG(V)
  END FUNCTION SIN_B

  !!
  !! COS
  !!

  PURE ELEMENTAL FUNCTION COS_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    DOUBLE PRECISION :: V, DV
    V = COS(X%VALUE)
    DV = -SIN(X%VALUE)
    Z = DV*X
    Z%VALUE = V
  END FUNCTION COS_A

  IMPURE ELEMENTAL FUNCTION COS_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = COS(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    DV = -SIN(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    Z = DV*X
    Z%RE%VALUE = DBLE(V)
    Z%IM%VALUE = AIMAG(V)
  END FUNCTION COS_B

  !!
  !! LOG
  !!

  PURE ELEMENTAL FUNCTION LOG_A(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_DOUBLE), INTENT(IN) :: X
    TYPE(ADJAC_DOUBLE) :: Z
    DOUBLE PRECISION :: V, DV
    V = LOG(X%VALUE)
    DV = 1D0/X%VALUE
    Z = DV*X
    Z%VALUE = V
  END FUNCTION LOG_A

  IMPURE ELEMENTAL FUNCTION LOG_B(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEX), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEX) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = LOG(CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0)))
    DV = 1D0/CMPLX(X%RE%VALUE, X%IM%VALUE, KIND=KIND(0D0))
    Z = DV*X
    Z%RE%VALUE = DBLE(V)
    Z%IM%VALUE = AIMAG(V)
  END FUNCTION LOG_B
   SUBROUTINE ALLOC_MEM_Q(X)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: X
    INTEGER, DIMENSION(:), ALLOCATABLE :: ITMP
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:), ALLOCATABLE :: TMP
    INTEGER :: SZ

    IF (JAC_PRODUCT_MODE) THEN
       RETURN
    END IF
    IF (.NOT.ALLOCATED(SUM_MAP_Q)) THEN
       SZ = 0
    ELSE
       SZ = SIZE(SUM_MAP_Q)
    END IF

    IF (SZ < 2*FREE_Q + 1) THEN
       ! ENLARGE WORK SPACE
       IF (ALLOCATED(SUM_MAP_Q)) THEN
          SZ = SZ + 2*FREE_Q + 1
          ALLOCATE(ITMP(SZ), TMP(SZ))
          ITMP(1:SIZE(SUM_MAP_Q)) = SUM_MAP_Q(:)
          TMP(1:SIZE(SUM_MUL_Q)) = SUM_MUL_Q(:)
          CALL MOVE_ALLOC(ITMP, SUM_MAP_Q)
          CALL MOVE_ALLOC(TMP, SUM_MUL_Q)
       ELSE
          ALLOCATE(SUM_MAP_Q(100), SUM_MUL_Q(100))
       END IF
    END IF

    X%I = FREE_Q
    FREE_Q = FREE_Q + 1
  END SUBROUTINE ALLOC_MEM_Q

  PURE SUBROUTINE LINK_MEM_Q(DST, SRC)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: DST
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: SRC
    DST%I = SRC%I
  END SUBROUTINE LINK_MEM_Q

  PURE SUBROUTINE FREE_MEM_Q(X)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: X
    X%I = 0
  END SUBROUTINE FREE_MEM_Q

  SUBROUTINE SET_INDEPENDENT_Q(X, XVAL, J, DX)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(OUT) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: XVAL
    COMPLEX(KIND=KIND(0D0)), OPTIONAL, INTENT(IN) :: DX
    INTEGER, INTENT(IN) :: J

    X%VALUE = XVAL
    IF (JAC_PRODUCT_MODE) THEN
       IF (.NOT.PRESENT(DX)) THEN
          CALL FATAL_ERROR('NO DX GIVEN TO ADJAC_SET_INDEPENDENT WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
       END IF
       X%VMUL = DX
    ELSE
       X%VMUL = 1
       CALL ALLOC_MEM_Q(X)
       SUM_MAP_Q(1 + 2*(X%I-1)) = 0
       SUM_MAP_Q(2 + 2*(X%I-1)) = J
    END IF
  END SUBROUTINE SET_INDEPENDENT_Q

  SUBROUTINE SET_INDEPENDENT_MANY_Q(X, XVAL, DX)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:), INTENT(INOUT) :: X
    COMPLEX(KIND=KIND(0D0)), DIMENSION(SIZE(X)), INTENT(IN) :: XVAL
    COMPLEX(KIND=KIND(0D0)), DIMENSION(SIZE(X)), OPTIONAL, INTENT(IN) :: DX

    INTEGER :: J

    IF (PRESENT(DX)) THEN
       DO J = 1, SIZE(X,1)
          CALL SET_INDEPENDENT_Q(X(J), XVAL(J), J, DX(J))
       END DO
    ELSE
       DO J = 1, SIZE(X,1)
          CALL SET_INDEPENDENT_Q(X(J), XVAL(J), J)
       END DO
    END IF
  END SUBROUTINE SET_INDEPENDENT_MANY_Q

  SUBROUTINE GET_VALUE_ONE_Q(Y, VAL, DY)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    COMPLEX(KIND=KIND(0D0)), INTENT(OUT) :: VAL
    COMPLEX(KIND=KIND(0D0)), OPTIONAL, INTENT(OUT) :: DY
    VAL = Y%VALUE
    IF (PRESENT(DY)) THEN
       IF (.NOT. JAC_PRODUCT_MODE) THEN
          CALL FATAL_ERROR('CALL TO ADJAC_GET_VALUE WITH DY WHEN JACOBIAN PRODUCT MODE IS NOT ACTIVE')
       END IF
       DY = Y%VMUL
    END IF
  END SUBROUTINE GET_VALUE_ONE_Q

  SUBROUTINE GET_VALUE_MANY_Q(Y, VAL, DY)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:), INTENT(IN) :: Y
    COMPLEX(KIND=KIND(0D0)), DIMENSION(SIZE(Y,1)), INTENT(OUT) :: VAL
    COMPLEX(KIND=KIND(0D0)), DIMENSION(SIZE(Y,1)), OPTIONAL, INTENT(OUT) :: DY
    INTEGER :: J
    DO J = 1, SIZE(VAL,1)
       VAL(J) = Y(J)%VALUE
    END DO
    IF (PRESENT(DY)) THEN
       IF (.NOT. JAC_PRODUCT_MODE) THEN
          CALL FATAL_ERROR('CALL TO ADJAC_GET_VALUE WITH DY WHEN JACOBIAN PRODUCT MODE IS NOT ACTIVE')
       END IF
       DO J = 1, SIZE(VAL,1)
          DY(J) = Y(J)%VMUL
       END DO
    END IF
  END SUBROUTINE GET_VALUE_MANY_Q

  SUBROUTINE GET_DENSE_JACOBIAN_Q(Y, JAC_DENSE)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:), INTENT(INOUT) :: Y
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:,:), INTENT(OUT) :: JAC_DENSE
    COMPLEX(KIND=KIND(0D0)), DIMENSION(BLOCK_SIZE,FREE_Q) :: WORK
    INTEGER, DIMENSION(FREE_Q) :: IWORK, IMASK
    INTEGER :: K, J, IA, IB, KMIN, KMAX, NWORK, J_NEXT

    IF (JAC_PRODUCT_MODE) THEN
       CALL FATAL_ERROR('CALL TO ADJAC_GET_DENSE_JACOBIAN WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
    END IF

    JAC_DENSE = 0

    WORK = 0
    IMASK = 0

    DO KMIN = 1, SIZE(Y,1), BLOCK_SIZE
       KMAX = MIN(KMIN + BLOCK_SIZE - 1, SIZE(Y,1))

       NWORK = 0
       DO K = KMIN, KMAX, 1
          IF (Y(K)%I == 0) CYCLE
          WORK(K-KMIN+1, Y(K)%I) = Y(K)%VMUL
          CALL HEAP_PUSH(IWORK, NWORK, Y(K)%I)
          IMASK(Y(K)%I) = 1
       END DO


    ! TRAVERSE THE TAPE
    J_NEXT = 0
    IF (NWORK > 0) THEN
       CALL HEAP_POP(IWORK, NWORK, J_NEXT)
    END IF
    DO WHILE (J_NEXT > 0)
       J = J_NEXT
       J_NEXT = 0

       IF (256*NWORK > J) THEN
          ! HEAP IS TOO BIG, PROBABLY CONTAINS NEARLY ALL J VALUES,
          ! AND WE ARE BETTER OFF JUST LOOPING THROUGH THEM
          NWORK = J
          EXIT
       END IF

       IA = SUM_MAP_Q(1+2*(J-1))
       IB = SUM_MAP_Q(2+2*(J-1))

       IF (IA == 0) THEN
          JAC_DENSE(KMIN:KMAX,IB) = WORK(1:(KMAX-KMIN+1),J)
       ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_Q(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_Q(2+2*(J-1)) * WORK(K,J)
        END DO

          IF (IMASK(IA) == 0 .AND. IMASK(IB) == 0) THEN
             CALL HEAP_PUSH(IWORK, NWORK, IA)
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IA) = 1
             IMASK(IB) = 1
          ELSE IF (IMASK(IA) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IA, J_NEXT)
             IMASK(IA) = 1
          ELSE IF (IMASK(IB) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IB) = 1
          END IF
       END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

       IMASK(J) = 0

       IF (NWORK > 0 .AND. J_NEXT == 0) THEN
         CALL HEAP_POP(IWORK, NWORK, J_NEXT)
       END IF
    END DO
    DO J = NWORK, 1, -1
      IF (IMASK(J).NE.0) THEN
        IA = SUM_MAP_Q(1+2*(J-1))
        IB = SUM_MAP_Q(2+2*(J-1))
        IF (IA == 0) THEN
          JAC_DENSE(KMIN:KMAX,IB) = WORK(1:(KMAX-KMIN+1),J)
        ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_Q(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_Q(2+2*(J-1)) * WORK(K,J)
        END DO

          IMASK(IA) = 1
          IMASK(IB) = 1
        END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

        IMASK(J) = 0
      END IF
    END DO

    END DO
  END SUBROUTINE GET_DENSE_JACOBIAN_Q

  SUBROUTINE GET_COO_JACOBIAN_Q(Y, NNZ, JAC_VAL, JAC_I, JAC_J)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:), INTENT(INOUT) :: Y
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: JAC_VAL
    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT(INOUT) :: JAC_I, JAC_J
    INTEGER, INTENT(OUT) :: NNZ
    COMPLEX(KIND=KIND(0D0)), DIMENSION(BLOCK_SIZE,FREE_Q) :: WORK
    INTEGER, DIMENSION(FREE_Q) :: IWORK, IMASK
    INTEGER, DIMENSION(:), ALLOCATABLE :: ITMP
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:), ALLOCATABLE :: VTMP
    INTEGER :: KMIN, KMAX, K, J, IA, IB, NWORK, J_NEXT, SZ

    IF (JAC_PRODUCT_MODE) THEN
       CALL FATAL_ERROR('CALL TO ADJAC_GET_COO_JACOBIAN WHEN JACOBIAN PRODUCT MODE IS ACTIVE')
    END IF

    IF (ALLOCATED(JAC_VAL)) DEALLOCATE(JAC_VAL)
    IF (ALLOCATED(JAC_I)) DEALLOCATE(JAC_I)
    IF (ALLOCATED(JAC_J)) DEALLOCATE(JAC_J)

    SZ = FREE_Q + 10
    ALLOCATE(JAC_VAL(SZ), JAC_I(SZ), JAC_J(SZ))

    NNZ = 0
    WORK = 0
    IMASK = 0

    DO KMIN = 1, SIZE(Y,1), BLOCK_SIZE
       KMAX = MIN(KMIN + BLOCK_SIZE - 1, SIZE(Y,1))

       NWORK = 0
       DO K = KMIN, KMAX, 1
          IF (Y(K)%I == 0) CYCLE
          WORK(K-KMIN+1, Y(K)%I) = Y(K)%VMUL
          CALL HEAP_PUSH(IWORK, NWORK, Y(K)%I)
          IMASK(Y(K)%I) = 1
       END DO


    ! TRAVERSE THE TAPE
    J_NEXT = 0
    IF (NWORK > 0) THEN
       CALL HEAP_POP(IWORK, NWORK, J_NEXT)
    END IF
    DO WHILE (J_NEXT > 0)
       J = J_NEXT
       J_NEXT = 0

       IF (256*NWORK > J) THEN
          ! HEAP IS TOO BIG, PROBABLY CONTAINS NEARLY ALL J VALUES,
          ! AND WE ARE BETTER OFF JUST LOOPING THROUGH THEM
          NWORK = J
          EXIT
       END IF

       IA = SUM_MAP_Q(1+2*(J-1))
       IB = SUM_MAP_Q(2+2*(J-1))

       IF (IA == 0) THEN

            IF (NNZ + (KMAX-KMIN) + 1 >= SZ) THEN
               ! EXPONENTIAL OVERALLOCATION
               SZ = 2*SZ + (KMAX-KMIN) + 1

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_I(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_I)

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_J(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_J)

               ALLOCATE(VTMP(SZ))
               VTMP(1:NNZ) = JAC_VAL(1:NNZ)
               CALL MOVE_ALLOC(VTMP, JAC_VAL)
            END IF
            DO K = KMIN, KMAX
               IF (WORK(K-KMIN+1,J).NE.0) THEN
                   NNZ = NNZ + 1
                   JAC_I(NNZ) = K
                   JAC_J(NNZ) = IB
                   JAC_VAL(NNZ) = WORK(K-KMIN+1,J)
                END IF
            END DO

       ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_Q(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_Q(2+2*(J-1)) * WORK(K,J)
        END DO

          IF (IMASK(IA) == 0 .AND. IMASK(IB) == 0) THEN
             CALL HEAP_PUSH(IWORK, NWORK, IA)
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IA) = 1
             IMASK(IB) = 1
          ELSE IF (IMASK(IA) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IA, J_NEXT)
             IMASK(IA) = 1
          ELSE IF (IMASK(IB) == 0) THEN
             CALL HEAP_PUSHPOP(IWORK, NWORK, IB, J_NEXT)
             IMASK(IB) = 1
          END IF
       END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

       IMASK(J) = 0

       IF (NWORK > 0 .AND. J_NEXT == 0) THEN
         CALL HEAP_POP(IWORK, NWORK, J_NEXT)
       END IF
    END DO
    DO J = NWORK, 1, -1
      IF (IMASK(J).NE.0) THEN
        IA = SUM_MAP_Q(1+2*(J-1))
        IB = SUM_MAP_Q(2+2*(J-1))
        IF (IA == 0) THEN

            IF (NNZ + (KMAX-KMIN) + 1 >= SZ) THEN
               ! EXPONENTIAL OVERALLOCATION
               SZ = 2*SZ + (KMAX-KMIN) + 1

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_I(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_I)

               ALLOCATE(ITMP(SZ))
               ITMP(1:NNZ) = JAC_J(1:NNZ)
               CALL MOVE_ALLOC(ITMP, JAC_J)

               ALLOCATE(VTMP(SZ))
               VTMP(1:NNZ) = JAC_VAL(1:NNZ)
               CALL MOVE_ALLOC(VTMP, JAC_VAL)
            END IF
            DO K = KMIN, KMAX
               IF (WORK(K-KMIN+1,J).NE.0) THEN
                   NNZ = NNZ + 1
                   JAC_I(NNZ) = K
                   JAC_J(NNZ) = IB
                   JAC_VAL(NNZ) = WORK(K-KMIN+1,J)
                END IF
            END DO

        ELSE

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IA) = WORK(K,IA) + SUM_MUL_Q(1+2*(J-1)) * WORK(K,J)
        END DO
        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,IB) = WORK(K,IB) + SUM_MUL_Q(2+2*(J-1)) * WORK(K,J)
        END DO

          IMASK(IA) = 1
          IMASK(IB) = 1
        END IF

        DO CONCURRENT (K=1:BLOCK_SIZE)
          WORK(K,J) = 0
        END DO

        IMASK(J) = 0
      END IF
    END DO

    END DO

    IF (NNZ .EQ. 0) THEN
       IF (ALLOCATED(JAC_VAL)) DEALLOCATE(JAC_VAL)
       IF (ALLOCATED(JAC_I)) DEALLOCATE(JAC_I)
       IF (ALLOCATED(JAC_J)) DEALLOCATE(JAC_J)
    ELSE IF (NNZ < SZ) THEN
       ! SHRINK TO SIZE
       ALLOCATE(ITMP(NNZ))
       ITMP(1:NNZ) = JAC_I(1:NNZ)
       CALL MOVE_ALLOC(ITMP, JAC_I)
       ALLOCATE(ITMP(NNZ))
       ITMP(1:NNZ) = JAC_J(1:NNZ)
       CALL MOVE_ALLOC(ITMP, JAC_J)
       ALLOCATE(VTMP(NNZ))
       VTMP(1:NNZ) = JAC_VAL(1:NNZ)
       CALL MOVE_ALLOC(VTMP, JAC_VAL)
    END IF
  END SUBROUTINE GET_COO_JACOBIAN_Q

   SUBROUTINE SUM_TAYLOR_Q(ALPHAP, BETAP, A, B, C)
    ! C := ALPHA*A + BETA*B
    USE ISO_C_BINDING
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: ALPHAP, BETAP
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: A, B
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: C

    IF (JAC_PRODUCT_MODE) THEN
       C%VMUL = ALPHAP * A%VMUL + BETAP * B%VMUL
    ELSE
       IF (A%VMUL == 0 .OR. A%I == 0 .OR. ALPHAP == 0) THEN
          C%VMUL = BETAP * B%VMUL
          C%I = B%I
       ELSE IF (B%VMUL == 0 .OR. B%I == 0 .OR. BETAP == 0) THEN
          C%VMUL = ALPHAP * A%VMUL
          C%I = A%I
       ELSE IF (A%I == B%I) THEN
          C%VMUL = ALPHAP * A%VMUL + BETAP * B%VMUL
          C%I = A%I
       ELSE
          CALL ALLOC_MEM_Q(C)
          C%VMUL = 1
          SUM_MAP_Q(1 + 2*(C%I-1)) = A%I
          SUM_MAP_Q(2 + 2*(C%I-1)) = B%I
          SUM_MUL_Q(1 + 2*(C%I-1)) = ALPHAP * A%VMUL
          SUM_MUL_Q(2 + 2*(C%I-1)) = BETAP * B%VMUL
       END IF
    END IF
  END SUBROUTINE SUM_TAYLOR_Q


  !--------------------------------------------------------------------------
  ! OVERLOADED OPERATORS
  !--------------------------------------------------------------------------

  !!
  !! ASSIGNMENT(=)
  !!

  PURE ELEMENTAL SUBROUTINE ASSIGN_QI(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: X
    INTEGER, INTENT(IN) :: Y
    CALL FREE_MEM_Q(X)
    X%VALUE = Y
    X%VMUL = 0
  END SUBROUTINE ASSIGN_QI
  PURE ELEMENTAL SUBROUTINE ASSIGN_QD(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    CALL FREE_MEM_Q(X)
    X%VALUE = Y
    X%VMUL = 0
  END SUBROUTINE ASSIGN_QD
  PURE ELEMENTAL SUBROUTINE ASSIGN_QZ(X, Y)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(INOUT) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    CALL FREE_MEM_Q(X)
    X%VALUE = Y
    X%VMUL = 0
  END SUBROUTINE ASSIGN_QZ

  !!
  !! OPERATOR(+)
  !!

  ! X + Y = X + Y + (X_J + Y_J) DJ

  IMPURE ELEMENTAL FUNCTION ADD_QQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEXAN) :: Z

    Z%VALUE = X%VALUE + Y%VALUE
    CALL SUM_TAYLOR(CMPLX(1D0, KIND=KIND(0D0)), CMPLX(1D0, KIND=KIND(0D0)), X, Y, Z)
  END FUNCTION ADD_QQ

  PURE ELEMENTAL FUNCTION ADD_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE + Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION ADD_QI

  PURE ELEMENTAL FUNCTION ADD_IQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y + X
  END FUNCTION ADD_IQ
  PURE ELEMENTAL FUNCTION ADD_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE + Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION ADD_QD

  PURE ELEMENTAL FUNCTION ADD_DQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y + X
  END FUNCTION ADD_DQ
  PURE ELEMENTAL FUNCTION ADD_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE + Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION ADD_QZ

  PURE ELEMENTAL FUNCTION ADD_ZQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y + X
  END FUNCTION ADD_ZQ

  !!
  !! OPERATOR(+), UNARY
  !!

  PURE ELEMENTAL FUNCTION POS_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = X
  END FUNCTION POS_Q


  !!
  !! OPERATOR(-)
  !!

  ! X - Y = X - Y + (X_J - Y_J) DJ

  IMPURE ELEMENTAL FUNCTION SUB_QQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEXAN) :: Z

    Z%VALUE = X%VALUE - Y%VALUE
    CALL SUM_TAYLOR(CMPLX(1D0, KIND=KIND(0D0)), CMPLX(-1D0, KIND=KIND(0D0)), X, Y, Z)
  END FUNCTION SUB_QQ

  PURE ELEMENTAL FUNCTION SUB_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE - Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION SUB_QI

  PURE ELEMENTAL FUNCTION SUB_IQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X - Y%VALUE
    Z%VMUL = -Y%VMUL
    CALL LINK_MEM_Q(Z, Y)
  END FUNCTION SUB_IQ
  PURE ELEMENTAL FUNCTION SUB_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE - Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION SUB_QD

  PURE ELEMENTAL FUNCTION SUB_DQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X - Y%VALUE
    Z%VMUL = -Y%VMUL
    CALL LINK_MEM_Q(Z, Y)
  END FUNCTION SUB_DQ
  PURE ELEMENTAL FUNCTION SUB_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE - Y
    Z%VMUL = X%VMUL
    CALL LINK_MEM_Q(Z, X)
  END FUNCTION SUB_QZ

  PURE ELEMENTAL FUNCTION SUB_ZQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X - Y%VALUE
    Z%VMUL = -Y%VMUL
    CALL LINK_MEM_Q(Z, Y)
  END FUNCTION SUB_ZQ

  !!
  !! OPERATOR(-), UNARY
  !!

  PURE ELEMENTAL FUNCTION NEG_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = 0D0 - X
  END FUNCTION NEG_Q


  !!
  !! OPERATOR(*)
  !!

  ! X*Y = X*Y + (X Y_J + Y X_J) DJ

  IMPURE ELEMENTAL FUNCTION MUL_QQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEXAN) :: Z

    Z%VALUE = X%VALUE * Y%VALUE
    CALL SUM_TAYLOR(Y%VALUE, X%VALUE, X, Y, Z)
  END FUNCTION MUL_QQ

  PURE ELEMENTAL FUNCTION MUL_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    IF (Y == 0) THEN
       Z%VALUE = 0
       Z%VMUL = 0
       CALL FREE_MEM_Q(Z)
    ELSE
       Z%VALUE = X%VALUE * Y
       Z%VMUL = X%VMUL * Y
       CALL LINK_MEM_Q(Z, X)
    END IF
  END FUNCTION MUL_QI

  PURE ELEMENTAL FUNCTION MUL_IQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y * X
  END FUNCTION MUL_IQ
  PURE ELEMENTAL FUNCTION MUL_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    IF (Y == 0) THEN
       Z%VALUE = 0
       Z%VMUL = 0
       CALL FREE_MEM_Q(Z)
    ELSE
       Z%VALUE = X%VALUE * Y
       Z%VMUL = X%VMUL * Y
       CALL LINK_MEM_Q(Z, X)
    END IF
  END FUNCTION MUL_QD

  PURE ELEMENTAL FUNCTION MUL_DQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y * X
  END FUNCTION MUL_DQ
  PURE ELEMENTAL FUNCTION MUL_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    IF (Y == 0) THEN
       Z%VALUE = 0
       Z%VMUL = 0
       CALL FREE_MEM_Q(Z)
    ELSE
       Z%VALUE = X%VALUE * Y
       Z%VMUL = X%VMUL * Y
       CALL LINK_MEM_Q(Z, X)
    END IF
  END FUNCTION MUL_QZ

  PURE ELEMENTAL FUNCTION MUL_ZQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = Y * X
  END FUNCTION MUL_ZQ

  !!
  !! OPERATOR(/)
  !!

  ! X/Y = X/Y + (X_J/Y - X Y_J/Y**2) DJ

  IMPURE ELEMENTAL FUNCTION DIV_QQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z%VALUE = X%VALUE / Y%VALUE
    CALL SUM_TAYLOR(1D0/Y%VALUE, -X%VALUE/(Y%VALUE**2), X, Y, Z)
  END FUNCTION DIV_QQ

  PURE ELEMENTAL FUNCTION DIV_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (1D0 / Y) * X
  END FUNCTION DIV_QI

  PURE ELEMENTAL FUNCTION DIV_IQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (-X / (Y%VALUE**2)) * Y
    Z%VALUE = X / Y%VALUE
  END FUNCTION DIV_IQ
  PURE ELEMENTAL FUNCTION DIV_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (1D0 / Y) * X
  END FUNCTION DIV_QD

  PURE ELEMENTAL FUNCTION DIV_DQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (-X / (Y%VALUE**2)) * Y
    Z%VALUE = X / Y%VALUE
  END FUNCTION DIV_DQ
  PURE ELEMENTAL FUNCTION DIV_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (1D0 / Y) * X
  END FUNCTION DIV_QZ

  PURE ELEMENTAL FUNCTION DIV_ZQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = (-X / (Y%VALUE**2)) * Y
    Z%VALUE = X / Y%VALUE
  END FUNCTION DIV_ZQ

  !!
  !! OPERATOR(**)
  !!

  PURE ELEMENTAL FUNCTION POW_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    INTEGER, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = EXP(Y * LOG(X))
  END FUNCTION POW_QI
  PURE ELEMENTAL FUNCTION POW_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    DOUBLE PRECISION, INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = EXP(Y * LOG(X))
  END FUNCTION POW_QD
  PURE ELEMENTAL FUNCTION POW_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN) :: Z
    Z = EXP(Y * LOG(X))
  END FUNCTION POW_QZ

  !!
  !! MATMUL
  !!

  FUNCTION MATMUL_QQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: X, Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_QQ

  FUNCTION MATMUL_QI(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: X
    INTEGER, DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_QI

  FUNCTION MATMUL_IQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    INTEGER, DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_IQ
  FUNCTION MATMUL_QD(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: X
    DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_QD

  FUNCTION MATMUL_DQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    DOUBLE PRECISION, DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_DQ
  FUNCTION MATMUL_QZ(X, Y) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: X
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_QZ

  FUNCTION MATMUL_ZQ(X, Y) RESULT(Z)
    IMPLICIT NONE
    COMPLEX(KIND=KIND(0D0)), DIMENSION(:,:), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN), DIMENSION(:,:), INTENT(IN) :: Y
    TYPE(ADJAC_COMPLEXAN), DIMENSION(SIZE(X,1),SIZE(Y,2)) :: Z
        INTEGER I, J, K

    IF (SIZE(X,2) .NE. SIZE(Y,1)) THEN
       WRITE(*,*) 'INVALID ARRAY SIZES IN MATMUL'
       STOP
    END IF

    DO J = 1, SIZE(Y,2)
       DO I = 1, SIZE(X,1)
          Z(I,J) = X(I,1)*Y(1,J)
          DO K = 2, SIZE(X,2)
             Z(I,J) = Z(I,J) + X(I,K)*Y(K,J)
          END DO
       END DO
    END DO

  END FUNCTION MATMUL_ZQ

  !!
  !! DBLE
  !!


  !!
  !! AIMAG
  !!


  !!
  !! CONJG
  !!


  !!
  !! EXP
  !!

  PURE ELEMENTAL FUNCTION EXP_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = EXP(X%VALUE)
    DV = V
    Z = DV*X
    Z%VALUE = V
  END FUNCTION EXP_Q


  !!
  !! SIN
  !!

  PURE ELEMENTAL FUNCTION SIN_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = SIN(X%VALUE)
    DV = COS(X%VALUE)
    Z = DV*X
    Z%VALUE = V
  END FUNCTION SIN_Q


  !!
  !! COS
  !!

  PURE ELEMENTAL FUNCTION COS_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = COS(X%VALUE)
    DV = -SIN(X%VALUE)
    Z = DV*X
    Z%VALUE = V
  END FUNCTION COS_Q


  !!
  !! LOG
  !!

  PURE ELEMENTAL FUNCTION LOG_Q(X) RESULT(Z)
    IMPLICIT NONE
    TYPE(ADJAC_COMPLEXAN), INTENT(IN) :: X
    TYPE(ADJAC_COMPLEXAN) :: Z
    COMPLEX(KIND=KIND(0D0)) :: V, DV
    V = LOG(X%VALUE)
    DV = 1D0/X%VALUE
    Z = DV*X
    Z%VALUE = V
  END FUNCTION LOG_Q


END MODULE ModLib_AdJac
