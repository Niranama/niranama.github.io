!*****************************************************************************

!  MPFUN20-Fort: A thread-safe arbitrary precision computation package
!  Medium precision language interface module (module MPFUNH)
!  Variant 1: Precision level arguments are NOT required.

!  Note: !> and !>> comments delimit variant differences, and are used to generate
!  the variant files of this module using the gencodes.f90 program. Do not
!  change these comments.

!  Revision date:  24 Sep 2021

!  AUTHOR:
!    David H. Bailey
!    Lawrence Berkeley National Lab (retired) and University of California, Davis
!    Email: dhbailey@lbl.gov

!  COPYRIGHT AND DISCLAIMER:
!    All software in this package (c) 2021 David H. Bailey.
!    By downloading or using this software you agree to the copyright, disclaimer
!    and license agreement in the accompanying file DISCLAIMER.txt.

!  PURPOSE OF PACKAGE:
!    This package permits one to perform floating-point computations (real and
!    complex) to arbitrarily high numeric precision, by making only relatively
!    minor changes to existing Fortran-90 programs.  All basic arithmetic
!    operations and transcendental functions are supported, together with several
!    special functions.

!    In addition to fast execution times, one key feature of this package is a
!    100% THREAD-SAFE design, which means that user-level applications can be
!    easily converted for parallel execution, say using a threaded parallel
!    environment such as OpenMP.

!  DOCUMENTATION:
!    A detailed description of this package, and instructions for compiling
!    and testing this program on various specific systems are included in the
!    README file accompanying this package, and, in more detail, in the
!    following technical paper:

!    David H. Bailey, "MPFUN2020: A new thread-safe arbitrary precision package,"
!    available at http://www.davidhbailey.com/dhbpapers/mpfun2020.pdf.

!  DESCRIPTION OF THIS MODULE (MPFUNH):
!    This module contains all high-level Fortran-90 language interfaces for
!    operations using the medium precision datatype. This is not needed for
!    most programs, but provides significantly better performance (and
!    less memory) for certain large, demanding applications that can benefit
!    from two high-precision datatypes (e.g., tpslqm3.f90 and tpphix3.f90).

!    There are four variants of this module:
!      mpfunh1.f90    Mixed-mode operations ARE allowed; precision level
!                     arguments are NOT required in certain functions;
!                     quad precision (128-bit) is NOT supported.
!      mpfunh2.f90    Mixed-mode operations are NOT allowed; precision level
!                     arguments ARE required in certain functions.
!                     quad precision (128-bit) is NOT supported.
!      mpfunhq1.f90    Mixed-mode operations ARE allowed; precision level
!                     arguments are NOT required in certain functions;
!                     quad precision (128-bit) IS supported (limited).
!      mpfunhq2.f90    Mixed-mode operations are NOT allowed; precision level
!                     arguments ARE not required in certain functions;
!                     quad precision (128-bit) IS supported (limited).
!    Compile and link whichever one of these four is most appropriate for the
!    given applications. See documentation for details.

MODULE ModLib_MPFUNH
USE ModLib_MPFUNA
USE ModLib_MPFUNB
USE ModLib_MPFUNC
USE ModLib_MPFUND
USE ModLib_MPFUNE
USE ModLib_MPFUNF
USE ModLib_MPFUNG
IMPLICIT NONE

!  Assignments and the five arithmetic operators:

PRIVATE &
  MP_EQRR, MP_EQDR, MP_EQRD, MP_EQIR, MP_EQRI, MP_EQRA, MP_EQRZ, &
  MP_EQZR, MP_EQZZ, MP_EQDZ, MP_EQZD, MP_EQDCZ, MP_EQZDC, &
  MP_ADDRR, MP_ADDDR, MP_ADDRD, MP_ADDIR, MP_ADDRI, MP_ADDZZ, &
  MP_ADDDZ, MP_ADDZD, MP_ADDDCZ, MP_ADDZDC, MP_ADDRZ, MP_ADDZR, &
  MP_SUBRR, MP_SUBDR, MP_SUBRD, MP_SUBIR, MP_SUBRI, MP_SUBZZ, &
  MP_SUBDZ, MP_SUBZD, MP_SUBDCZ, MP_SUBZDC, MP_SUBRZ, MP_SUBZR, &
  MP_NEGR, MP_NEGZ, &
  MP_MULRR, MP_MULDR, MP_MULRD, MP_MULIR, MP_MULRI, MP_MULZZ, &
  MP_MULDZ, MP_MULZD, MP_MULDCZ, MP_MULZDC, MP_MULRZ, MP_MULZR, &
  MP_DIVRR, MP_DIVDR, MP_DIVRD, MP_DIVIR, MP_DIVRI, MP_DIVZZ, &
  MP_DIVDZ, MP_DIVZD, MP_DIVDCZ, MP_DIVZDC, MP_DIVRZ, MP_DIVZR, &
  MP_EXPRI, MP_EXPRR, MP_EXPZI, MP_EXPZZ, MP_EXPRZ, MP_EXPZR

!  The six comparison tests:

PRIVATE &
  MP_EQTRR, MP_EQTDR, MP_EQTRD, MP_EQTIR, MP_EQTRI, MP_EQTZZ, &
  MP_EQTDZ, MP_EQTZD, MP_EQTDCZ, MP_EQTZDC, MP_EQTRZ, MP_EQTZR, &
  MP_NETRR, MP_NETDR, MP_NETRD, MP_NETIR, MP_NETRI, MP_NETZZ, &
  MP_NETDZ, MP_NETZD, MP_NETDCZ, MP_NETZDC, MP_NETRZ, MP_NETZR, &
  MP_LETRR, MP_LETDR, MP_LETRD, MP_LETIR, MP_LETRI, &
  MP_GETRR, MP_GETDR, MP_GETRD, MP_GETIR, MP_GETRI, &
  MP_LTTRR, MP_LTTDR, MP_LTTRD, MP_LTTIR, MP_LTTRI, &
  MP_GTTRR, MP_GTTDR, MP_GTTRD, MP_GTTIR, MP_GTTRI

!  Algebraic, transcendental and type conversion functions:

PRIVATE &
  MP_ABSR, MP_ABSZ, MP_ACOS, MP_ACOSH, MP_AGM, MP_AIMAG, MP_AINT, &
  MP_ANINT, MP_ASIN, MP_ASINH, MP_ATAN, MP_ATAN2, MP_ATANH, MP_ATOR1, &
  MP_ATORN, MP_BERNE, MP_BESSELJ, MP_BESSEL_J0, MP_BESSEL_J1, &
  MP_BESSEL_JN, MP_CCOS, MP_CEXP, MP_CLOG, MP_CONJG, MP_COS, MP_COSH, &
  MP_CSIN, MP_CSQRT, MP_CSSH, MP_CSSN, MP_DCTOZ, MP_DCTOZ2, MP_DECMD, &
  MP_DTOR, MP_DTOR2, MP_EFORM, MP_EGAMMA, MP_ERF, MP_ERFC, MP_EXP, &
  MP_FFORM, MP_GAMMA, MP_HYPOT, MP_INCGAMMA, MP_LOG, MP_LOG2, MP_MAX, &
  MP_MIN, MP_MOD, MP_NRT, MP_PI, MP_PRODD, MP_PRODQ, MP_QTOR, MP_QTOR2, &
  MP_QUOTD, MP_QUOTQ, MP_RAND, MP_READR1, MP_READR2, MP_READR3, &
  MP_READR4, MP_READR5, MP_READZ1, MP_READZ2, MP_READZ3, MP_READZ4, &
  MP_READZ5, MP_RTOD, MP_RTOM, MP_RTOQ, MP_RTOR, MP_RTOZ, MP_SETWP, &
  MP_SIGN, MP_SIN, MP_SINH, MP_SQRT, MP_TAN, MP_TANH, MP_WPREC, &
  MP_WPRECZ, MP_WRITER, MP_WRITEZ, MP_ZETA, MP_ZETAEM, MP_ZTODC, &
  MP_ZTOR, MP_ZTOZ, MP_ZTOZM

!  Operator extension interface blocks:

INTERFACE ASSIGNMENT (=)
  MODULE PROCEDURE MP_EQRR
  MODULE PROCEDURE MP_EQDR
  MODULE PROCEDURE MP_EQIR
  MODULE PROCEDURE MP_EQRZ
  MODULE PROCEDURE MP_EQZR
  MODULE PROCEDURE MP_EQZZ
  MODULE PROCEDURE MP_EQDZ
  MODULE PROCEDURE MP_EQDCZ

!>  In variant #1, uncomment these lines:
  MODULE PROCEDURE MP_EQRD
  MODULE PROCEDURE MP_EQRI
  MODULE PROCEDURE MP_EQRA
  MODULE PROCEDURE MP_EQZD
  MODULE PROCEDURE MP_EQZDC
!>>
END INTERFACE

INTERFACE OPERATOR (+)
  MODULE PROCEDURE MP_ADDRR
  MODULE PROCEDURE MP_ADDDR
  MODULE PROCEDURE MP_ADDRD
  MODULE PROCEDURE MP_ADDIR
  MODULE PROCEDURE MP_ADDRI
  MODULE PROCEDURE MP_ADDZZ
  MODULE PROCEDURE MP_ADDDZ
  MODULE PROCEDURE MP_ADDZD
  MODULE PROCEDURE MP_ADDDCZ
  MODULE PROCEDURE MP_ADDZDC
  MODULE PROCEDURE MP_ADDRZ
  MODULE PROCEDURE MP_ADDZR
END INTERFACE

INTERFACE OPERATOR (-)
  MODULE PROCEDURE MP_SUBRR
  MODULE PROCEDURE MP_SUBDR
  MODULE PROCEDURE MP_SUBRD
  MODULE PROCEDURE MP_SUBIR
  MODULE PROCEDURE MP_SUBRI
  MODULE PROCEDURE MP_SUBZZ
  MODULE PROCEDURE MP_SUBDZ
  MODULE PROCEDURE MP_SUBZD
  MODULE PROCEDURE MP_SUBDCZ
  MODULE PROCEDURE MP_SUBZDC
  MODULE PROCEDURE MP_SUBRZ
  MODULE PROCEDURE MP_SUBZR
  MODULE PROCEDURE MP_NEGR
  MODULE PROCEDURE MP_NEGZ
END INTERFACE

INTERFACE OPERATOR (*)
  MODULE PROCEDURE MP_MULRR
  MODULE PROCEDURE MP_MULDR
  MODULE PROCEDURE MP_MULRD
  MODULE PROCEDURE MP_MULIR
  MODULE PROCEDURE MP_MULRI
  MODULE PROCEDURE MP_MULZZ
  MODULE PROCEDURE MP_MULDZ
  MODULE PROCEDURE MP_MULZD
  MODULE PROCEDURE MP_MULDCZ
  MODULE PROCEDURE MP_MULZDC
  MODULE PROCEDURE MP_MULRZ
  MODULE PROCEDURE MP_MULZR
END INTERFACE

INTERFACE OPERATOR (/)
  MODULE PROCEDURE MP_DIVRR
  MODULE PROCEDURE MP_DIVDR
  MODULE PROCEDURE MP_DIVRD
  MODULE PROCEDURE MP_DIVIR
  MODULE PROCEDURE MP_DIVRI
  MODULE PROCEDURE MP_DIVZZ
  MODULE PROCEDURE MP_DIVDZ
  MODULE PROCEDURE MP_DIVZD
  MODULE PROCEDURE MP_DIVDCZ
  MODULE PROCEDURE MP_DIVZDC
  MODULE PROCEDURE MP_DIVRZ
  MODULE PROCEDURE MP_DIVZR
END INTERFACE

INTERFACE OPERATOR (**)
   MODULE PROCEDURE MP_EXPRI
   MODULE PROCEDURE MP_EXPRR
   MODULE PROCEDURE MP_EXPZI
   MODULE PROCEDURE MP_EXPZZ
   MODULE PROCEDURE MP_EXPRZ
   MODULE PROCEDURE MP_EXPZR
END INTERFACE

INTERFACE OPERATOR (.EQ.)
  MODULE PROCEDURE MP_EQTRR
  MODULE PROCEDURE MP_EQTDR
  MODULE PROCEDURE MP_EQTRD
  MODULE PROCEDURE MP_EQTIR
  MODULE PROCEDURE MP_EQTRI
  MODULE PROCEDURE MP_EQTZZ
  MODULE PROCEDURE MP_EQTDZ
  MODULE PROCEDURE MP_EQTZD
  MODULE PROCEDURE MP_EQTDCZ
  MODULE PROCEDURE MP_EQTZDC
  MODULE PROCEDURE MP_EQTRZ
  MODULE PROCEDURE MP_EQTZR
END INTERFACE

INTERFACE OPERATOR (.NE.)
  MODULE PROCEDURE MP_NETRR
  MODULE PROCEDURE MP_NETDR
  MODULE PROCEDURE MP_NETRD
  MODULE PROCEDURE MP_NETIR
  MODULE PROCEDURE MP_NETRI
  MODULE PROCEDURE MP_NETZZ
  MODULE PROCEDURE MP_NETDZ
  MODULE PROCEDURE MP_NETZD
  MODULE PROCEDURE MP_NETDCZ
  MODULE PROCEDURE MP_NETZDC
  MODULE PROCEDURE MP_NETRZ
  MODULE PROCEDURE MP_NETZR
END INTERFACE

INTERFACE OPERATOR (.LE.)
  MODULE PROCEDURE MP_LETRR
  MODULE PROCEDURE MP_LETDR
  MODULE PROCEDURE MP_LETRD
  MODULE PROCEDURE MP_LETIR
  MODULE PROCEDURE MP_LETRI
END INTERFACE

INTERFACE OPERATOR (.GE.)
  MODULE PROCEDURE MP_GETRR
  MODULE PROCEDURE MP_GETDR
  MODULE PROCEDURE MP_GETRD
  MODULE PROCEDURE MP_GETIR
  MODULE PROCEDURE MP_GETRI
END INTERFACE

INTERFACE OPERATOR (.LT.)
  MODULE PROCEDURE MP_LTTRR
  MODULE PROCEDURE MP_LTTDR
  MODULE PROCEDURE MP_LTTRD
  MODULE PROCEDURE MP_LTTIR
  MODULE PROCEDURE MP_LTTRI
END INTERFACE

INTERFACE OPERATOR (.GT.)
  MODULE PROCEDURE MP_GTTRR
  MODULE PROCEDURE MP_GTTDR
  MODULE PROCEDURE MP_GTTRD
  MODULE PROCEDURE MP_GTTIR
  MODULE PROCEDURE MP_GTTRI
END INTERFACE

!  MP generic function interface blogs, listed alphabetically by interface name:

INTERFACE ABS
  MODULE PROCEDURE MP_ABSR
  MODULE PROCEDURE MP_ABSZ
END INTERFACE

INTERFACE ACOS
  MODULE PROCEDURE MP_ACOS
END INTERFACE

INTERFACE ACOSH
  MODULE PROCEDURE MP_ACOSH
END INTERFACE

INTERFACE AGM
  MODULE PROCEDURE MP_AGM
END INTERFACE

INTERFACE AIMAG
  MODULE PROCEDURE MP_AIMAG
END INTERFACE

INTERFACE AINT
  MODULE PROCEDURE MP_AINT
END INTERFACE

INTERFACE ANINT
  MODULE PROCEDURE MP_ANINT
END INTERFACE

INTERFACE ASIN
  MODULE PROCEDURE MP_ASIN
END INTERFACE

INTERFACE ASINH
  MODULE PROCEDURE MP_ASINH
END INTERFACE

INTERFACE ATAN
  MODULE PROCEDURE MP_ATAN
END INTERFACE

INTERFACE ATAN2
  MODULE PROCEDURE MP_ATAN2
END INTERFACE

INTERFACE ATANH
  MODULE PROCEDURE MP_ATANH
END INTERFACE

INTERFACE BERNE
  MODULE PROCEDURE MP_BERNE
END INTERFACE

INTERFACE BESSELJ
  MODULE PROCEDURE MP_BESSELJ
END INTERFACE

INTERFACE BESSEL_J0
  MODULE PROCEDURE MP_BESSEL_J0
END INTERFACE

INTERFACE BESSEL_J1
  MODULE PROCEDURE MP_BESSEL_J1
END INTERFACE

INTERFACE BESSEL_JN
  MODULE PROCEDURE MP_BESSEL_JN
END INTERFACE

INTERFACE CONJG
  MODULE PROCEDURE MP_CONJG
END INTERFACE

INTERFACE COS
  MODULE PROCEDURE MP_COS
  MODULE PROCEDURE MP_CCOS
END INTERFACE

INTERFACE COSH
  MODULE PROCEDURE MP_COSH
END INTERFACE

INTERFACE DBLE
  MODULE PROCEDURE MP_RTOD
END INTERFACE

INTERFACE DCMPLX
  MODULE PROCEDURE MP_ZTODC
END INTERFACE

INTERFACE ERF
  MODULE PROCEDURE MP_ERF
END INTERFACE

INTERFACE ERFC
  MODULE PROCEDURE MP_ERFC
END INTERFACE

INTERFACE EXP
  MODULE PROCEDURE MP_EXP
  MODULE PROCEDURE MP_CEXP
END INTERFACE

INTERFACE GAMMA
  MODULE PROCEDURE MP_GAMMA
END INTERFACE

INTERFACE HYPOT
  MODULE PROCEDURE MP_HYPOT
END INTERFACE

INTERFACE LOG
  MODULE PROCEDURE MP_LOG
  MODULE PROCEDURE MP_CLOG
END INTERFACE

INTERFACE MAX
  MODULE PROCEDURE MP_MAX
END INTERFACE

INTERFACE MIN
  MODULE PROCEDURE MP_MIN
END INTERFACE

INTERFACE MOD
  MODULE PROCEDURE MP_MOD
END INTERFACE

INTERFACE MPCMPLXM
  MODULE PROCEDURE MP_DCTOZ
  MODULE PROCEDURE MP_RTOZ
  MODULE PROCEDURE MP_ZTOZ
  MODULE PROCEDURE MP_ZTOZM
END INTERFACE

INTERFACE MPCMPLXDCM
  MODULE PROCEDURE MP_DCTOZ2
END INTERFACE

INTERFACE MPCSSH
  MODULE PROCEDURE MP_CSSH
END INTERFACE

INTERFACE MPCSSN
  MODULE PROCEDURE MP_CSSN
END INTERFACE

INTERFACE MPDECMD
  MODULE PROCEDURE MP_DECMD
END INTERFACE

INTERFACE MPEFORM
  MODULE PROCEDURE MP_EFORM
END INTERFACE

INTERFACE MPEGAMMAM
  MODULE PROCEDURE MP_EGAMMA
END INTERFACE

INTERFACE MPFFORM
  MODULE PROCEDURE MP_FFORM
END INTERFACE

INTERFACE INCGAMMA
  MODULE PROCEDURE MP_INCGAMMA
END INTERFACE

INTERFACE MPLOG2M
  MODULE PROCEDURE MP_LOG2
END INTERFACE

INTERFACE MPNRT
  MODULE PROCEDURE MP_NRT
END INTERFACE

INTERFACE MPPIM
  MODULE PROCEDURE MP_PI
END INTERFACE

INTERFACE MPPROD
  MODULE PROCEDURE MP_PRODD
  MODULE PROCEDURE MP_PRODQ
END INTERFACE

INTERFACE MPQUOT
  MODULE PROCEDURE MP_QUOTD
  MODULE PROCEDURE MP_QUOTQ
END INTERFACE

INTERFACE MPRAND
  MODULE PROCEDURE MP_RAND
END INTERFACE

INTERFACE MPREAD
  MODULE PROCEDURE MP_READR1
  MODULE PROCEDURE MP_READR2
  MODULE PROCEDURE MP_READR3
  MODULE PROCEDURE MP_READR4
  MODULE PROCEDURE MP_READR5
  MODULE PROCEDURE MP_READZ1
  MODULE PROCEDURE MP_READZ2
  MODULE PROCEDURE MP_READZ3
  MODULE PROCEDURE MP_READZ4
  MODULE PROCEDURE MP_READZ5
END INTERFACE

INTERFACE MPREALM
  MODULE PROCEDURE MP_ATOR1
  MODULE PROCEDURE MP_ATORN
  MODULE PROCEDURE MP_DTOR
  MODULE PROCEDURE MP_RTOR
  MODULE PROCEDURE MP_ZTOR
  MODULE PROCEDURE MP_RTOM
  MODULE PROCEDURE MP_QTOR
END INTERFACE

INTERFACE MPREALDM
  MODULE PROCEDURE MP_DTOR2
END INTERFACE

INTERFACE MPREALQM
  MODULE PROCEDURE MP_QTOR2
END INTERFACE

INTERFACE MPWPREC
  MODULE PROCEDURE MP_WPREC
  MODULE PROCEDURE MP_WPRECZ
END INTERFACE

INTERFACE MPWRITE
  MODULE PROCEDURE MP_WRITER
  MODULE PROCEDURE MP_WRITEZ
END INTERFACE

INTERFACE QREAL
  MODULE PROCEDURE MP_RTOQ
END INTERFACE

INTERFACE SIGN
  MODULE PROCEDURE MP_SIGN
END INTERFACE

INTERFACE SIN
  MODULE PROCEDURE MP_SIN
  MODULE PROCEDURE MP_CSIN
END INTERFACE

INTERFACE SINH
  MODULE PROCEDURE MP_SINH
END INTERFACE

INTERFACE SQRT
  MODULE PROCEDURE MP_SQRT
  MODULE PROCEDURE MP_CSQRT
END INTERFACE

INTERFACE TAN
  MODULE PROCEDURE MP_TAN
END INTERFACE

INTERFACE TANH
  MODULE PROCEDURE MP_TANH
END INTERFACE

INTERFACE ZETA
  MODULE PROCEDURE MP_ZETA
END INTERFACE

INTERFACE ZETAEM
  MODULE PROCEDURE MP_ZETAEM
END INTERFACE

CONTAINS

!  This routine outputs an error message if iprec exceeds mpwdsm.

  FUNCTION MP_SETWP (IPREC)
    INTEGER MP_SETWP
    INTEGER, INTENT (IN):: IPREC
    IF (IPREC > MPWDSM) THEN
      WRITE (MPLDB, 1)
1       FORMAT ( &
        '*** MP_SETWP: requested precision level exceeds default medium precision.'/ &
        'Increase default medium precision in module MPFUNF.')
      CALL MPABRT (98)
    ENDIF
    MP_SETWP = IPREC
  END FUNCTION

!  Assignment routines:

  SUBROUTINE MP_EQRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (OUT):: RA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    RA%MPR(0) = MPWDSM6
    CALL MPEQ (RB%MPR, RA%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQDR (DA, RB)
    IMPLICIT NONE
    REAL (MPRKND), INTENT (OUT):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER IB, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    CALL MPMDC (RB%MPR, DA, IB, MPNW)
    DA = DA * 2.D0 ** IB
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQRD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (OUT):: RA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER I1, MPNW
    MPNW = MPWDSM
    RA%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, RA%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQIR (IA, RB)
    IMPLICIT NONE
    INTEGER, INTENT (OUT):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    REAL (MPRKND) DA
    INTEGER IB, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    CALL MPMDC (RB%MPR, DA, IB, MPNW)
    IA = DA * 2.D0 ** IB
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (OUT):: RA
    INTEGER, INTENT (IN):: IB
    REAL (MPRKND) DB
    INTEGER I1, MPNW
    MPNW = MPWDSM
    RA%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, RA%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQRA (RA, AB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (OUT):: RA
    CHARACTER(*), INTENT (IN):: AB
    CHARACTER(1) :: CHR1(LEN(AB))
    INTEGER I, L1, MPNW
    MPNW = MPWDSM
    L1 = LEN (AB)
    DO I = 1, L1
      CHR1(I) = AB(I:I)
    ENDDO
    RA%MPR(0) = MPWDSM6
    CALL MPCTOMP (CHR1, L1, RA%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM), INTENT (OUT):: ZA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    ZA%MPC(0) = MPWDSM6
    ZA%MPC(L2) = MPWDSM6
    CALL MPCEQ (ZB%MPC, ZA%MPC, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQDZ (DA, ZB)
    IMPLICIT NONE
    REAL (MPRKND), INTENT (OUT):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, MPNW, N1
    REAL (MPRKND) D1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPMDC (ZB%MPC, D1, N1, MPNW)
    DA = D1 * 2.D0 ** N1
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQZD (ZA, DB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM), INTENT (OUT):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    REAL (MPRKND) D1
    INTEGER L1, MPNW
    MPNW = MPWDSM
    L1 = MPWDSM6
    ZA%MPC(0) = MPWDSM6
    ZA%MPC(L1) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, ZA%MPC, MPNW)
    CALL MPDMC40 (D1, 0, ZA%MPC(L1:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQDCZ (DCA, ZB)
    IMPLICIT NONE
    COMPLEX (KIND (0.D0)), INTENT (OUT):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, MPNW, N1, N2
    REAL (MPRKND) D1, D2
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPMDC (ZB%MPC, D1, N1, MPNW)
    D1 = D1 * 2.D0 ** N1
    CALL MPMDC (ZB%MPC(L1:), D2, N2, MPNW)
    D2 = D2 * 2.D0 ** N2
    DCA = CMPLX (D1, D2, MPRKND)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQZDC (ZA, DCB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM), INTENT (OUT):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER L1, MPNW
    MPNW = MPWDSM
    L1 = MPWDSM6
    ZA%MPC(0) = MPWDSM6
    ZA%MPC(L1) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, ZA%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, ZA%MPC(L1:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (OUT):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, MPNW
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    RA%MPR(0) = MPWDSM6
    CALL MPEQ (ZB%MPC, RA%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_EQZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM), INTENT (OUT):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER L1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    CALL MPDMC (0.D0, 0, R1%MPR, MPNW)
    L1 = MPWDSM6
    ZA%MPC(0) = MPWDSM6
    ZA%MPC(L1) = MPWDSM6
    CALL MPEQ (RB%MPR, ZA%MPC, MPNW)
    CALL MPEQ (R1%MPR, ZA%MPC(L1:), MPNW)
    RETURN
  END SUBROUTINE

!  Addition routines:

  FUNCTION MP_ADDRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ADDRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_ADDRR%MPR(0) = MPWDSM6
    CALL MPADD (RA%MPR, RB%MPR, MP_ADDRR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDDR (DA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ADDDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_ADDDR%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPADD (R1%MPR, RB%MPR, MP_ADDDR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDRD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ADDRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_ADDRD%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPADD (RA%MPR, R1%MPR, MP_ADDRD%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDIR (IA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ADDIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_ADDIR%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPADD (R1%MPR, RB%MPR, MP_ADDIR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ADDRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    REAL (MPRKND) DB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_ADDRI%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPADD (RA%MPR, R1%MPR, MP_ADDRI%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER L1, L2, L3, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_ADDZZ%MPC(0) = MPWDSM6
    MP_ADDZZ%MPC(L3) = MPWDSM6
    CALL MPCADD (ZA%MPC, ZB%MPC, MP_ADDZZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDDZ (DA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDDZ
    REAL (MPRKND) , INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    REAL (MPRKND) D1
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_ADDDZ%MPC(0) = MPWDSM6
    MP_ADDDZ%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DA, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCADD (Z1%MPC, ZB%MPC, MP_ADDDZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDZD (ZA, DB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER L1, L2, MPNW
    REAL (MPRKND) D1
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_ADDZD%MPC(0) = MPWDSM6
    MP_ADDZD%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCADD (ZA%MPC, Z1%MPC, MP_ADDZD%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDDCZ (DCA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_ADDDCZ%MPC(0) = MPWDSM6
    MP_ADDDCZ%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCADD (Z1%MPC, ZB%MPC, MP_ADDDCZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDZDC (ZA, DCB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_ADDZDC%MPC(0) = MPWDSM6
    MP_ADDZDC%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCADD (ZA%MPC, Z1%MPC, MP_ADDZDC%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L2, L3, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_ADDRZ%MPC(0) = MPWDSM6
    MP_ADDRZ%MPC(L3) = MPWDSM6
    CALL MPADD (RA%MPR, ZB%MPC, MP_ADDRZ%MPC, MPNW)
    CALL MPEQ (ZB%MPC(L2:), MP_ADDRZ%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ADDZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ADDZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER L1, L3, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_ADDZR%MPC(0) = MPWDSM6
    MP_ADDZR%MPC(L3) = MPWDSM6
    CALL MPADD (ZA%MPC, RB%MPR, MP_ADDZR%MPC, MPNW)
    CALL MPEQ (ZA%MPC(L1:), MP_ADDZR%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

!  Subtraction routines:

  FUNCTION MP_SUBRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SUBRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_SUBRR%MPR(0) = MPWDSM6
    CALL MPSUB (RA%MPR, RB%MPR, MP_SUBRR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBDR (DA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SUBDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_SUBDR%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPSUB (R1%MPR, RB%MPR, MP_SUBDR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBRD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SUBRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_SUBRD%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPSUB (RA%MPR, R1%MPR, MP_SUBRD%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBIR (IA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SUBIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_SUBIR%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPSUB (R1%MPR, RB%MPR, MP_SUBIR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SUBRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_SUBRI%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPSUB (RA%MPR, R1%MPR, MP_SUBRI%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER L1, L2, L3, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_SUBZZ%MPC(0) = MPWDSM6
    MP_SUBZZ%MPC(L3) = MPWDSM6
    CALL MPCSUB (ZA%MPC, ZB%MPC, MP_SUBZZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBDZ (DA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBDZ
    REAL (MPRKND) , INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    REAL (MPRKND) D1
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_SUBDZ%MPC(0) = MPWDSM6
    MP_SUBDZ%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DA, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCSUB (Z1%MPC, ZB%MPC, MP_SUBDZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBZD (ZA, DB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER L1, L2, MPNW
    REAL (MPRKND) D1
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_SUBZD%MPC(0) = MPWDSM6
    MP_SUBZD%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCSUB (ZA%MPC, Z1%MPC, MP_SUBZD%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBDCZ (DCA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_SUBDCZ%MPC(0) = MPWDSM6
    MP_SUBDCZ%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCSUB (Z1%MPC, ZB%MPC, MP_SUBDCZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBZDC (ZA, DCB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_SUBZDC%MPC(0) = MPWDSM6
    MP_SUBZDC%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCSUB (ZA%MPC, Z1%MPC, MP_SUBZDC%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L2, L3, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_SUBRZ%MPC(0) = MPWDSM6
    MP_SUBRZ%MPC(L3) = MPWDSM6
    CALL MPSUB (RA%MPR, ZB%MPC, MP_SUBRZ%MPC, MPNW)
    CALL MPEQ (ZB%MPC(L2:), MP_SUBRZ%MPC(L3:), MPNW)
    MP_SUBRZ%MPC(L3+2) = - MP_SUBRZ%MPC(L3+2)
    RETURN
  END FUNCTION

  FUNCTION MP_SUBZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_SUBZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER L1, L3, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_SUBZR%MPC(0) = MPWDSM6
    MP_SUBZR%MPC(L3) = MPWDSM6
    CALL MPSUB (ZA%MPC, RB%MPR, MP_SUBZR%MPC, MPNW)
    CALL MPEQ (ZA%MPC(L1:), MP_SUBZR%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

!  Negation routines:

  FUNCTION MP_NEGR (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_NEGR
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_NEGR%MPR(0) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_NEGR%MPR, MPNW)
    MP_NEGR%MPR(2) = - RA%MPR(2)
    RETURN
  END FUNCTION

  FUNCTION MP_NEGZ (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_NEGZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_NEGZ%MPC(0) = MPWDSM6
    MP_NEGZ%MPC(L2) = MPWDSM6
    CALL MPCEQ (ZA%MPC, MP_NEGZ%MPC, MPNW)
    MP_NEGZ%MPC(2) = - MP_NEGZ%MPC(2)
    MP_NEGZ%MPC(L2+2) = - MP_NEGZ%MPC(L2+2)
    RETURN
  END FUNCTION

!  Multiplication routines:

  FUNCTION MP_MULRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MULRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_MULRR%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RB%MPR, MP_MULRR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULDR (DA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MULDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    MP_MULDR%MPR(0) = MPWDSM6
    CALL MPMULD40 (RB%MPR, DA, MP_MULDR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULRD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MULRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_MULRD%MPR(0) = MPWDSM6
    CALL MPMULD40 (RA%MPR, DB, MP_MULRD%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULIR (IA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MULIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    REAL (MPRKND) DA
    INTEGER MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    MP_MULIR%MPR(0) = MPWDSM6
    DA = IA
    CALL MPMULD40 (RB%MPR, DA, MP_MULIR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MULRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    REAL (MPRKND) DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_MULRI%MPR(0) = MPWDSM6
    DB = IB
    CALL MPMULD40 (RA%MPR, DB, MP_MULRI%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER L1, L2, L3, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_MULZZ%MPC(0) = MPWDSM6
    MP_MULZZ%MPC(L3) = MPWDSM6
    CALL MPCMUL (ZA%MPC, ZB%MPC, MP_MULZZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULDZ (DA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULDZ
    REAL (MPRKND) , INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_MULDZ%MPC(0) = MPWDSM6
    MP_MULDZ%MPC(L2) = MPWDSM6
    CALL MPMULD40 (ZB%MPC, DA, MP_MULDZ%MPC, MPNW)
    CALL MPMULD40 (ZB%MPC(L1:), DA, MP_MULDZ%MPC(L2:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULZD (ZA, DB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_MULZD%MPC(0) = MPWDSM6
    MP_MULZD%MPC(L2) = MPWDSM6
    CALL MPMULD40 (ZA%MPC, DB, MP_MULZD%MPC, MPNW)
    CALL MPMULD40 (ZA%MPC(L1:), DB, MP_MULZD%MPC(L2:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULDCZ (DCA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_MULDCZ%MPC(0) = MPWDSM6
    MP_MULDCZ%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCMUL (Z1%MPC, ZB%MPC, MP_MULDCZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULZDC (ZA, DCB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_MULZDC%MPC(0) = MPWDSM6
    MP_MULZDC%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCMUL (ZA%MPC, Z1%MPC, MP_MULZDC%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L2, L3, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_MULRZ%MPC(0) = MPWDSM6
    MP_MULRZ%MPC(L3) = MPWDSM6
    CALL MPMUL (RA%MPR, ZB%MPC, MP_MULRZ%MPC, MPNW)
    CALL MPMUL (RA%MPR, ZB%MPC(L2:), MP_MULRZ%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_MULZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_MULZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER L1, L3, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_MULZR%MPC(0) = MPWDSM6
    MP_MULZR%MPC(L3) = MPWDSM6
    CALL MPMUL (ZA%MPC, RB%MPR, MP_MULZR%MPC, MPNW)
    CALL MPMUL (ZA%MPC(L1:), RB%MPR, MP_MULZR%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

!  Division routines:

  FUNCTION MP_DIVRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DIVRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_DIVRR%MPR(0) = MPWDSM6
    CALL MPDIV (RA%MPR, RB%MPR, MP_DIVRR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVDR (DA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DIVDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_DIVDR%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPDIV (R1%MPR, RB%MPR, MP_DIVDR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVRD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DIVRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_DIVRD%MPR(0) = MPWDSM6
    CALL MPDIVD40 (RA%MPR, DB, MP_DIVRD%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVIR (IA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DIVIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_DIVIR%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPDIV (R1%MPR, RB%MPR, MP_DIVIR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DIVRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    REAL (MPRKND) DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_DIVRI%MPR(0) = MPWDSM6
    DB = IB
    CALL MPDIVD40 (RA%MPR, DB, MP_DIVRI%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER L1, L2, L3, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_DIVZZ%MPC(0) = MPWDSM6
    MP_DIVZZ%MPC(L3) = MPWDSM6
    CALL MPCDIV (ZA%MPC, ZB%MPC, MP_DIVZZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVDZ (DA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVDZ
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    REAL (MPRKND) D1
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_DIVDZ%MPC(0) = MPWDSM6
    MP_DIVDZ%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DA, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCDIV (Z1%MPC, ZB%MPC, MP_DIVDZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVZD (ZA, DB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    REAL (MPRKND) D1
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_DIVZD%MPC(0) = MPWDSM6
    MP_DIVZD%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCDIV (ZA%MPC, Z1%MPC, MP_DIVZD%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVDCZ (DCA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_DIVDCZ%MPC(0) = MPWDSM6
    MP_DIVDCZ%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCDIV (Z1%MPC, ZB%MPC, MP_DIVDCZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVZDC (ZA, DCB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    MP_DIVZDC%MPC(0) = MPWDSM6
    MP_DIVZDC%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCDIV (ZA%MPC, Z1%MPC, MP_DIVZDC%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    TYPE (MP_REALM):: R1, R2, R3
    INTEGER L2, L3, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    L3 = MPWDSM6
    MP_DIVRZ%MPC(0) = MPWDSM6
    MP_DIVRZ%MPC(L3) = MPWDSM6
    CALL MPMUL (ZB%MPC, ZB%MPC, R1%MPR, MPNW)
    CALL MPMUL (ZB%MPC(L2:), ZB%MPC(L2:), R2%MPR, MPNW)
    CALL MPADD (R1%MPR, R2%MPR, R3%MPR, MPNW)
    CALL MPMUL (RA%MPR, ZB%MPC, R1%MPR, MPNW)
    CALL MPDIV (R1%MPR, R3%MPR, MP_DIVRZ%MPC, MPNW)
    CALL MPMUL (RA%MPR, ZB%MPC(L2:), R1%MPR, MPNW)
    CALL MPDIV (R1%MPR, R3%MPR, MP_DIVRZ%MPC(L3:), MPNW)
    MP_DIVRZ%MPC(L3+2) = - MP_DIVRZ%MPC(L3+2)
    RETURN
  END FUNCTION

  FUNCTION MP_DIVZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DIVZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER L1, L3, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_DIVZR%MPC(0) = MPWDSM6
    MP_DIVZR%MPC(L3) = MPWDSM6
    CALL MPDIV (ZA%MPC, RB%MPR, MP_DIVZR%MPC, MPNW)
    CALL MPDIV (ZA%MPC(L1:), RB%MPR, MP_DIVZR%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

!  Exponentiation routines:

  FUNCTION MP_EXPRI (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_EXPRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_EXPRI%MPR(0) = MPWDSM6
    CALL MPNPWR (RA%MPR, IB, MP_EXPRI%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXPRR (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_EXPRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_EXPRR%MPR(0) = MPWDSM6
    CALL MPPOWER (RA%MPR, RB%MPR, MP_EXPRR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXPZI (ZA, IB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_EXPZI
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER, INTENT (IN):: IB
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_EXPZI%MPC(0) = MPWDSM6
    MP_EXPZI%MPC(L2) = MPWDSM6
    CALL MPCNPWR (ZA%MPC, IB, MP_EXPZI%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXPZZ (ZA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_EXPZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER L1, L2, L3, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_EXPZZ%MPC(0) = MPWDSM6
    MP_EXPZZ%MPC(L3) = MPWDSM6
    CALL MPCPOWCC (ZA%MPC, ZB%MPC, MP_EXPZZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXPRZ (RA, ZB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_EXPRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER L2, L3, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_EXPRZ%MPC(0) = MPWDSM6
    MP_EXPRZ%MPC(L3) = MPWDSM6
    CALL MPCPOWRC (RA%MPR, ZB%MPC, MP_EXPRZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXPZR (ZA, RB)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_EXPZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER L1, L3, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    L3 = MPWDSM6
    MP_EXPZR%MPC(0) = MPWDSM6
    MP_EXPZR%MPC(L3) = MPWDSM6
    CALL MPCPOWCR (ZA%MPC, RB%MPR, MP_EXPZR%MPC, MPNW)
    RETURN
  END FUNCTION

!  Equality test routines:

  FUNCTION MP_EQTRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_EQTRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .EQ. 0) THEN
      MP_EQTRR = .TRUE.
    ELSE
      MP_EQTRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_EQTDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .EQ. 0) THEN
      MP_EQTDR = .TRUE.
    ELSE
      MP_EQTDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_EQTRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .EQ. 0) THEN
      MP_EQTRD = .TRUE.
    ELSE
      MP_EQTRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_EQTIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .EQ. 0) THEN
      MP_EQTIR = .TRUE.
    ELSE
      MP_EQTIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_EQTRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .EQ. 0) THEN
      MP_EQTRI = .TRUE.
    ELSE
      MP_EQTRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTZZ (ZA, ZB)
    IMPLICIT NONE
    LOGICAL MP_EQTZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (ZA%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), ZB%MPC(L2:), IC2, MPNW)
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTZZ = .TRUE.
    ELSE
      MP_EQTZZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTDZ (DA, ZB)
    IMPLICIT NONE
    LOGICAL MP_EQTDZ
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    REAL (MPRKND) D1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DA, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (Z1%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (Z1%MPC(L2:), ZB%MPC(L1:), IC2, MPNW)
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTDZ = .TRUE.
    ELSE
      MP_EQTDZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTZD (ZA, DB)
    IMPLICIT NONE
    LOGICAL MP_EQTZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    REAL (MPRKND) D1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (ZA%MPC, Z1%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), Z1%MPC(L2:), IC2, MPNW)
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTZD = .TRUE.
    ELSE
      MP_EQTZD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTDCZ (DCA, ZB)
    IMPLICIT NONE
    LOGICAL MP_EQTDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (Z1%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (Z1%MPC(L2:), ZB%MPC(L1:), IC2, MPNW)
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTDCZ = .TRUE.
    ELSE
      MP_EQTDCZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTZDC (ZA, DCB)
    IMPLICIT NONE
    LOGICAL MP_EQTZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (ZA%MPC, Z1%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), Z1%MPC(L2:), IC2, MPNW)
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTZDC = .TRUE.
    ELSE
      MP_EQTZDC = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTRZ (RA, ZB)
    IMPLICIT NONE
    LOGICAL MP_EQTRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L2, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, ZB%MPC, IC1, MPNW)
    IC2 = INT (ZB%MPC(L2+2))
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTRZ = .TRUE.
    ELSE
      MP_EQTRZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_EQTZR (ZA, RB)
    IMPLICIT NONE
    LOGICAL MP_EQTZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER IC1, IC2, L1, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (ZA%MPC, RB%MPR, IC1, MPNW)
    IC2 = INT (ZA%MPC(L1+2))
    IF (IC1 .EQ. 0 .AND. IC2 .EQ. 0) THEN
      MP_EQTZR = .TRUE.
    ELSE
      MP_EQTZR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!  Non-equality test routines:

  FUNCTION MP_NETRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_NETRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .NE. 0) THEN
      MP_NETRR = .TRUE.
    ELSE
      MP_NETRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_NETDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .NE. 0) THEN
      MP_NETDR = .TRUE.
    ELSE
      MP_NETDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_NETRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .NE. 0) THEN
      MP_NETRD = .TRUE.
    ELSE
      MP_NETRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_NETIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .NE. 0) THEN
      MP_NETIR = .TRUE.
    ELSE
      MP_NETIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_NETRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .NE. 0) THEN
      MP_NETRI = .TRUE.
    ELSE
      MP_NETRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETZZ (ZA, ZB)
    IMPLICIT NONE
    LOGICAL MP_NETZZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA, ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    L1 = ZA%MPC(0)
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (ZB%MPC(1)), &
      INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (ZA%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), ZB%MPC(L2:), IC2, MPNW)
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETZZ = .TRUE.
    ELSE
      MP_NETZZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETDZ (DA, ZB)
    IMPLICIT NONE
    LOGICAL MP_NETDZ
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    REAL (MPRKND) D1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DA, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (Z1%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (Z1%MPC(L2:), ZB%MPC(L1:), IC2, MPNW)
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETDZ = .TRUE.
    ELSE
      MP_NETDZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETZD (ZA, DB)
    IMPLICIT NONE
    LOGICAL MP_NETZD
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    REAL (MPRKND) D1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    D1 = 0.D0
    CALL MPDMC40 (DB, 0, Z1%MPC, MPNW)
    CALL MPDMC40 (D1, 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (ZA%MPC, Z1%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), Z1%MPC(L2:), IC2, MPNW)
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETZD = .TRUE.
    ELSE
      MP_NETZD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETDCZ (DCA, ZB)
    IMPLICIT NONE
    LOGICAL MP_NETDCZ
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZB%MPC(0)
    MPNW = MAX (INT (ZB%MPC(1)), INT (ZB%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (Z1%MPC, ZB%MPC, IC1, MPNW)
    CALL MPCPR (Z1%MPC(L2:), ZB%MPC(L1:), IC2, MPNW)
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETDCZ = .TRUE.
    ELSE
      MP_NETDCZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETZDC (ZA, DCB)
    IMPLICIT NONE
    LOGICAL MP_NETZDC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    COMPLEX (KIND (0.D0)), INTENT (IN):: DCB
    INTEGER IC1, IC2, L1, L2, MPNW
    TYPE (MP_COMPLEXM) Z1
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    CALL MPDMC40 (DBLE (DCB), 0, Z1%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCB), 0, Z1%MPC(L2:), MPNW)
    CALL MPCPR (ZA%MPC, Z1%MPC, IC1, MPNW)
    CALL MPCPR (ZA%MPC(L1:), Z1%MPC(L2:), IC2, MPNW)
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETZDC = .TRUE.
    ELSE
      MP_NETZDC = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETRZ (RA, ZB)
    IMPLICIT NONE
    LOGICAL MP_NETRZ
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_COMPLEXM), INTENT (IN):: ZB
    INTEGER IC1, IC2, L2, MPNW
    L2 = ZB%MPC(0)
    MPNW = MAX (INT (RA%MPR(1)), INT (ZB%MPC(1)), INT (ZB%MPC(L2+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, ZB%MPC, IC1, MPNW)
    IC2 = INT (ZB%MPC(L2+2))
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETRZ = .TRUE.
    ELSE
      MP_NETRZ = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_NETZR (ZA, RB)
    IMPLICIT NONE
    LOGICAL MP_NETZR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    TYPE (MP_REALM), INTENT (IN):: RB
    INTEGER IC1, IC2, L1, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (ZA%MPC, RB%MPR, IC1, MPNW)
    IC2 = INT (ZA%MPC(L1+2))
    IF (IC1 .NE. 0 .OR. IC2 .NE. 0) THEN
      MP_NETZR = .TRUE.
    ELSE
      MP_NETZR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!  Less-than-or-equal test routines:

  FUNCTION MP_LETRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_LETRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .LE. 0) THEN
      MP_LETRR = .TRUE.
    ELSE
      MP_LETRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LETDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_LETDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .LE. 0) THEN
      MP_LETDR = .TRUE.
    ELSE
      MP_LETDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LETRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_LETRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .LE. 0) THEN
      MP_LETRD = .TRUE.
    ELSE
      MP_LETRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LETIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_LETIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .LE. 0) THEN
      MP_LETIR = .TRUE.
    ELSE
      MP_LETIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LETRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_LETRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .LE. 0) THEN
      MP_LETRI = .TRUE.
    ELSE
      MP_LETRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!  Greater-than-or-equal test routines:

  FUNCTION MP_GETRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_GETRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .GE. 0) THEN
      MP_GETRR = .TRUE.
    ELSE
      MP_GETRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GETDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_GETDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .GE. 0) THEN
      MP_GETDR = .TRUE.
    ELSE
      MP_GETDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GETRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_GETRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .GE. 0) THEN
      MP_GETRD = .TRUE.
    ELSE
      MP_GETRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GETIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_GETIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .GE. 0) THEN
      MP_GETIR = .TRUE.
    ELSE
      MP_GETIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GETRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_GETRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .GE. 0) THEN
      MP_GETRI = .TRUE.
    ELSE
      MP_GETRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!  Less-than test routines:

  FUNCTION MP_LTTRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_LTTRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .LT. 0) THEN
      MP_LTTRR = .TRUE.
    ELSE
      MP_LTTRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LTTDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_LTTDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .LT. 0) THEN
      MP_LTTDR = .TRUE.
    ELSE
      MP_LTTDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LTTRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_LTTRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .LT. 0) THEN
      MP_LTTRD = .TRUE.
    ELSE
      MP_LTTRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LTTIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_LTTIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .LT. 0) THEN
      MP_LTTIR = .TRUE.
    ELSE
      MP_LTTIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_LTTRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_LTTRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .LT. 0) THEN
      MP_LTTRI = .TRUE.
    ELSE
      MP_LTTRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!  Greater-than test routines:

  FUNCTION MP_GTTRR (RA, RB)
    IMPLICIT NONE
    LOGICAL MP_GTTRR
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC .GT. 0) THEN
      MP_GTTRR = .TRUE.
    ELSE
      MP_GTTRR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GTTDR (DA, RB)
    IMPLICIT NONE
    LOGICAL MP_GTTDR
    REAL (MPRKND), INTENT (IN):: DA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .GT. 0) THEN
      MP_GTTDR = .TRUE.
    ELSE
      MP_GTTDR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GTTRD (RA, DB)
    IMPLICIT NONE
    LOGICAL MP_GTTRD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    TYPE (MP_REALM) R1
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .GT. 0) THEN
      MP_GTTRD = .TRUE.
    ELSE
      MP_GTTRD = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GTTIR (IA, RB)
    IMPLICIT NONE
    LOGICAL MP_GTTIR
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DA
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DA = IA
    I1 = 0
    CALL MPDMC40 (DA, I1, R1%MPR, MPNW)
    CALL MPCPR (R1%MPR, RB%MPR, IC, MPNW)
    IF (IC .GT. 0) THEN
      MP_GTTIR = .TRUE.
    ELSE
      MP_GTTIR = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_GTTRI (RA, IB)
    IMPLICIT NONE
    LOGICAL MP_GTTRI
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    TYPE (MP_REALM) R1
    REAL (MPRKND) DB
    INTEGER I1, IC, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    DB = IB
    I1 = 0
    CALL MPDMC40 (DB, I1, R1%MPR, MPNW)
    CALL MPCPR (RA%MPR, R1%MPR, IC, MPNW)
    IF (IC .GT. 0) THEN
      MP_GTTRI = .TRUE.
    ELSE
      MP_GTTRI = .FALSE.
    ENDIF
    RETURN
  END FUNCTION

!   Algebraic and transcendental function definitions, listed alphabetically:

  FUNCTION MP_ABSR (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ABSR
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_ABSR%MPR(0) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_ABSR%MPR, MPNW)
    MP_ABSR%MPR(2) = ABS (RA%MPR(2))
    RETURN
  END FUNCTION

  FUNCTION MP_ABSZ (ZA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ABSZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_ABSZ%MPR(0) = MPWDSM6
    CALL MPCABS (ZA%MPC, MP_ABSZ%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ACOS (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ACOS
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RA%MPR, R1%MPR, MPNW)
    CALL MPDMC (1.D0, 0, R2%MPR, MPNW)
    CALL MPSUB (R2%MPR, R1%MPR, R3%MPR, MPNW)
    IF (R3%MPR(2) < 0.D0) THEN
      WRITE (MPLDB, 1)
1     FORMAT ('*** MP_ACOS: argument is not in (-1, 1).')
      CALL MPABRT (24)
    ENDIF
    CALL MPSQRT (R3%MPR, R1%MPR, MPNW)
    MP_ACOS%MPR(0) = MPWDSM6
    CALL MPANG (RA%MPR, R1%MPR, MP_ACOS%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ACOSH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ACOSH
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    MP_ACOSH%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RA%MPR, R1%MPR, MPNW)
    CALL MPDMC (1.D0, 0, R2%MPR, MPNW)
    CALL MPSUB (R1%MPR, R2%MPR, R3%MPR, MPNW)
    IF (R3%MPR(2) < 0.D0) THEN
      WRITE (MPLDB, 1)
1     FORMAT ('*** MP_ACOSH: argument is not >= 1.')
      CALL MPABRT (24)
    ENDIF
    CALL MPSQRT (R3%MPR, R1%MPR, MPNW)
    CALL MPADD (RA%MPR, R1%MPR, R2%MPR, MPNW)
    CALL MPLOG (R2%MPR, MP_ACOSH%MPR, MPNW)
    RETURN
  END FUNCTION

   FUNCTION MP_AGM (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_AGM
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_AGM%MPR(0) = MPWDSM6
    CALL MPAGMR (RB%MPR, RA%MPR, MP_AGM%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_AIMAG (ZA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_AIMAG
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_AIMAG%MPR(0) = MPWDSM6
    CALL MPEQ (ZA%MPC(L1:), MP_AIMAG%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_AINT (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_AINT
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    MP_AINT%MPR(0) = MPWDSM6
    CALL MPINFR (RA%MPR, MP_AINT%MPR, R1%MPR, MPNW)
    RETURN
  END FUNCTION

   FUNCTION MP_ANINT (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ANINT
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_ANINT%MPR(0) = MPWDSM6
    CALL MPNINT (RA%MPR, MP_ANINT%MPR, MPNW)
    RETURN
  END FUNCTION

   FUNCTION MP_ASIN (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ASIN
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RA%MPR, R1%MPR, MPNW)
    CALL MPDMC (1.D0, 0, R2%MPR, MPNW)
    CALL MPSUB (R2%MPR, R1%MPR, R3%MPR, MPNW)
    IF (R3%MPR(2) < 0.D0) THEN
      WRITE (MPLDB, 1)
1     FORMAT ('*** MP_ASIN: argument is not in (-1, 1).')
      CALL MPABRT (25)
    ENDIF
    CALL MPSQRT (R3%MPR, R1%MPR, MPNW)
    MP_ASIN%MPR(0) = MPWDSM6
    CALL MPANG (R1%MPR, RA%MPR, MP_ASIN%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ASINH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ASINH
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    MP_ASINH%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RA%MPR, R1%MPR, MPNW)
    CALL MPDMC (1.D0, 0, R2%MPR, MPNW)
    CALL MPADD (R1%MPR, R2%MPR, R3%MPR, MPNW)
    CALL MPSQRT (R3%MPR, R1%MPR, MPNW)
    CALL MPADD (RA%MPR, R1%MPR, R2%MPR, MPNW)
    CALL MPLOG (R2%MPR, MP_ASINH%MPR, MPNW)
    RETURN
  END FUNCTION

   FUNCTION MP_ATAN (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ATAN
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    CALL MPDMC (1.D0, 0, R1%MPR, MPNW)
    MP_ATAN%MPR(0) = MPWDSM6
    CALL MPANG (R1%MPR, RA%MPR, MP_ATAN%MPR, MPNW)
    RETURN
  END FUNCTION

   FUNCTION MP_ATAN2 (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ATAN2
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_ATAN2%MPR(0) = MPWDSM6
    CALL MPANG (RB%MPR, RA%MPR, MP_ATAN2%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ATANH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ATANH
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    MP_ATANH%MPR(0) = MPWDSM6
    CALL MPDMC (1.D0, 0, R1%MPR, MPNW)
    CALL MPADD (R1%MPR, RA%MPR, R2%MPR, MPNW)
    CALL MPSUB (R1%MPR, RA%MPR, R3%MPR, MPNW)
    CALL MPDIV (R2%MPR, R3%MPR, R1%MPR, MPNW)
    IF (R1%MPR(2) < 0.D0) THEN
      WRITE (MPLDB, 1)
1     FORMAT ('*** MP_ATANH: argument is not in (-1, 1).')
      CALL MPABRT (24)
    ENDIF
    CALL MPLOG (R1%MPR, R2%MPR, MPNW)
    CALL MPMULD (R2%MPR, 0.5D0, MP_ATANH%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ATOR1 (A, IB, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM) MP_ATOR1
    INTEGER, INTENT (IN):: IB
    CHARACTER(1), INTENT (IN):: A(IB)
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_ATOR1%MPR(0) = MPWDSM6
    CALL MPCTOMP (A, IB, MP_ATOR1%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ATORN (AA, IPREC)
    IMPLICIT NONE
    CHARACTER(*), INTENT (IN):: AA
    TYPE (MP_REALM):: MP_ATORN
    CHARACTER(1) :: CHR1(LEN(AA))
    INTEGER I, L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L1 = LEN (AA)
    DO I = 1, L1
      CHR1(I) = AA(I:I)
    ENDDO
    MP_ATORN%MPR(0) = MPWDSM6
    CALL MPCTOMP (CHR1, L1, MP_ATORN%MPR, MPNW)
    RETURN
  END FUNCTION

  SUBROUTINE MP_BERNE (NB, RB, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: NB
    TYPE (MP_REALM), INTENT (OUT):: RB(NB)
    INTEGER I, N1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    DO I = 1, NB
      RB(I)%MPR(0) = MPWDSM6
    ENDDO
    N1 = MPWDSM
    CALL MPBERNER (N1, NB, RB(1)%MPR, MPNW)
    RETURN
  END SUBROUTINE

  FUNCTION MP_BESSELJ (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_BESSELJ
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_BESSELJ%MPR(0) = MPWDSM6
    CALL MPBESSELJR (RA%MPR, RB%MPR, MP_BESSELJ%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_BESSEL_J0 (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_BESSEL_J0
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    CALL MPDMC (0.D0, 0, R1%MPR, MPNW)
    MP_BESSEL_J0%MPR(0) = MPWDSM6
    CALL MPBESSELJR (R1%MPR, RA%MPR, MP_BESSEL_J0%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_BESSEL_J1 (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_BESSEL_J1
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    CALL MPDMC (1.D0, 0, R1%MPR, MPNW)
    MP_BESSEL_J1%MPR(0) = MPWDSM6
    CALL MPBESSELJR (R1%MPR, RA%MPR, MP_BESSEL_J1%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_BESSEL_JN (IA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_BESSEL_JN
    INTEGER, INTENT (IN):: IA
    TYPE (MP_REALM), INTENT (IN):: RB
    TYPE (MP_REALM) R1
    INTEGER MPNW
    MPNW = MIN (INT (RB%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    CALL MPDMC (DBLE (IA), 0, R1%MPR, MPNW)
    MP_BESSEL_JN%MPR(0) = MPWDSM6
    CALL MPBESSELJR (R1%MPR, RB%MPR, MP_BESSEL_JN%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_CCOS (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CCOS
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, L3, MPNW
    TYPE (MP_COMPLEXM) Z1, Z2, Z3
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    Z3%MPC(0) = MPWDSM6
    Z3%MPC(L2) = MPWDSM6
    L3 = MPWDSM6
    MP_CCOS%MPC(0) = MPWDSM6
    MP_CCOS%MPC(L3) = MPWDSM6
    CALL MPDMC (1.D0, 0, Z1%MPC, MPNW)
    CALL MPDMC (0.D0, 0, Z1%MPC(L2:), MPNW)
    CALL MPEQ (ZA%MPC, Z3%MPC(L2:), MPNW)
    CALL MPEQ (ZA%MPC(L1:), Z3%MPC, MPNW)
    Z3%MPC(2) = - Z3%MPC(2)
    CALL MPCEXP (Z3%MPC, Z2%MPC, MPNW)
    CALL MPCDIV (Z1%MPC, Z2%MPC, Z3%MPC, MPNW)
    CALL MPCADD (Z2%MPC, Z3%MPC, Z1%MPC, MPNW)
    CALL MPMULD (Z1%MPC, 0.5D0, MP_CCOS%MPC, MPNW)
    CALL MPMULD (Z1%MPC(L2:), 0.5D0, MP_CCOS%MPC(L3:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_CEXP (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CEXP
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_CEXP%MPC(0) = MPWDSM6
    MP_CEXP%MPC(L2) = MPWDSM6
    CALL MPCEXP (ZA%MPC, MP_CEXP%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_CLOG (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CLOG
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_CLOG%MPC(0) = MPWDSM6
    MP_CLOG%MPC(L2) = MPWDSM6
    CALL MPCLOG (ZA%MPC, MP_CLOG%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_CONJG (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CONJG
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_CONJG%MPC(0) = MPWDSM6
    MP_CONJG%MPC(L2) = MPWDSM6
    CALL MPCONJG (ZA%MPC, MP_CONJG%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_COS (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_COS
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    TYPE (MP_REALM) R1
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_COS%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    CALL MPCSSNR (RA%MPR, MP_COS%MPR, R1%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_COSH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_COSH
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    TYPE (MP_REALM) R1
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_COSH%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    CALL MPCSSHR (RA%MPR, MP_COSH%MPR, R1%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_CSIN (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CSIN
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, L3, MPNW
    TYPE (MP_COMPLEXM) Z1, Z2, Z3
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    Z1%MPC(0) = MPWDSM6
    Z1%MPC(L2) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    Z3%MPC(0) = MPWDSM6
    Z3%MPC(L2) = MPWDSM6
    L3 = MPWDSM6
    MP_CSIN%MPC(0) = MPWDSM6
    MP_CSIN%MPC(L3) = MPWDSM6
    CALL MPDMC (1.D0, 0, Z1%MPC, MPNW)
    CALL MPDMC (0.D0, 0, Z1%MPC(L2:), MPNW)
    CALL MPEQ (ZA%MPC, Z3%MPC(L2:), MPNW)
    CALL MPEQ (ZA%MPC(L1:), Z3%MPC, MPNW)
    Z3%MPC(2) = - Z3%MPC(2)
    CALL MPCEXP (Z3%MPC, Z2%MPC, MPNW)
    CALL MPCDIV (Z1%MPC, Z2%MPC, Z3%MPC, MPNW)
    CALL MPCSUB (Z2%MPC, Z3%MPC, Z1%MPC, MPNW)
    CALL MPMULD (Z1%MPC, 0.5D0, MP_CSIN%MPC(L3:), MPNW)
    CALL MPMULD (Z1%MPC(L2:), 0.5D0, MP_CSIN%MPC, MPNW)
    MP_CSIN%MPC(L3+2) = - MP_CSIN%MPC(L3+2)
    RETURN
  END FUNCTION

  FUNCTION MP_CSQRT (ZA)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_CSQRT
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, L2, MPNW
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    L2 = MPWDSM6
    MP_CSQRT%MPC(0) = MPWDSM6
    MP_CSQRT%MPC(L2) = MPWDSM6
    CALL MPCSQRT (ZA%MPC, MP_CSQRT%MPC, MPNW)
    RETURN
  END FUNCTION

  SUBROUTINE MP_CSSH (RA, RB, RC)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM), INTENT (OUT):: RB, RC
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    RB%MPR(0) = MPWDSM6
    RC%MPR(0) = MPWDSM6
    CALL MPCSSHR (RA%MPR, RB%MPR, RC%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_CSSN (RA, RB, RC)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM), INTENT (OUT):: RB, RC
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    RB%MPR(0) = MPWDSM6
    RC%MPR(0) = MPWDSM6
    CALL MPCSSNR (RA%MPR, RB%MPR, RC%MPR, MPNW)
    RETURN
  END SUBROUTINE

  FUNCTION MP_DCTOZ (DCA, IPREC)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DCTOZ
    COMPLEX (KIND(0.D0)), INTENT (IN):: DCA
    INTEGER L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L1 = MPWDSM6
    MP_DCTOZ%MPC(0) = MPWDSM6
    MP_DCTOZ%MPC(L1) = MPWDSM6
    CALL MPDMC40 (DBLE (DCA), 0, MP_DCTOZ%MPC, MPNW)
    CALL MPDMC40 (AIMAG (DCA), 0, MP_DCTOZ%MPC(L1:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DCTOZ2 (DCA, IPREC)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_DCTOZ2
    COMPLEX (KIND(0.D0)), INTENT (IN):: DCA
    INTEGER L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L1 = MPWDSM6
    MP_DCTOZ2%MPC(0) = MPWDSM6
    MP_DCTOZ2%MPC(L1) = MPWDSM6
    CALL MPDMC (DBLE (DCA), 0, MP_DCTOZ2%MPC, MPNW)
    CALL MPDMC (AIMAG (DCA), 0, MP_DCTOZ2%MPC(L1:), MPNW)
    RETURN
  END FUNCTION

  SUBROUTINE MP_DECMD (RA, DB, IB)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (OUT):: DB
    INTEGER, INTENT (OUT):: IB
    REAL (MPRKND) ALG102, DT1, DT2
    PARAMETER (ALG102 = 0.301029995663981195D0)
    INTEGER I1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDS)
    CALL MPMDC (RA%MPR, DT1, I1, MPNW)
    IF (DT1 /= 0.D0) THEN
      DT2 = ALG102 * I1 + LOG10 (ABS (DT1))
      IB = DT2
      IF (DT2 < 0.D0) IB = IB - 1
      DB = SIGN (10.D0 ** (DT2 - IB), DT1)
    ELSE
      DB = 0.D0
      IB = 0
    ENDIF
  END SUBROUTINE

  FUNCTION MP_DTOR (DA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DTOR
    REAL (MPRKND), INTENT (IN):: DA
    INTEGER I1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_DTOR%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC40 (DA, I1, MP_DTOR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_DTOR2 (DA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_DTOR2
    REAL (MPRKND), INTENT (IN):: DA
    INTEGER I1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_DTOR2%MPR(0) = MPWDSM6
    I1 = 0
    CALL MPDMC (DA, I1, MP_DTOR2%MPR, MPNW)
    RETURN
  END FUNCTION

  SUBROUTINE MP_EFORM (RA, NB, ND, B)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: NB, ND
    CHARACTER(1), INTENT (OUT):: B(NB)
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    CALL MPEFORMAT (RA%MPR, NB, ND, B, MPNW)
    RETURN
  END SUBROUTINE

  FUNCTION MP_EGAMMA (IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_EGAMMA
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_EGAMMA%MPR(0) = MPWDSM6
    CALL MPEGAMMAQ (MP_EGAMMA%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_ERF (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ERF
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_ERF%MPR(0) = MPWDSM6
    CALL MPERFR (RA%MPR, MP_ERF%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ERFC (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ERFC
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_ERFC%MPR(0) = MPWDSM6
    CALL MPERFCR (RA%MPR, MP_ERFC%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_EXP (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_EXP
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_EXP%MPR(0) = MPWDSM6
    CALL MPEXP (RA%MPR, MP_EXP%MPR, MPNW)
    RETURN
  END FUNCTION

  SUBROUTINE MP_FFORM (RA, NB, ND, B)
    IMPLICIT NONE
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: NB, ND
    CHARACTER(1), INTENT (OUT):: B(NB)
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    CALL MPFFORMAT (RA%MPR, NB, ND, B, MPNW)
    RETURN
  END SUBROUTINE

  FUNCTION MP_GAMMA (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_GAMMA
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_GAMMA%MPR(0) = MPWDSM6
    CALL MPGAMMAR (RA%MPR, MP_GAMMA%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_HYPOT (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_HYPOT
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_HYPOT%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    CALL MPMUL (RA%MPR, RA%MPR, R1%MPR, MPNW)
    CALL MPMUL (RB%MPR, RB%MPR, R2%MPR, MPNW)
    CALL MPADD (R1%MPR, R2%MPR, R3%MPR, MPNW)
    CALL MPSQRT (R3%MPR, MP_HYPOT%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_INCGAMMA (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_INCGAMMA
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_INCGAMMA%MPR(0) = MPWDSM6
!    call mpincgammar (ra%mpr, rb%mpr, mp_incgamma%mpr, mpnw)
    RETURN
  END FUNCTION

  FUNCTION MP_LOG (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_LOG
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_LOG%MPR(0) = MPWDSM6
    CALL MPLOG (RA%MPR, MP_LOG%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_LOG2 (IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_LOG2
    TYPE (MP_REALM) QPI
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_LOG2%MPR(0) = MPWDSM6
    QPI%MPR(0) = MPWDSM6
    CALL MPPIQ (QPI%MPR, MPNW)
    CALL MPLOG2Q (QPI%MPR, MP_LOG2%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_MAX (RA, RB, RC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MAX
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    TYPE (MP_REALM), INTENT (IN), OPTIONAL:: RC
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    IF (PRESENT (RC)) MPNW = MAX (MPNW, INT (RC%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_MAX%MPR(0) = MPWDSM6
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC >= 0) THEN
      CALL MPEQ (RA%MPR, MP_MAX%MPR, MPNW)
    ELSE
      CALL MPEQ (RB%MPR, MP_MAX%MPR, MPNW)
    ENDIF
    IF (PRESENT (RC)) THEN
      CALL MPCPR (RC%MPR, MP_MAX%MPR, IC, MPNW)
      IF (IC >= 0) CALL MPEQ (RC%MPR, MP_MAX%MPR, MPNW)
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_MIN (RA, RB, RC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MIN
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    TYPE (MP_REALM), INTENT (IN), OPTIONAL:: RC
    INTEGER IC, MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    IF (PRESENT (RC)) MPNW = MAX (MPNW, INT (RC%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_MIN%MPR(0) = MPWDSM6
    CALL MPCPR (RA%MPR, RB%MPR, IC, MPNW)
    IF (IC <= 0) THEN
      CALL MPEQ (RA%MPR, MP_MIN%MPR, MPNW)
    ELSE
      CALL MPEQ (RB%MPR, MP_MIN%MPR, MPNW)
    ENDIF
    IF (PRESENT (RC)) THEN
      CALL MPCPR (RC%MPR, MP_MIN%MPR, IC, MPNW)
      IF (IC <= 0) CALL MPEQ (RC%MPR, MP_MIN%MPR, MPNW)
    ENDIF
    RETURN
  END FUNCTION

  FUNCTION MP_MOD (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_MOD
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    TYPE (MP_REALM) R1, R2, R3
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_MOD%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    CALL MPDIV (RA%MPR, RB%MPR, R1%MPR, MPNW)
    CALL MPINFR (R1%MPR, R2%MPR, R3%MPR, MPNW)
    CALL MPMUL (RB%MPR, R2%MPR, R3%MPR, MPNW)
    CALL MPSUB (RA%MPR, R3%MPR, MP_MOD%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_NRT (RA, IB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_NRT
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER, INTENT (IN):: IB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_NRT%MPR(0) = MPWDSM6
    CALL MPNRTR (RA%MPR, IB, MP_NRT%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_PI (IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_PI
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_PI%MPR(0) = MPWDSM6
    CALL MPPIQ (MP_PI%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_PRODD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_PRODD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_PRODD%MPR(0) = MPWDSM6
    CALL MPMULD (RA%MPR, DB, MP_PRODD%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_PRODQ (RA, QB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_PRODQ
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MAX (MPRKND2, KIND (1.0))), INTENT (IN):: QB
    TYPE (MP_REALM) R1
    INTEGER MPNW
    R1%MPR(0) = MPWDSM6
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_PRODQ%MPR(0) = MPWDSM6
    CALL MPQMC (QB, 0, R1%MPR, MPNW)
    CALL MPMUL (RA%MPR, R1%MPR, MP_PRODQ%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_QTOR (QA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_QTOR
    INTEGER MPNW
    REAL (MAX (MPRKND2, KIND (1.))), INTENT (IN):: QA

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_QTOR%MPR(0) = MPWDSM6
    CALL MPQMC90 (QA, 0, MP_QTOR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_QTOR2 (QA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_QTOR2
    INTEGER MPNW
    REAL (MAX (MPRKND2, KIND (1.))), INTENT (IN):: QA

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_QTOR2%MPR(0) = MPWDSM6
    CALL MPQMC (QA, 0, MP_QTOR2%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_QUOTD (RA, DB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_QUOTD
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MPRKND), INTENT (IN):: DB
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_QUOTD%MPR(0) = MPWDSM6
    CALL MPDIVD (RA%MPR, DB, MP_QUOTD%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_QUOTQ (RA, QB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_QUOTQ
    TYPE (MP_REALM), INTENT (IN):: RA
    REAL (MAX (MPRKND2, KIND (1.0))), INTENT (IN):: QB
    TYPE (MP_REALM) R1
    INTEGER MPNW
    R1%MPR(0) = MPWDSM6
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_QUOTQ%MPR(0) = MPWDSM6
    CALL MPQMC (QB, 0, R1%MPR, MPNW)
    CALL MPDIV (RA%MPR, R1%MPR, MP_QUOTQ%MPR, MPNW)
  END FUNCTION

  FUNCTION MP_RAND (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_RAND
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_RAND%MPR(0) = MPWDSM6
    CALL MPRANDR (RA%MPR, MP_RAND%MPR, MPNW)
    RETURN
  END FUNCTION

!   Five variations are necessary here due to Fortran rules about optional arguments.

  SUBROUTINE MP_READR1 (IU, R1, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_REALM), INTENT (OUT):: R1
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    R1%MPR(0) = MPWDSM6
    CALL MPINP (IU, R1%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READR2 (IU, R1, R2, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_REALM), INTENT (OUT):: R1, R2
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    CALL MPINP (IU, R1%MPR, MPNW)
    CALL MPINP (IU, R2%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READR3 (IU, R1, R2, R3, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_REALM), INTENT (OUT):: R1, R2, R3
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    CALL MPINP (IU, R1%MPR, MPNW)
    CALL MPINP (IU, R2%MPR, MPNW)
    CALL MPINP (IU, R3%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READR4 (IU, R1, R2, R3, R4, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_REALM), INTENT (OUT):: R1, R2, R3, R4
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    R4%MPR(0) = MPWDSM6
    CALL MPINP (IU, R1%MPR, MPNW)
    CALL MPINP (IU, R2%MPR, MPNW)
    CALL MPINP (IU, R3%MPR, MPNW)
    CALL MPINP (IU, R4%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READR5 (IU, R1, R2, R3, R4, R5, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_REALM), INTENT (OUT):: R1, R2, R3, R4, R5
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    R3%MPR(0) = MPWDSM6
    R4%MPR(0) = MPWDSM6
    R5%MPR(0) = MPWDSM6
    CALL MPINP (IU, R1%MPR, MPNW)
    CALL MPINP (IU, R2%MPR, MPNW)
    CALL MPINP (IU, R3%MPR, MPNW)
    CALL MPINP (IU, R4%MPR, MPNW)
    CALL MPINP (IU, R5%MPR, MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READZ1 (IU, Z1, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_COMPLEXM), INTENT (OUT):: Z1
    INTEGER L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    Z1%MPC(0) = MPWDSM6
    L1 = MPWDSM6
    Z1%MPC(L1) = MPWDSM6
    CALL MPINP (IU, Z1%MPC, MPNW)
    CALL MPINP (IU, Z1%MPC(L1:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READZ2 (IU, Z1, Z2, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_COMPLEXM), INTENT (OUT):: Z1, Z2
    INTEGER L1, L2, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    Z1%MPC(0) = MPWDSM6
    L1 = MPWDSM6
    Z1%MPC(L1) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    L2 = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    CALL MPINP (IU, Z1%MPC, MPNW)
    CALL MPINP (IU, Z1%MPC(L1:), MPNW)
    CALL MPINP (IU, Z2%MPC, MPNW)
    CALL MPINP (IU, Z2%MPC(L2:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READZ3 (IU, Z1, Z2, Z3, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_COMPLEXM), INTENT (OUT):: Z1, Z2, Z3
    INTEGER L1, L2, L3, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    Z1%MPC(0) = MPWDSM6
    L1 = MPWDSM6
    Z1%MPC(L1) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    L2 = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    Z3%MPC(0) = MPWDSM6
    L3 = MPWDSM6
    Z3%MPC(L3) = MPWDSM6
    CALL MPINP (IU, Z1%MPC, MPNW)
    CALL MPINP (IU, Z1%MPC(L1:), MPNW)
    CALL MPINP (IU, Z2%MPC, MPNW)
    CALL MPINP (IU, Z2%MPC(L2:), MPNW)
    CALL MPINP (IU, Z3%MPC, MPNW)
    CALL MPINP (IU, Z3%MPC(L3:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READZ4 (IU, Z1, Z2, Z3, Z4, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_COMPLEXM), INTENT (OUT):: Z1, Z2, Z3, Z4
    INTEGER L1, L2, L3, L4, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    Z1%MPC(0) = MPWDSM6
    L1 = MPWDSM6
    Z1%MPC(L1) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    L2 = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    Z3%MPC(0) = MPWDSM6
    L3 = MPWDSM6
    Z3%MPC(L3) = MPWDSM6
    Z4%MPC(0) = MPWDSM6
    L4 = MPWDSM6
    Z4%MPC(L4) = MPWDSM6
    CALL MPINP (IU, Z1%MPC, MPNW)
    CALL MPINP (IU, Z1%MPC(L1:), MPNW)
    CALL MPINP (IU, Z2%MPC, MPNW)
    CALL MPINP (IU, Z2%MPC(L2:), MPNW)
    CALL MPINP (IU, Z3%MPC, MPNW)
    CALL MPINP (IU, Z3%MPC(L3:), MPNW)
    CALL MPINP (IU, Z4%MPC, MPNW)
    CALL MPINP (IU, Z4%MPC(L4:), MPNW)
    RETURN
  END SUBROUTINE

  SUBROUTINE MP_READZ5 (IU, Z1, Z2, Z3, Z4, Z5, IPREC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU
    TYPE (MP_COMPLEXM), INTENT (OUT):: Z1, Z2, Z3, Z4, Z5
    INTEGER L1, L2, L3, L4, L5, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    Z1%MPC(0) = MPWDSM6
    L1 = MPWDSM6
    Z1%MPC(L1) = MPWDSM6
    Z2%MPC(0) = MPWDSM6
    L2 = MPWDSM6
    Z2%MPC(L2) = MPWDSM6
    Z3%MPC(0) = MPWDSM6
    L3 = MPWDSM6
    Z3%MPC(L3) = MPWDSM6
    Z4%MPC(0) = MPWDSM6
    L4 = MPWDSM6
    Z4%MPC(L4) = MPWDSM6
    Z5%MPC(0) = MPWDSM6
    L5 = MPWDSM6
    Z5%MPC(L5) = MPWDSM6
    CALL MPINP (IU, Z1%MPC, MPNW)
    CALL MPINP (IU, Z1%MPC(L1:), MPNW)
    CALL MPINP (IU, Z2%MPC, MPNW)
    CALL MPINP (IU, Z2%MPC(L2:), MPNW)
    CALL MPINP (IU, Z3%MPC, MPNW)
    CALL MPINP (IU, Z3%MPC(L3:), MPNW)
    CALL MPINP (IU, Z4%MPC, MPNW)
    CALL MPINP (IU, Z4%MPC(L4:), MPNW)
    CALL MPINP (IU, Z5%MPC, MPNW)
    CALL MPINP (IU, Z5%MPC(L5:), MPNW)
    RETURN
  END SUBROUTINE

  FUNCTION MP_RTOD (RA)
    IMPLICIT NONE
    REAL (MPRKND):: MP_RTOD
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER N1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    CALL MPMDC (RA%MPR, MP_RTOD, N1, MPNW)
    MP_RTOD = MP_RTOD * 2.D0**N1
    RETURN
  END FUNCTION

  FUNCTION MP_RTOM (RA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_RTOM
    TYPE (MP_REAL), INTENT (IN):: RA
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_RTOM%MPR(0) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_RTOM%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_RTOQ (RA)
    IMPLICIT NONE
    REAL (MAX (MPRKND2, KIND (1.))):: MP_RTOQ
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER N1, MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    CALL MPMQC (RA%MPR, MP_RTOQ, N1, MPNW)
    MP_RTOQ = MP_RTOQ * 2.D0**N1
    RETURN
  END FUNCTION

  FUNCTION MP_RTOR (RA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_RTOR
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    MP_RTOR%MPR(0) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_RTOR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_RTOZ (RA, RB, IPREC)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_RTOZ
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L1 = MPWDSM6
    MP_RTOZ%MPC(0) = MPWDSM6
    MP_RTOZ%MPC(L1) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_RTOZ%MPC, MPNW)
    CALL MPEQ (RB%MPR, MP_RTOZ%MPC(L1:), MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SIGN (RA, RB)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SIGN
    TYPE (MP_REALM), INTENT (IN):: RA, RB
    INTEGER MPNW
    MPNW = MAX (INT (RA%MPR(1)), INT (RB%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_SIGN%MPR(0) = MPWDSM6
    CALL MPEQ (RA%MPR, MP_SIGN%MPR, MPNW)
    MP_SIGN%MPR(2) = SIGN (MP_SIGN%MPR(2), RB%MPR(2))
    RETURN
  END FUNCTION

  FUNCTION MP_SIN (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SIN
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    TYPE (MP_REALM) R1
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_SIN%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    CALL MPCSSNR (RA%MPR, R1%MPR, MP_SIN%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SINH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SINH
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    TYPE (MP_REALM) R1
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_SINH%MPR(0) = MPWDSM6
    R1%MPR(0) = MPWDSM6
    CALL MPCSSHR (RA%MPR, R1%MPR, MP_SINH%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_SQRT (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_SQRT
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_SQRT%MPR(0) = MPWDSM6
    CALL MPSQRT (RA%MPR, MP_SQRT%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_TAN (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_TAN
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    MP_TAN%MPR(0) = MPWDSM6
    CALL MPCSSNR (RA%MPR, R1%MPR, R2%MPR, MPNW)
    IF (R1%MPR(2) == 0.D0) THEN
      WRITE (MPLDB, 1)
1     FORMAT ('*** MP_TAN: Cos of argument is zero.')
      CALL MPABRT (26)
    ENDIF
    CALL MPDIV (R2%MPR, R1%MPR, MP_TAN%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_TANH (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_TANH
    TYPE (MP_REALM), INTENT (IN):: RA
    TYPE (MP_REALM) R1, R2
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    R1%MPR(0) = MPWDSM6
    R2%MPR(0) = MPWDSM6
    MP_TANH%MPR(0) = MPWDSM6
    CALL MPCSSHR (RA%MPR, R1%MPR, R2%MPR, MPNW)
    CALL MPDIV (R2%MPR, R1%MPR, MP_TANH%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_WPREC (RA)
    IMPLICIT NONE
    INTEGER MP_WPREC
    TYPE (MP_REALM), INTENT (IN):: RA
    MP_WPREC = MIN (INT (RA%MPR(1)), MPWDSM)
    RETURN
  END FUNCTION

  FUNCTION MP_WPRECZ (ZA)
    IMPLICIT NONE
    INTEGER MP_WPRECZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1
    L1 = ZA%MPC(0)
    MP_WPRECZ = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MP_WPRECZ = MIN (MP_WPRECZ, MPWDSM)
    RETURN
  END FUNCTION

  SUBROUTINE MP_WRITER (IU, LN, LD, R1, R2, R3, R4, R5)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU, LN, LD
    TYPE (MP_REALM), INTENT (IN):: R1, R2, R3, R4, R5
    OPTIONAL:: R2, R3, R4, R5
    INTEGER MPNW

    MPNW = MIN (INT (R1%MPR(1)), MPWDSM)
    CALL MPOUT (IU, LN, LD, R1%MPR, MPNW)
    IF (PRESENT (R2)) THEN
      MPNW = MIN (INT (R2%MPR(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, R2%MPR, MPNW)
    ENDIF
    IF (PRESENT (R3)) THEN
      MPNW = MIN (INT (R3%MPR(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, R3%MPR, MPNW)
    ENDIF
    IF (PRESENT (R4)) THEN
      MPNW = MIN (INT (R4%MPR(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, R4%MPR, MPNW)
    ENDIF
    IF (PRESENT (R5)) THEN
      MPNW = MIN (INT (R5%MPR(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, R5%MPR, MPNW)
    ENDIF

    RETURN
  END SUBROUTINE

  SUBROUTINE MP_WRITEZ (IU, LN, LD, Z1, Z2, Z3, Z4, Z5)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: IU, LN, LD
    TYPE (MP_COMPLEXM), INTENT (IN):: Z1, Z2, Z3, Z4, Z5
    OPTIONAL:: Z2, Z3, Z4, Z5
    INTEGER L1, L2, L3, L4, L5, MPNW

    L1 = Z1%MPC(0)
    MPNW = MIN (INT (Z1%MPC(1)), MPWDSM)
    CALL MPOUT (IU, LN, LD, Z1%MPC, MPNW)
    CALL MPOUT (IU, LN, LD, Z1%MPC(L1:), MPNW)
    IF (PRESENT (Z2)) THEN
      L2 = Z2%MPC(0)
      MPNW = MIN (INT (Z2%MPC(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, Z2%MPC, MPNW)
      CALL MPOUT (IU, LN, LD, Z2%MPC(L2:), MPNW)
    ENDIF
    IF (PRESENT (Z3)) THEN
      L3 = Z3%MPC(0)
      MPNW = MIN (INT (Z3%MPC(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, Z3%MPC, MPNW)
      CALL MPOUT (IU, LN, LD, Z3%MPC(L3:), MPNW)
    ENDIF
    IF (PRESENT (Z4)) THEN
      L4 = Z4%MPC(0)
      MPNW = MIN (INT (Z4%MPC(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, Z4%MPC, MPNW)
      CALL MPOUT (IU, LN, LD, Z4%MPC(L4:), MPNW)
    ENDIF
    IF (PRESENT (Z5)) THEN
      L5 = Z5%MPC(0)
      MPNW = MIN (INT (Z5%MPC(1)), MPWDSM)
      CALL MPOUT (IU, LN, LD, Z5%MPC, MPNW)
      CALL MPOUT (IU, LN, LD, Z5%MPC(L5:), MPNW)
    ENDIF

    RETURN
  END SUBROUTINE

  FUNCTION MP_ZETA (RA)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ZETA
    TYPE (MP_REALM), INTENT (IN):: RA
    INTEGER MPNW
    MPNW = MIN (INT (RA%MPR(1)), MPWDSM)
    MP_ZETA%MPR(0) = MPWDSM6
    CALL MPZETAR (RA%MPR, MP_ZETA%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ZETAEM (NB, RB, RC)
    IMPLICIT NONE
    INTEGER, INTENT (IN):: NB
    TYPE (MP_REALM):: MP_ZETAEM
    TYPE (MP_REALM), INTENT (IN):: RB(NB), RC
    INTEGER N1, MPNW
    MPNW = MAX (INT (RB(1)%MPR(1)), INT (RC%MPR(1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_ZETAEM%MPR(0) = MPWDSM6
    N1 = MPWDSM
    CALL MPZETAEMR (N1, NB, RB(1)%MPR, RC%MPR, MP_ZETAEM%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ZTODC (ZA)
    IMPLICIT NONE
    COMPLEX (KIND(0.D0)):: MP_ZTODC
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, MPNW, N1, N2
    REAL (MPRKND) D1, D2
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    CALL MPMDC (ZA%MPC, D1, N1, MPNW)
    D1 = D1 * 2.D0 ** N1
    CALL MPMDC (ZA%MPC(L1:), D2, N2, MPNW)
    D2 = D2 * 2.D0 ** N2
    MP_ZTODC = CMPLX (D1, D2, MPRKND)
    RETURN
  END FUNCTION

  FUNCTION MP_ZTOR (ZA, IPREC)
    IMPLICIT NONE
    TYPE (MP_REALM):: MP_ZTOR
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L1, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L1 = ZA%MPC(0)
    MPNW = MAX (INT (ZA%MPC(1)), INT (ZA%MPC(L1+1)))
    MPNW = MIN (MPNW, MPWDSM)
    MP_ZTOR%MPR(0) = MPWDSM6
    CALL MPEQ (ZA%MPC, MP_ZTOR%MPR, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ZTOZ (ZA, IPREC)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ZTOZ
    TYPE (MP_COMPLEXM), INTENT (IN):: ZA
    INTEGER L2, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L2 = MPWDSM6
    MP_ZTOZ%MPC(0) = MPWDSM6
    MP_ZTOZ%MPC(L2) = MPWDSM6
    CALL MPCEQ (ZA%MPC, MP_ZTOZ%MPC, MPNW)
    RETURN
  END FUNCTION

  FUNCTION MP_ZTOZM (ZA, IPREC)
    IMPLICIT NONE
    TYPE (MP_COMPLEXM):: MP_ZTOZM
    TYPE (MP_COMPLEX), INTENT (IN):: ZA
    INTEGER L2, MPNW

!>  In variant #1, uncomment these lines:
    INTEGER, OPTIONAL, INTENT (IN):: IPREC
    IF (PRESENT (IPREC)) THEN
      MPNW = MP_SETWP (IPREC)
    ELSE
      MPNW = MPWDSM
    ENDIF
!  Otherwise in variant #2, uncomment these lines:
!    integer, intent (in):: iprec
!    mpnw = mp_setwp (iprec)
!>>
    L2 = MPWDSM6
    MP_ZTOZM%MPC(0) = MPWDSM6
    MP_ZTOZM%MPC(L2) = MPWDSM6
    CALL MPCEQ (ZA%MPC, MP_ZTOZM%MPC, MPNW)
    RETURN
  END FUNCTION
END MODULE ModLib_MPFUNH

