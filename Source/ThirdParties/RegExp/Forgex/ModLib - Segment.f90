MODULE ModLib_Segment
   USE, INTRINSIC :: ISO_FORTRAN_ENV
   USE :: ModLib_UTF8
   IMPLICIT NONE

   TYPE, PUBLIC :: SEGMENT_T
      INTEGER(INT32) :: MIN = UTF8_CODE_EMPTY ! = 0
      INTEGER(INT32) :: MAX = UTF8_CODE_EMPTY ! = 0
   CONTAINS
      PROCEDURE :: PRINT => SEGMENT_FOR_PRINT
      PROCEDURE :: VALIDATE => SEGMENT_IS_VALID
   END TYPE

   ! See ASCII code set
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_EMPTY = SEGMENT_T(UTF8_CODE_EMPTY, UTF8_CODE_EMPTY)
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_ANY   = SEGMENT_T(UTF8_CODE_MIN, UTF8_CODE_MAX)
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_TAB   = SEGMENT_T(9, 9)     ! Horizontal Tab
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_LF    = SEGMENT_T(10, 10)   ! Line Feed
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_FF    = SEGMENT_T(12, 12)   ! Form Feed
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_CR    = SEGMENT_T(13, 13)   ! Carriage Return
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_SPACE = SEGMENT_T(32, 32)   ! White space
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_UNDERSCORE = SEGMENT_T(95, 95)
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_DIGIT = SEGMENT_T(48, 57)   ! 0-9
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_UPPERCASE = SEGMENT_T(65, 90)   ! A-Z
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_LOWERCASE = SEGMENT_T(97, 122)  ! a-z
   TYPE(SEGMENT_T), PARAMETER, PUBLIC :: SEG_ZENKAKU_SPACE = SEGMENT_T(12288, 12288) ! '　' U+3000 全角スペース

   INTERFACE OPERATOR(==)
      MODULE PROCEDURE :: SEGMENT_EQUIVALENT
   END INTERFACE

   INTERFACE OPERATOR(/=)
      MODULE PROCEDURE :: SEGMENT_NOT_EQUIV
   END INTERFACE

   INTERFACE OPERATOR(.IN.)
      MODULE PROCEDURE :: ARG_IN_SEGMENT
      MODULE PROCEDURE :: ARG_IN_SEGMENT_LIST
      MODULE PROCEDURE :: SEG_IN_SEGMENT
   END INTERFACE


CONTAINS


   FUNCTION ARG_IN_SEGMENT(A, SEG) RESULT(RES)
      IMPLICIT NONE
      INTEGER(INT32), INTENT(IN) :: A
      TYPE(SEGMENT_T), INTENT(IN) :: SEG
      LOGICAL :: RES

      RES = SEG%MIN <= A .AND. A <= SEG%MAX
   END FUNCTION ARG_IN_SEGMENT


   FUNCTION ARG_IN_SEGMENT_LIST(A, SEG_LIST) RESULT(RES)
      IMPLICIT NONE
      INTEGER(INT32), INTENT(IN) :: A
      TYPE(SEGMENT_T), INTENT(IN) :: SEG_LIST(:)
      LOGICAL :: RES
      INTEGER :: I

      RES = .FALSE.
      DO I = 1, UBOUND(SEG_LIST, DIM=1)
         RES = RES .OR. (SEG_LIST(I)%MIN <= A .AND. A <= SEG_LIST(I)%MAX)
      END DO

   END FUNCTION ARG_IN_SEGMENT_LIST

   FUNCTION SEG_IN_SEGMENT(A, B) RESULT(RES)
      IMPLICIT NONE
      TYPE(SEGMENT_T), INTENT(IN) :: A, B
      LOGICAL :: RES

      RES =  B%MIN <= A%MIN .AND. A%MAX <= B%MAX

   END FUNCTION SEG_IN_SEGMENT

   FUNCTION SEGMENT_EQUIVALENT(A, B) RESULT(RES)
      IMPLICIT NONE
      TYPE(SEGMENT_T), INTENT(IN) :: A, B
      LOGICAL :: RES

      RES = A%MAX == B%MAX .AND. A%MIN == B%MIN
   END FUNCTION SEGMENT_EQUIVALENT


   FUNCTION SEGMENT_NOT_EQUIV(A, B) RESULT(RES)
      IMPLICIT NONE
      TYPE(SEGMENT_T), INTENT(IN) :: A, B
      LOGICAL :: RES

      RES = A%MAX /= B%MAX .OR. A%MIN /= B%MIN

   END FUNCTION SEGMENT_NOT_EQUIV

   FUNCTION SEGMENT_FOR_PRINT (SEG) RESULT(RES)
      IMPLICIT NONE
      CLASS(SEGMENT_T), INTENT(IN) :: SEG
      CHARACTER(:), ALLOCATABLE :: RES

      IF (SEG == SEG_ANY) THEN
         RES = "<ANY>"
      ELSE IF (SEG == SEG_LF) THEN
         RES = "<LF>"
      ELSE IF (SEG == SEG_CR) THEN
         RES = "<CR>"
      ELSE IF (SEG == SEG_FF) THEN
         RES = "<FF>"
      ELSE IF (SEG == SEG_TAB) THEN
         RES = "<TAB>"
      ELSE IF (SEG == SEG_SPACE) THEN
         RES = "<SPACE>"
      ELSE IF (SEG == SEG_ZENKAKU_SPACE) THEN
         RES = "<ZENKAKU SPACE>"
      ELSE IF (SEG == SEG_EMPTY) THEN
         RES = "?"

      ELSE IF (SEG%MIN == SEG%MAX) THEN
         RES = CHAR_UTF8(SEG%MIN)
      ELSE IF (SEG%MAX == UTF8_CODE_MAX) THEN
         RES = '["'//CHAR_UTF8(SEG%MIN)//'"-'//"<U+1FFFFF>"//']'
      ELSE
         RES = '["'//CHAR_UTF8(SEG%MIN)//'"-"'//CHAR_UTF8(SEG%MAX)//'"]'
      END IF

   END FUNCTION SEGMENT_FOR_PRINT


   FUNCTION SEGMENT_IS_VALID(SELF) RESULT(RES)
      IMPLICIT NONE
      CLASS(SEGMENT_T) :: SELF
      LOGICAL :: RES

      RES = SELF%MIN <= SELF%MAX

   END FUNCTION SEGMENT_IS_VALID


END MODULE ModLib_Segment
