 
MODULE ModLib_Display_Auxiliary

!** PURPOSE OF THIS MODULE:
    ! THIS MODULE CONTAINS UTILITIES THAT ARE USED BY UTILITY_DISPLAY MUDULE.
    !   NOTE THAT THE ENTITIES THAT ARE DECLARED PUBLIC BELOW ARE NOT EXPORTED
    !   TO THE USER. THE PRIVATE STATEMENTS IN UTILITY_DISPLAY MUDULE PREVENT
    !   THAT FROM HAPPENING.
    !
    ! Copyright (c) 2008, Kristjan Jonasson, Dept. of Computer Science, University of
    ! Iceland (jonasson@hi.is). This software is free. For details see the file README.

!** USE STATEMENTS:
    ! NA

    IMPLICIT NONE       ! Enforce explicit typing of all variables

!** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS
    PUBLIC  :: DISP_SETTINGS, DEFSET, FACTORY_SETTINGS
    PUBLIC  :: TOSSET, TOSFAC, ERRORMSG, TOSTRING_SETTINGS
    PUBLIC  :: NNBLK, UPPER, READFMT, REPLACE_W, TRIM_REAL
    PUBLIC  :: GET_SE, PREPAREBOX, COPYTOBOX, BOXLIST, BOXNODE
    PUBLIC  :: COPYSEPTOBOX, FINISHBOX, TOSTRING_GET_COMPLEX
    PUBLIC  :: DISP_ERRMSG, TOSTRING_GET, FIND_EDITDESC_REAL
    PUBLIC  :: CHECK_SETTINGS, TOSTRING_CHECK_SETTINGS
    PUBLIC  :: REPLACE_ZERONANINF, SETTINGS, TRIM_S_REAL

    PRIVATE          ! by default, hide all data and routines except those declared explicitly

!** MODULE PARAMETERS:
    INTEGER,      PARAMETER :: DEFAULT_UNIT = -3
    CHARACTER(*), PARAMETER :: ERRORMSG = 'ILLEGAL FORMAT'

!** DERIVED TYPE DEFINITIONS:
    !
    ! *********************************** GENERAL DECLARATIONS ********************************************
    TYPE DISP_SETTINGS
        ! SETTINGS USED BY SUBROUTINE DISP AND THE UTILITY PROCEDURES.
        CHARACTER(6) :: ADVANCE     = 'YES'
        CHARACTER(9) :: MATSEP      = '   '
        CHARACTER(3) :: ORIENT      = 'COL'
        CHARACTER(9) :: SEP         = '  '
        CHARACTER(9) :: STYLE       = 'LEFT'
        CHARACTER(4) :: TRIM        = 'AUTO'
        CHARACTER(9) :: ZEROAS      = ''
        INTEGER      :: DIGMAX      = 6
        INTEGER      :: MATSEPLEN   = 3
        INTEGER      :: SEPLEN      = 2
        INTEGER      :: UNIT        = DEFAULT_UNIT
        INTEGER      :: ZASLEN      = 0
    END TYPE DISP_SETTINGS
    !
    TYPE TOSTRING_SETTINGS
        ! SETTINGS USED BY FUNCTION TOSTRING.
        CHARACTER(10) :: IFMT = 'I0'
        CHARACTER(16) :: RFMT = '1PG12.5'  ! 'SP,1P,G20.11E3' HAS LENGTH 14 AND IS ABOUT MAX
        CHARACTER(9)  :: SEP = ', '
        INTEGER       :: SEPLEN = 2
        CHARACTER(3)  :: TRIMB = 'YES'
        CHARACTER(4)  :: TRIMZ = 'G'
    END TYPE TOSTRING_SETTINGS
    !
    TYPE SETTINGS
    ! SETTINGS USED (PRIVATELY) BY DISP AND THE UTILITY PROCEDURES, IN THE VARIABLE SE.
        CHARACTER(22) ED
        CHARACTER(9) SEP, TSTY, ZAS
        CHARACTER(1) TCH
        INTEGER LUN, DMX, W, D, LSEP, LZAS, M1, N1, ADV
        LOGICAL TRM, NUMBER, VEC, ROW, GEDIT
    END TYPE SETTINGS
    !
    ! ********************* BOX-PACKAGE DECLARATIONS (SEE EXPLANATION ABOUT BOX-PACKAGE BELOW) *****************
    !
    TYPE BOXNODE
        ! A BOX IS THE CHARACTER REPRESENTATION OF A PRINTED ITEM
        CHARACTER, POINTER     :: BOX(:,:)
        TYPE(BOXNODE), POINTER :: NEXTBOX => NULL()
    END TYPE BOXNODE
    !
    TYPE BOXLIST
        ! THERE IS ONE LIST OF BOXES ASSOCIATED WITH EACH LOGICAL UNIT
        INTEGER :: UNIT = 1
        TYPE(BOXNODE), POINTER :: FIRSTBOX => NULL()
        TYPE(BOXNODE), POINTER :: LASTBOX => NULL()
        TYPE(BOXLIST), POINTER :: NEXTBOXLIST => NULL()
    END TYPE BOXLIST
    !

!** INTERFACE DEFINITIONS:
    ! na
    
!** MODULE VARIABLE DECLARATIONS:
    TYPE(DISP_SETTINGS), SAVE       :: DEFSET, &        ! CURRENT DEFAULT SETTINGS FOR DISP
                                       FACTORY_SETTINGS ! ORIGINAL (FACTORY) SETTINGS FOR DISP
    TYPE(TOSTRING_SETTINGS), SAVE   :: TOSSET, &        ! CURRENT SETTINGS FOR TOSTRING
                                       TOSFAC           ! FACTORY SETTINGS FOR TOSTRING
    TYPE(BOXLIST), POINTER :: FIRSTBOXLIST => NULL()

    CONTAINS

!** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS):

  ! ***************************** GENERAL PROCEDURES **************************************
  SUBROUTINE CHECK_SETTINGS()
    ! SANITY CHECK OF DISPLAY SETTINGS
    CHARACTER(9) :: TSTY
    CHARACTER TCH
    LOGICAL NUMBER, OK, DMXERR, ORIERR, STYERR, ADVERR
    CHARACTER(6), PARAMETER :: ADVOK(3) = (/'NO    ', 'YES   ', 'DOUBLE'/)
    TYPE(DISP_SETTINGS) DS
    DS = DEFSET
    CALL GETSTYLES(DS % STYLE, TSTY, TCH, NUMBER, OK)
    STYERR = .NOT. OK
    DMXERR = DS % DIGMAX < 1 .OR. DS % DIGMAX > 89
    ORIERR = ALL(DS % ORIENT /= (/'ROW', 'COL'/))
    ADVERR = ALL(DS % ADVANCE /= ADVOK)
    IF (DMXERR) DEFSET % DIGMAX = 6
    IF (ORIERR) DEFSET % ORIENT = 'COL'
    IF (STYERR) DEFSET % STYLE = 'LEFT'
    IF (ADVERR) DEFSET % ADVANCE = 'YES'
    !
    IF (DMXERR) CALL DISP_ERRMSG('DISP_SET: ERROR, ILLEGAL DIGMAX (MUST BE 1-89), SET TO 6')
    IF (ORIERR) CALL DISP_ERRMSG('DISP_SET: ERROR, ILLEGAL ORIENT: ' // TRIM(DS % ORIENT) // ', SET TO "COL"')
    IF (STYERR) CALL DISP_ERRMSG('DISP_SET: ERROR, ILLEGAL STYLE: ' // TRIM(DS % STYLE) // ', SET TO "LEFT"')
    IF (ADVERR) CALL DISP_ERRMSG('DISP_SET: ERROR, ILLEGAL ADVANCE: ' // TRIM(DS % ADVANCE) // ', SET TO "YES"')
  END SUBROUTINE CHECK_SETTINGS

  FUNCTION NUMBER_ROWS(SE) RESULT(NBR)
    ! SHOULD ROWS BE NUMBERED?
    TYPE(SETTINGS), INTENT(IN) :: SE
    LOGICAL NBR
    NBR = .FALSE.
    IF (.NOT. SE % NUMBER) RETURN
    IF (SE % VEC .AND. SE % ROW) RETURN
    NBR = .TRUE.
  END FUNCTION NUMBER_ROWS

  FUNCTION NUMBER_COLS(SE) RESULT(NBR)
    ! SHOULD COLUMNS BE NUMBERED?
    TYPE(SETTINGS), INTENT(IN) :: SE
    LOGICAL NBR
    NBR = .FALSE.
    IF (.NOT. SE % NUMBER) RETURN
    IF (SE % VEC .AND. .NOT. SE % ROW) RETURN
    NBR = .TRUE.
  END FUNCTION NUMBER_COLS

  SUBROUTINE PREPAREBOX(TITLE, SE, M, N, WID, WIDP, LIN1, WLEFT, BOXP)
    ! DETERMINE FORMAT TO USE TO WRITE MATRIX TO BOX AND ROW WHERE MATRIX BEGINS, COPY
    CHARACTER(*),   INTENT(IN)    :: TITLE     ! THE TITLE TO USE FOR THE MATRIX
    TYPE(SETTINGS), INTENT(IN)    :: SE        ! SETTINGS
    INTEGER,        INTENT(IN)    :: M         ! ROW COUNT OF MATRIX
    INTEGER,        INTENT(IN)    :: N         ! COLUMN COUNT OF MATRIX
    INTEGER,        INTENT(INOUT) :: WID(:)    ! WIDTHS OF COLUMNS IN MATRIX
    INTEGER,        INTENT(OUT)   :: WIDP(:)   ! WIDTHS OF COLUMNS IN BOX (MAX(WID, WIDTH OF COL NUMS))
    INTEGER,        INTENT(OUT)   :: LIN1      ! ROW NUMBER WHERE MATRIX BEGINS (TSTY='LEFT' 0, 'PAD' 1, 'UNDERLINE' 2)
    INTEGER,        INTENT(OUT)   :: WLEFT     ! NUMBER OF SPACES ON LEFT OF MATRIX (WHEN TSTY IS LEFT OR TITLE LONG)
    CHARACTER, POINTER            :: BOXP(:,:) ! THE BOX

    INTEGER WT, WA          ! CHAR COUNT OF TITLE, IDTH OF MATRIX IN CHARACTERS (WBOX = LM + WA + RM)
    INTEGER WBOX, WROW      ! WIDTH OF BOX IN CHARACTERS, WIDTH OF ROW NUMBERS IN CHARACTERS
    INTEGER LM              ! LEFT MARGIN
    INTEGER H,WS            ! HEIGHT OF BOX IN CHARACTERS, LENGTH OF COLUMN SEPARATOR
    INTEGER M1, N1, I       ! LOWER BOUNDS (FOR NUMBERING), INDEX
    CHARACTER(RANGE(0) + 2) SN(2), ROW_NUMS(M), COL_NUMS(N)
    CHARACTER(10) FMT

    ! ----------WBOX---------    -----------WBOX----------     -----WBOX------
    ! ---LM---                   --WLEFT-                             --WT-
    ! ----WLEFT---                LM WROW    WA       RM       WROW    WA
    !    WT   WROW    WA         ----====-----------======     ----===========
    ! --------====-----------    THIS-IS-A-VERY-LONG-TITLE            TITLE
    !               1     2                1     2                   1     2
    ! MATRIX = 1   4.50  6.80         1   4.50  6.80            1   4.50  6.80
    !          2   6.88  9.22         2   6.88  9.22            2   6.88  9.22
    !          3  19.44  0.08         3  19.44  0.08            3  19.44  0.08
    !          ...                    ...                       ...
    !         10   6.18  4.22        10   6.18  4.22           10   6.18  4.22
    ! RM = 0                     WT = WBOX                     LM = RM = 0, WLEFT = WROW
    M1 = SE % M1
    N1 = SE % N1
    WS = SE % LSEP
    WT = LEN(TITLE)
    WROW = 0
    WIDP = WID
    IF (SE % NUMBER) THEN
      FMT = '(SS,I0)'
      IF (NUMBER_COLS(SE)) THEN
        WRITE(COL_NUMS, FMT) (/ (I, I = N1, N1 + N - 1) /)
        WIDP = MAX(WID, LEN_TRIM(COL_NUMS))
      ENDIF
      IF (NUMBER_ROWS(SE)) THEN
        WRITE(SN, FMT) M1, M1 + M - 1
        WROW = MAXVAL(LEN_TRIM(SN)) + WS  ! DETERMINE MAX WIDTH OF ROW NUMBERS
        CALL REPLACE_W(FMT, WROW - WS) ! TO CREATE E.G. 'I5' FROM 'I0'
        WRITE(ROW_NUMS, FMT) (/ (I, I = M1, M1 + M - 1) /)
      ENDIF
    ENDIF
    WA = MAX(0,N-1)*WS + SUM(WIDP)
    SELECT CASE(UPPER(SE % TSTY))
    CASE('LEFT');      LIN1 = 1; WBOX = WT + WROW + WA;     H = MAX(1,M); LM = WT
    CASE('PAD');       LIN1 = 2; WBOX = MAX(WT, WA + WROW); H = M + 1;    LM = MAX(0, (WT - WA - WROW)/2)
    CASE('UNDERLINE'); LIN1 = 3; WBOX = MAX(WT, WA + WROW); H = M + 2;    LM = MAX(0, (WT - WA - WROW)/2)
    CASE DEFAULT;      LIN1 = 1; WBOX = 0; H = 0; LM = 0 ! SHOULD NOT HAPPEN
    END SELECT
    WLEFT = LM
    IF (NUMBER_COLS(SE)) H = H + 1
    CALL NEWBOX(SE % LUN, H, WBOX, BOXP)
    IF (NUMBER_COLS(SE)) THEN
      CALL COPYCOLUMNNUMBERSTOBOX(COL_NUMS, WLEFT + WROW, WID, WIDP, WS,  BOXP, LIN1)
    ENDIF
    IF (NUMBER_ROWS(SE)) THEN
      CALL COPYTOBOX(ROW_NUMS, LIN1, WROW - WS, WROW - WS, NBLJ = 0, BOXP = BOXP, WLEFT = WLEFT)
      CALL COPYSEPTOBOX(SE % SEP(1:SE % LSEP), M, LIN1, BOXP, WLEFT)
    ENDIF
  END SUBROUTINE PREPAREBOX

  SUBROUTINE COPYTOBOX(S, LIN1, WIDJ, WIDPJ, NBLJ, BOXP,  WLEFT)
    ! COPY STRINGS TO COLUMN IN BOXP; UPDATE WLEFT TO CURRENT CHAR COLUMN IN BOXP
    CHARACTER(*), INTENT(IN)    :: S(:)        ! THE STRINGS TO COPY
    INTEGER,      INTENT(IN)    :: LIN1, WIDJ  ! FIRST LINE IN BOX TO COPY TO, WIDTH OF COLUMN
    INTEGER,      INTENT(IN)    :: NBLJ, WIDPJ ! NUMBER OF BLANK CHARACTERS TO TRIM FROM LEFT OF S, OFFSET TO NEXT COL
    CHARACTER,    INTENT(INOUT) :: BOXP(:,:)   ! THE BOX TO ACCEPT THE COLUMN
    INTEGER,      INTENT(INOUT) :: WLEFT       ! NUMBER OF CHAR-COLUMNS IN BOX ALREADY WRITTEN TO
    INTEGER I, J
    WLEFT = WLEFT + WIDPJ - WIDJ
    FORALL(I = 1:WIDJ, J=1:SIZE(S)) BOXP(WLEFT+I, J+LIN1-1) = S(J)(I+NBLJ:I+NBLJ)
    WLEFT = WLEFT + WIDJ
  END SUBROUTINE COPYTOBOX

  SUBROUTINE COPYSEPTOBOX(SEP, M, LIN1, BOXP,  WLEFT)
    ! COPY COLUMN SEPARATOR TO BOXP; UPDATE WLEFT
    CHARACTER(*), INTENT(IN)    :: SEP
    INTEGER,      INTENT(IN)    :: M, LIN1
    CHARACTER,    INTENT(INOUT) :: BOXP(:,:)
    INTEGER,      INTENT(INOUT) :: WLEFT
    INTEGER I, J
    FORALL(I = 1:LEN(SEP), J=1:M) BOXP(WLEFT+I, J+LIN1-1) = SEP(I:I)
    WLEFT = WLEFT + LEN(SEP)
  END SUBROUTINE COPYSEPTOBOX

  SUBROUTINE COPYCOLUMNNUMBERSTOBOX(S, WLEFT, WID, WIDP, LSEP, BOXP, LIN1)
    CHARACTER(*), INTENT(IN)    :: S(:)      ! STRINGS WITH LEFT-ADJUSTED COLUMN NUMBERS
    INTEGER,      INTENT(IN)    :: WLEFT     ! CHAR POSITIONS ON LEFT OF 1ST COL
    INTEGER,      INTENT(IN)    :: WID(:)    ! WIDTHS OF COLUMNS IN MATRIX
    INTEGER,      INTENT(IN)    :: WIDP(:)   ! WIDTHS OF COLUMNS IN BOX (MAX(WID, WIDTH OF COL NUMS))
    INTEGER,      INTENT(IN)    :: LSEP      ! WIDTH OF COLUMN SEPARATOR
    CHARACTER,    INTENT(INOUT) :: BOXP(:,:) ! RECEIVES THE NUMBERS
    INTEGER,      INTENT(INOUT) :: LIN1      ! LINE NUMBER IN BOX TO COPY TO
    INTEGER LS(SIZE(S)), RMARGMAX, K, I, LMARGIN, J
    !
    LS = LEN_TRIM(S)
    RMARGMAX = (MAX(0, MINVAL(WID) - MAXVAL(LS)))/2 ! LOCATE ACCORDING TO NARROWEST COLUMN, WIDEST NUMBER
    K = WLEFT
    DO I = 1, SIZE(WID)
      LMARGIN = MAX(0, WIDP(I) - LS(I) - RMARGMAX)
      K = K + LMARGIN
      FORALL(J = 1:LS(I)) BOXP(K+J, LIN1) = S(I)(J:J)
      K = K + WIDP(I) - LMARGIN + LSEP
    ENDDO
    LIN1 = LIN1 + 1
  END SUBROUTINE COPYCOLUMNNUMBERSTOBOX

  SUBROUTINE FINISHBOX(TITLE, SE, BOXP)
    ! FINISH CREATING A BOX AND DISPLAY IT IF ADVANCING IS TURNED ON
    CHARACTER(*),   INTENT(IN)    :: TITLE     ! THE TITLE TO USE FOR THE MATRIX
    TYPE(SETTINGS), INTENT(IN)    :: SE        ! SETTINGS
    CHARACTER,      INTENT(INOUT) :: BOXP(:,:) ! THE BOX
    !
    INTEGER I, WT, W, WPADRIGHT, WPADLEFT ! INDEX, WIDTH OF TITLE, WIDTH OF BOX AND SPACING ON EITHER SIDE OF IT
    INTEGER LIN1 ! LINE TO PUT LEFT TITLE
    !
    WT = LEN(TITLE)
    W = SIZE(BOXP,1)
    IF (UPPER(SE % TSTY) == 'LEFT') THEN
      LIN1 = 1
      IF (NUMBER_COLS(SE)) LIN1 = MIN(2,SIZE(BOXP,2))
      FORALL(I=1:WT) BOXP(I,LIN1) = TITLE(I:I)
    ELSE
      WPADRIGHT = (W - WT)/2
      WPADLEFT = W - WPADRIGHT - WT
      FORALL(I=1:WT) BOXP(WPADLEFT+I, 1) = TITLE(I:I)
      IF (UPPER(SE % TSTY) == 'PAD') THEN
        BOXP(1:WPADLEFT, 1) = SE % TCH
        BOXP(W-WPADRIGHT+1:W, 1) = SE % TCH
      ELSE ! TSTY == 'UNDERLINE'
        BOXP(:,2) = SE % TCH
      ENDIF
    ENDIF
    IF (SE % ADV >= 1) CALL DISPBOXLIST(SE % LUN, DEFSET % MATSEP(1:DEFSET % MATSEPLEN))
    IF (SE % ADV >= 2) CALL DISPNEWLINE(SE % LUN)
  END SUBROUTINE FINISHBOX

  SUBROUTINE FIND_EDITDESC_REAL(EXP, EXPM, DMX,  EDESC, FLEN, NDEC, POSIT)
    ! SUBROUTINE OF FIND_EDITDESC_SNGL AND FIND_EDITDESC_DBLE
    INTEGER,       INTENT(IN)    :: EXPM, DMX
    INTEGER,       INTENT(INOUT) :: EXP
    CHARACTER(14), INTENT(OUT)   :: EDESC
    INTEGER,       INTENT(OUT)   :: FLEN, NDEC
    LOGICAL,       INTENT(IN)    :: POSIT
    INTEGER :: NEG, NXP
    EXP = MAX(EXP, EXPM)
    NEG = 1
    IF (EXP < DMX .AND. EXP >= -1) THEN
      IF (POSIT .OR. EXP > MAX(0, EXPM)) NEG = 0
      EDESC = '(SS,FXX.YY)'
      NDEC = MAX(0, DMX - EXP - 1)
      FLEN = NEG + 2 + NDEC + MAX(0,EXP) ! -X.YYYYY (2 COVERS X AND .)
      WRITE(EDESC(6:10), '(SS,I2,".",I2)') FLEN, NDEC
    ELSE
      IF (POSIT) NEG = 0
      IF     (ABS(EXP) > 999) THEN; NXP = 4
      ELSEIF (ABS(EXP) >  99) THEN; NXP = 3
      ELSEIF (ABS(EXP) >   9) THEN; NXP = 2
      ELSE                        ; NXP = 1
      ENDIF
      FLEN = NEG + 3 + DMX + NXP
      EDESC = '(SS,ESXX.YYEZ)'
      WRITE(EDESC(7:13), '(SS,I2,".",I2,"E",I1)') FLEN, DMX - 1, NXP
      NDEC = DMX - 1
    ENDIF
  END SUBROUTINE FIND_EDITDESC_REAL

  PURE SUBROUTINE READFMT(FMT, FMT1, W, D, GEDIT)
    ! RETURNS W AND D WHEN FMT IS (XW.D) OR (XW) (THEN D = 0), X = EDIT DESCRIPTOR LETTER
    ! (I, F, ETC). X CAN ALSO BE ES, DS, 1PG OR 1PF. RETURNS W = -1 FOR ILLEGAL FMT.
    ! RETURNS GEDIT = .TRUE. IF FMT IS GW.D. HOW ABOUT SS,1PES4.3?
    CHARACTER(*), INTENT(IN)  :: FMT  ! E.G. FMT = F 8.2
    CHARACTER(*), INTENT(OUT) :: FMT1 ! RETURNS '(SS,F8.2)'
    CHARACTER CH
    INTEGER, INTENT(OUT) :: W, D
    LOGICAL, INTENT(OUT) :: GEDIT
    INTEGER :: K0, K1, K2, K3, K4
    CALL SSZIPFMT(FMT, FMT1)
    W = -1; D = 0; GEDIT = .FALSE.
    K1 = VERIFY(FMT1(2:), '0123456789') + 1
    IF (K1 == 0) RETURN ! ONLY DIGITS
    K2 = VERIFY(FMT1(K1:), 'ABDEFGILNOPSZABDEFGILNOPSZ,') + K1 - 1 ! , FOR "1P,G12.3"
    IF (K2 <= K1) RETURN ! NO LETTER OR ONLY LETTERS
    CH = UPPER(FMT1(K2-1:K2-1))
    IF (CH == ',') THEN ! DEAL WITH SS,1PG13.5
      K0 = K2
      K1 = VERIFY(FMT1(K0:),'0123456789') + K0 - 1
      IF (K1==0) RETURN
      K2 = VERIFY(FMT1(K1:),'ABDEFGILNOPSZABDEFGILNOPSZ,') + K1 - 1
      IF (K2 <= K1) RETURN
      CH = UPPER(FMT1(K2-1:K2-1))
    ENDIF
    GEDIT = CH == 'G' .OR. CH == 'G'
    K3 = VERIFY(FMT1(K2:), '0123456789') + K2 - 1
    IF (K3 == K2) RETURN ! NO DIGITS
    READ(FMT1(K2:K3-1), *) W
    IF (K3 > LEN(FMT1)) RETURN
    IF (FMT1(K3:K3) /= '.') RETURN ! NOT . AFTER W
    K4 = VERIFY(FMT1(K3+1:), '0123456789') + K3
    IF (K4 == K3+1) RETURN ! NO DIGITS
    READ(FMT1(K3+1:K4-1), *) D
  END SUBROUTINE READFMT

  PURE SUBROUTINE REPLACE_W(FMT, WNEW)
    ! CHANGE E.G. '(F0.3)' TO '(F5.3)'. WORKS ALSO FOR '(SS,I0)' TO '(SS,I5)'. IF WNEW > 999, SET IT TO 999
    CHARACTER(*), INTENT(INOUT) :: FMT
    INTEGER, INTENT(IN) :: WNEW
    INTEGER :: K0, K1, K2, K3
    CHARACTER(3) RW
    K1 = VERIFY(FMT(2:), '0123456789') + 1
    K2 = VERIFY(FMT(K1:), 'ABDEFGILNOPSZABDEFGILNOPSZ,') + K1 - 1
    IF (K2 == K1) RETURN ! NO LETTER
    IF (FMT(K2-1:K2-1)==',') THEN ! HANDLE (SS,1PF10.3)
      K0 = K2
      K1 = VERIFY(FMT(K0:),'0123456789') + 1
      IF (K1==0) RETURN
      K2 = VERIFY(FMT(K1:),'ABDEFGILNOPSZABDEFGILNOPSZ,') + K1 - 1
      IF (K2 <= K1) RETURN
    END IF
    K3 = VERIFY(FMT(K2:), '0123456789') + K2 - 1
    IF (K3 == K2) RETURN ! NO DIGITS
    WRITE(RW, '(SS,I0)') MIN(999,WNEW)
    FMT = FMT(1:K2-1) // TRIM(RW) // FMT(K3:)
  END SUBROUTINE REPLACE_W

  SUBROUTINE GET_SE(SE, TITLE, SHAPEX, FMT, ADVANCE, LBOUND, SEPERATOR, STYLE, TRIM, UNIT, ORIENT, ZEROAS, DIGMAX)
    ! GET THE SETTINGS FROM THE OPTIONAL PARAMETERS FMT...ZEROAS IN TO THE STRUCTURE SE.
    ! REPLACE ABSENT ARGUMENTS WITH CORRESPONDING VALUES FROM THE STRUCTURE DEFSET.
    TYPE(SETTINGS), INTENT(OUT)          :: SE
    CHARACTER(*),   INTENT(IN)           :: TITLE
    INTEGER,        INTENT(IN)           :: SHAPEX(:)
    CHARACTER(*),   INTENT(IN), OPTIONAL :: FMT
    INTEGER,        INTENT(IN), OPTIONAL :: UNIT, DIGMAX, LBOUND(:)
    CHARACTER(*),   INTENT(IN), OPTIONAL :: ADVANCE, SEPERATOR, STYLE, ZEROAS, TRIM, ORIENT
    LOGICAL OK
    !
    CHARACTER(22) ED
    CHARACTER(9) SEP, TSTY, ZAS
    CHARACTER(1) TCH
    CHARACTER(6) ADVCHR
    INTEGER LUN, DMX, W, D, LSEP, LZAS, M1, N1, ADV
    LOGICAL TRM, NUMBER, VEC, ROW, IS_SCALAR, GEDIT
    !
    VEC = (SIZE(SHAPEX) == 1)
    IS_SCALAR = SIZE(SHAPEX) == 0
    IF (VEC .AND. PRESENT(ORIENT)) THEN
      SELECT CASE(UPPER(ORIENT))
      CASE('ROW');  ROW = .TRUE.
      CASE('COL');  ROW = .FALSE.
      CASE DEFAULT;
        CALL DISP_ERRMSG('DISP: ERROR, WRONG VALUE OF ORIENT: '//ORIENT(1:LEN_TRIM(ORIENT))//', USING "COL"')
        ROW = .FALSE.
      END SELECT
    ELSEIF (VEC) THEN
      ROW = DEFSET % ORIENT == 'ROW'
    ELSE
      ROW = .FALSE.
    ENDIF
    IF (PRESENT(FMT)) THEN
      CALL READFMT(FMT, ED, W, D, GEDIT)
    ELSE
      ED = '()'
      W = -1; D = 0; GEDIT = .FALSE.
    ENDIF
    IF (PRESENT(UNIT)) THEN
      LUN = UNIT
    ELSE
      LUN = DEFSET % UNIT
    ENDIF
    IF (.NOT.PRESENT(DIGMAX)) THEN
      DMX = DEFSET % DIGMAX
    ELSEIF (PRESENT(FMT)) THEN
      CALL DISP_ERRMSG('DISP: ERROR, BOTH FMT AND DIGMAX PRESENT, IGNORING DIGMAX')
      DMX = 1
    ELSEIF (DIGMAX < 1 .OR. DIGMAX > 89) THEN
      CALL DISP_ERRMSG('DISP: ERROR, DIGMAX MUST BE >= 1 AND < 90, USING 6')
      DMX = 6
    ELSE
      DMX = DIGMAX
    ENDIF
    IF (PRESENT(ADVANCE)) THEN
      ADVCHR = UPPER(ADVANCE)
    ELSE
      ADVCHR = DEFSET % ADVANCE
    ENDIF
    SELECT CASE(TRIMS(ADVCHR))
    CASE('NO');     ADV = 0
    CASE('YES');    ADV = 1
    CASE('DOUBLE'); ADV = 2
    CASE DEFAULT
      CALL DISP_ERRMSG('DISP: ERROR, ILLEGAL ADVANCE: ' // TRIMS(ADVANCE) // ', USING "YES"')
      ADV = 1
    END SELECT
    IF (PRESENT(TRIM)) THEN
      IF (UPPER(TRIM) /= 'YES' .AND. UPPER(TRIM) /= 'NO' .AND. UPPER(TRIM) /= 'AUTO') THEN
        CALL DISP_ERRMSG('DISP: ERROR, ILLEGAL TRIM: ' // TRIMS(TRIM) // ', USING "YES"')
        TRM = .TRUE.
      ELSE
        TRM = UPPER(TRIM) == 'YES' .OR. UPPER(TRIM) == 'AUTO' .AND. .NOT.PRESENT(FMT)
      ENDIF
    ELSEIF (W == 0) THEN
      TRM = .TRUE.
    ELSE
      TRM = DEFSET % TRIM == 'YES' .OR. DEFSET % TRIM == 'AUTO' .AND. .NOT.PRESENT(FMT)
    ENDIF
    IF (PRESENT(SEPERATOR)) THEN
      SEP = SEPERATOR
      LSEP = LEN(SEPERATOR)
    ELSE
      SEP = DEFSET % SEP
      LSEP = DEFSET % SEPLEN
    ENDIF
    IF (PRESENT(STYLE)) THEN
      CALL GETSTYLES(STYLE, TSTY, TCH, NUMBER, OK)
      IF (.NOT. OK) CALL DISP_ERRMSG('DISP: ERROR, ILLEGAL STYLE: '//STYLE//'. USING DEFAULT INSTEAD')
    ELSE
      CALL GETSTYLES(DEFSET % STYLE, TSTY, TCH, NUMBER, OK)
    ENDIF
    IF (TITLE == '') TSTY = 'LEFT'
    IF (IS_SCALAR) NUMBER = .FALSE.
    IF (PRESENT(ZEROAS)) THEN
      ZAS = ZEROAS
      LZAS = LEN(ZEROAS)
    ELSE
      ZAS = DEFSET % ZEROAS
      LZAS = DEFSET % ZASLEN
    ENDIF
    IF (W > 0) LZAS = MIN(W, LZAS)
    ZAS = ZAS(1:LZAS)
    M1 = 1
    N1 = 1
    IF (PRESENT(LBOUND)) THEN
      NUMBER = .TRUE.
      IF (SIZE(LBOUND) == 1) THEN
        IF (VEC .AND. ROW) THEN
          N1 = LBOUND(1)
        ELSE
          M1 = LBOUND(1)
        ENDIF
      ELSEIF (SIZE(LBOUND) >= 2) THEN
        M1 = LBOUND(1)
        N1 = LBOUND(2)
      ENDIF
    ENDIF
    SE = SETTINGS(ED, SEP, TSTY, ZAS, TCH, LUN, DMX, W, D, LSEP, LZAS, M1, N1, ADV, TRM, NUMBER, VEC, ROW, GEDIT)
  CONTAINS
    FUNCTION TRIMS(S) RESULT(T)
      CHARACTER(*), INTENT(IN) :: S
      CHARACTER(LEN_TRIM(S)) :: T
      INTRINSIC TRIM
      T = TRIM(S)
    END FUNCTION TRIMS
  END SUBROUTINE GET_SE

  SUBROUTINE GETSTYLES(STYLE, TSTY, TCH, NUMBER, OK)
    ! RETURN TSTY = 'LEFT', 'PAD', OR 'UNDERLINE', TCH = X FROM XPAD OR XUNDERLINE, NUMBER = .TRUE. IF STYLE INCLUDES
    ! NUMBER. IF STYLE HAS ABOVE, RETURN TSTY = 'PAD' AND TCH = ' '. RETURN TSTY = 'LEFT' IF ERROR. SEE NOTE 1 BELOW.
    CHARACTER(*), INTENT(IN) :: STYLE
    CHARACTER(9), INTENT(OUT) :: TSTY
    CHARACTER(1), INTENT(OUT) :: TCH
    LOGICAL,      INTENT(OUT) :: NUMBER, OK
    INTEGER KAMP, I, NSTY
    CHARACTER(LEN(STYLE))   :: STY(2)
    CHARACTER(9), PARAMETER :: LPUA(4) = (/'LEFT     ', 'PAD      ', 'UNDERLINE', 'ABOVE    '/)
    CHARACTER(9), PARAMETER :: PU(2) = (/'PAD      ', 'UNDERLINE'/)
    KAMP = SCAN(UPPER(STYLE), '&')
    OK = .TRUE.
    IF (KAMP > 0) THEN
      STY(1) = ADJUSTL(UPPER(STYLE(1:KAMP-1)))
      STY(2) = ADJUSTL(UPPER(STYLE(KAMP+1:)))
      NSTY = 2
    ELSE
      STY(1) = ADJUSTL(UPPER(STYLE))
      NSTY = 1
    END IF
    NUMBER = .FALSE.
    TSTY = 'LEFT'
    TCH = '-'
    DO I = 1, NSTY
      IF (STY(I) == 'NUMBER') THEN
        NUMBER = .TRUE.
      ELSEIF (STY(I) == 'ABOVE') THEN
        TSTY = 'PAD'
        TCH = ' '
      ELSEIF (ANY(STY(I) == LPUA)) THEN
        TSTY = STY(I)
      ELSEIF (ANY(STY(I)(2:) == PU)) THEN
        TSTY = STY(I)(2:)
        TCH = STY(I)(1:1)
      ELSE
        OK = .FALSE.
        RETURN
      ENDIF
    ENDDO
    OK = .TRUE.
  END SUBROUTINE GETSTYLES

  SUBROUTINE REPLACE_ZERONANINF(S, ZAS, MASKZ, MASKNAN, MASKMINF, MASKINF)
    ! REPLACE ZEROS IN S (WHERE MASKZ IS TRUE) WITH ZAS (I.E. ZERO-AS STRING) ALSO REPLACE NANS WITH 'NAN',
    ! INFINITIES WITH '+INF' AND MINUS INFINITIES WITH '-INF'. ZEROS ARE ALIGNED WITH . IF ZAS CONTAINS .
    ! OTHERWISE RIGHT-ADJUSTED. NANS, AND INFS ARE RIGHT ADJUSTED.
    ! NOTE: THERE ARE COMPILER BUGS IN CURRENT VERSIONS OF BOTH THE ABSOFT AND THE PATHSCALE COMPILERS
    ! SO THE MERGE CALLS (COMMENTED OUT BELOW) HAD TO BE REPLACED WITH DO LOOPS.
    CHARACTER(*), INTENT(INOUT) :: S(:)
    LOGICAL     , INTENT(IN)    :: MASKZ(:), MASKNAN(:), MASKINF(:), MASKMINF(:)
    CHARACTER(*), INTENT(IN)    :: ZAS
    OPTIONAL                    :: MASKNAN, MASKMINF, MASKINF
    CHARACTER(LEN(S)) Z, NAN, MINF, INF
    INTEGER W, WZ, N, I, K, ZASDOT
    W = LEN(S)
    WZ = LEN(ZAS)
    N = SIZE(MASKZ)
    IF (WZ /= 0 .AND. WZ <= W) THEN ! ZAS NOT EMPTY AND NOT TOO WIDE
      ZASDOT = INDEX(ZAS, '.')
      Z = ''
      IF (ZASDOT > 0) THEN
        DO I=1,N
          IF (MASKZ(I)) EXIT
        ENDDO
        IF (I<=N) THEN ! SOME ZEROS
          K = INDEX(S(I), '.')
          IF (K == 0 .OR. ZASDOT > K .OR. WZ-ZASDOT > W-K) THEN ! CANNOT ALIGN .'S
            Z(W-WZ+1:) = ZAS ! ALIGN RIGHT
          ELSE
            Z(K-ZASDOT+1:K-ZASDOT+WZ) = ZAS
          ENDIF
        ENDIF
      ELSE
        Z(W-WZ+1:) = ZAS
      END IF
      ! S = MERGE(Z, S, MASKZ)
      DO I=1,N
        IF (MASKZ(I)) S(I) = Z
      ENDDO
    ENDIF
    IF (PRESENT(MASKNAN)) THEN
      IF (W >= 4) THEN
        NAN = REPEAT(' ', W-4) // ' NAN'
        MINF = REPEAT(' ', W-4) // '-INF'
        INF = REPEAT(' ', W-4) // '+INF'
      ELSEIF (W == 3) THEN
        NAN = 'NAN'
        MINF = '***'
        INF = 'INF'
      ELSE
        NAN = REPEAT('*',W)
        MINF = NAN
        INF = NAN
      ENDIF
      ! S = MERGE(NAN, S, MASKNAN)
      ! S = MERGE(MINF, S, MASKMINF)
      ! S = MERGE(INF, S, MASKINF)
      DO I=1,N
        IF (MASKNAN(I)) S(I) = NAN
        IF (MASKMINF(I)) S(I) = MINF
        IF (MASKINF(I)) S(I) = INF
      ENDDO
    ENDIF
  END SUBROUTINE REPLACE_ZERONANINF

  PURE FUNCTION UPPER(S) RESULT(SU) ! CHANGE STRING TO UPPER CASE
    CHARACTER(*), INTENT(IN) :: S
    CHARACTER(LEN(S)) SU
    CHARACTER(26), PARAMETER :: LL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', &
         UL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    INTEGER I, K
    SU = S
    DO I = 1,LEN(S)
      K = INDEX(LL, S(I:I))
      IF (K > 0) SU(I:I) = UL(K:K)
    END DO
  END FUNCTION UPPER

  PURE SUBROUTINE SSZIPFMT(FMT, FMT1)
    ! SET FMT1 TO '(SS,'//REMOVEBLANKS(FMT)//')'. CALLER IS RESPONSIBLE THAT
    ! FMT1 HAS SUFFICIENT LENGTH.
    CHARACTER(*), INTENT(IN) :: FMT
    CHARACTER(*), INTENT(OUT) :: FMT1
    INTEGER I,J
    FMT1 = '(SS,'
    J = 5
    DO I = 1,LEN(FMT)
      IF (FMT(I:I) /= ' ') THEN
        FMT1(J:J) = FMT(I:I)
        J = J+1
      ENDIF
    ENDDO
    FMT1(J:J) = ')'
  END SUBROUTINE SSZIPFMT

  PURE FUNCTION NNBLK(S) RESULT(N) ! COUNT NONBLANKS IN S
    CHARACTER(*), INTENT(IN) :: S
    INTEGER I, N
    N = 0
    DO I = 1,LEN(S)
      IF (S(I:I) /= ' ') N = N+1
    ENDDO
  END FUNCTION NNBLK

  SUBROUTINE DISP_ERRMSG(S)
    CHARACTER(*), INTENT(IN) :: S
    INTEGER WLEFT
    CHARACTER(1), POINTER :: BOXP(:,:)
    WLEFT = 0
    CALL NEWBOX(DEFAULT_UNIT, 1, LEN(S), BOXP)
    CALL COPYTOBOX((/S/), LIN1 = 1, WIDJ = LEN(S), WIDPJ = LEN(S), NBLJ = 0, BOXP = BOXP, WLEFT = WLEFT)
    CALL DISPBOXLIST(DEFAULT_UNIT, SEP = '')
  END SUBROUTINE DISP_ERRMSG
  ! *********************************** END OF GENERAL PROCEDURES *********************************

  ! ************************************* TOSTRING PROCEDURES *************************************
  SUBROUTINE TOSTRING_CHECK_SETTINGS
    ! SANITY CHECK OF TOSTRING SETTINGS
    TYPE(TOSTRING_SETTINGS) TS
    INTEGER WI, WR, D
    CHARACTER(MAX(LEN(TOSSET % RFMT), LEN(TOSSET % IFMT)) + 5) FMT1
    LOGICAL GEDIT
    TS = TOSSET
    IF (ALL(TS % TRIMB /= (/'YES', 'NO '/)))           TOSSET % TRIMB = TOSFAC % TRIMB
    IF (ALL(TS % TRIMZ /= (/'NONE', 'ALL ', 'G   '/))) TOSSET % TRIMZ = TOSFAC % TRIMZ
    CALL READFMT(TOSSET % RFMT, FMT1, WR, D, GEDIT)
    CALL READFMT(TOSSET % IFMT, FMT1, WI, D, GEDIT)
    IF (WR < 0) TOSSET % RFMT = TOSFAC % RFMT
    IF (WI < 0) TOSSET % IFMT = TOSFAC % IFMT
    IF (ALL(TS % TRIMB /= (/'YES ', 'NO  ', 'AUTO'/))) CALL DISP_ERRMSG( &
         'TOSTRING_SET: ERROR, ILLEGAL TRIMB: '//TRIM(TS % TRIMB)//', SET TO ' // TRIM(TOSFAC % TRIMB))
    IF (ALL(TS % TRIMZ /= (/'NONE', 'ALL ', 'G   '/))) CALL DISP_ERRMSG( &
         'TOSTRING_SET: ERROR, ILLEGAL TRIMZ: '//TRIM(TS % TRIMZ)//', SET TO '//TRIM(TOSFAC % TRIMZ))
    IF (WR < 0) CALL DISP_ERRMSG( &
         'TOSTRING_SET: ERROR, ILLEGAL RFMT: '//TRIM(TS % RFMT)//', SET TO '//TRIM(TOSFAC % RFMT))
    IF (WI < 0) CALL DISP_ERRMSG( &
         'TOSTRING_SET: ERROR, ILLEGAL IFMT: '//TRIM(TS % IFMT)//', SET TO '//TRIM(TOSFAC % IFMT))
  END SUBROUTINE TOSTRING_CHECK_SETTINGS

  PURE SUBROUTINE TRIM_S_REAL(SA, GEDIT, W)
    ! TRIM TRAILING ZEROS AND POSSIBLY DECIMAL POINT FROM FRACTIONAL PART.
    ! IF SA = '52.2000E12' ON ENTRY THEN IT IS RETURNED AS '52.2E12   '.
    ! WHETHER TRIMMING IS ACTUALLY DONE DEPENDS ON TOSSET, GEDIT AND W.
    CHARACTER(*), INTENT(INOUT) :: SA
    LOGICAL, INTENT(IN) :: GEDIT
    INTEGER, INTENT(IN) :: W
    INTEGER K, K2, K3
    IF (TOSSET % TRIMB == 'YES' .OR. W == 0) SA = ADJUSTL(SA)
    IF (TOSSET % TRIMZ == 'ALL' .OR. TOSSET % TRIMZ == 'G' .AND. GEDIT) THEN
      K = SCAN(SA, '.')
      IF (K > 0) THEN
        K2 = VERIFY(SA(K+1:), '0123456789') + K
        IF (K2 == K) K2 = LEN(SA) + 1
        K3 = VERIFY(SA(K:K2-1), '0.', BACK=.TRUE.) + K - 1
        SA(K3+1:) = SA(K2:)
      ENDIF
    ENDIF
  END SUBROUTINE TRIM_S_REAL

  PURE SUBROUTINE TRIM_REAL(SA, GEDIT, W)
    ! TRIM TRAILING ZEROS AND POSSIBLY DECIMAL POINT FROM FRACTIONAL PART.
    ! IF SA = '52.2000E12' ON ENTRY THEN IT IS RETURNED AS '52.2E12   '.
    ! WHETHER TRIMMING IS ACTUALLY DONE DEPENDS ON TOSSET, GEDIT AND W.
    CHARACTER(*), INTENT(INOUT) :: SA(:)
    LOGICAL, INTENT(IN) :: GEDIT
    INTEGER, INTENT(IN) :: W
    INTEGER I
    IF (TOSSET % TRIMB == 'YES' .OR. W == 0) SA = ADJUSTL(SA)
    IF (TOSSET % TRIMZ == 'ALL' .OR. TOSSET % TRIMZ == 'G' .AND. GEDIT) THEN
      DO I=1,SIZE(SA) ! TRIM TRAILING ZEROS FROM FRACTIONAL PART
        CALL TRIM_S_REAL(SA(I), GEDIT, W)
      ENDDO
    ENDIF
  END SUBROUTINE TRIM_REAL

  PURE SUBROUTINE TOSTRING_GET(SA, ST)
    ! COPY TRIMMED ELEMENTS OF SA (CONTAINING INDIVIDUAL ELEMENTS AS STRINGS) TO THE FINAL
    ! TOSTRING RESULT ST, SEPARATED BY TOSSET % SEP STRINGS.
    CHARACTER(*), INTENT(IN)  :: SA(:)
    CHARACTER(*), INTENT(OUT) :: ST
    INTEGER                   :: I, K, N, SEPL
    SEPL = TOSSET % SEPLEN
    K = 0
    DO I = 1,SIZE(SA)
      IF (K>0) ST(K+1:K+SEPL) = TOSSET % SEP(1:SEPL)
      IF (K>0) K = K + SEPL
      N = LEN_TRIM(SA(I))
      ST(K+1:K+N) = TRIM(SA(I))
      K = K + N
    END DO
  END SUBROUTINE TOSTRING_GET

  PURE SUBROUTINE TOSTRING_GET_COMPLEX(SAR, SGN, SAI, ST)
    ! VERSION OF TOSTRING_GET FOR COMPLEX NUMBERS
    CHARACTER(*), INTENT(IN)  :: SAR(:), SAI(:), SGN(*)
    CHARACTER(*), INTENT(OUT) :: ST
    INTEGER                   :: I, K, N, SEPL
    SEPL = TOSSET % SEPLEN
    K = 0
    DO I = 1,SIZE(SAR)
      IF (K>0) ST(K+1:K+SEPL) = TOSSET % SEP(1:SEPL)
      IF (K>0) K = K + SEPL
      N = LEN_TRIM(SAR(I))
      ST(K+1:K+N) = TRIM(SAR(I))
      ST(K+N+1:K+N+3) = ' '//SGN(I)//' '
      K = K + N + 3
      N = LEN_TRIM(SAI(I))
      ST(K+1:K+N) = TRIM(SAI(I))
      ST(K+N+1:K+N+1) = 'I'
      K = K + N + 1
    END DO
  END SUBROUTINE TOSTRING_GET_COMPLEX

  ! ********************************* END OF TOSTRING PROCEDURES *********************************

  ! *********************************** BOX-PACKAGE **********************************************
  !
  ! A "BOX" IS A VARIABLE DIMENSION CHARACTER MATRIX THAT CAN BE CREATED DYNAMICALLY. THERE ARE
  ! LINKED LISTS OF BOXES, ONE FOR EACH LOGICAL UNIT. WHEN DISP IS CALLED THE ITEM TO BE DISPLAYED
  ! IS WRITTEN TO A BOX. IF ADVANCE = 'NO' IS IN EFFECT, THE WRITING OUT OF THE ITEMS IS DELAYED
  ! UNTIL DISP IS CALLED ON THE SAME UNIT WITH ADVANCE = 'YES' IN EFFECT; THEN ALL THE BOXES IN
  ! THE RELEVANT LIST ARE WRITTEN TO THE UNIT. THERE ARE TWO SUBROUTINES THAT ARE MEANT TO BE
  ! CALLED FROM OUTSIDE THE BOX-PACKAGE: NEWBOX AND DISPBOXLIST:
  !
  ! CALL NEWBOX(UNIT, M, N, BOXP) CREATES A BOX ON UNIT UNIT. BOXP RETURNS A POINTER TO THE
  ! CREATED BOX WHICH IS OF TYPE CHARACTER AND DIMENSION (M,N).
  !
  ! CALL DISPBOXLIST(UNIT, SEP) WRITES ALL THE BOXES IN THE LIST ASSOCIATED WITH UNIT TO THE FILE
  ! ON UNIT, SEPARATED WITH THE STRING SEP. THE FOLLOWING EXAMPLE MAKES THIS CLEAR: LET SEP = ' : '
  ! AND LET THE FIRST BOX CONTAIN XXX AND THE SECOND HAVE TWO ROWS, BOTH EQUAL TO YYYY. THEN THE
  ! TEXT WRITTEN WILL BE: XXX : YYYY : YYYY
  !
  ! TO OBTAIN TAB-SEPARATED BOXES WHEN USING ASCII, LET SEP = CHAR(9). AFTER WRITING THE BOXES,
  ! THE COMPLETE LIST IS DEALLOCATED. IF UNIT = -3 THE ASTERISK UNIT (USUALLY COMMAND WINDOW) IS
  ! WRITTEN TO. IF UNIT = -2 THE ROUTINE PUTSTR FROM THE DISP_WHERE UNIT IS USED FOR WRITING. IF
  ! UNIT = -1 ALL OUTPUT WILL BE DISCARDED. WITH THE ISO_FORTRAN_ENV MODULE OF FORTRAN 2003, UNIT
  ! MAY ALSO EQUAL OUTPUT_UNIT, UNLESS THE COMPILER SETS THAT TO -2.

  FUNCTION GETBOXLIST(UNIT) RESULT(P)
    ! RETURN BOXLIST ASSOCIATED WITH SPECIFIED UNIT. IF THIS LIST DOES NOT EXIST A NEW LIST IS STARTED.
    INTEGER, INTENT(IN) :: UNIT
    TYPE(BOXLIST), POINTER :: P
    P => FIRSTBOXLIST
    DO WHILE(ASSOCIATED(P))
      IF (P % UNIT == UNIT) RETURN
      P => P % NEXTBOXLIST
    END DO
    ALLOCATE(P)
    P % NEXTBOXLIST => FIRSTBOXLIST  ! PUT AT HEAD OF LIST
    P % UNIT = UNIT
    FIRSTBOXLIST => P
  END FUNCTION GETBOXLIST

  SUBROUTINE CLEARBOXLIST(UNIT)
    ! DEALLOCATE ALL BOXES ASSOCIATED WITH UNIT
    INTEGER, INTENT(IN) :: UNIT
    TYPE(BOXNODE), POINTER :: P, Q
    TYPE(BOXLIST), POINTER :: BLP
    BLP => FIRSTBOXLIST
    DO WHILE(ASSOCIATED(BLP))
      IF (BLP % UNIT == UNIT) EXIT
      BLP => BLP % NEXTBOXLIST
    END DO
    IF (.NOT. ASSOCIATED(BLP)) RETURN
    P => BLP % FIRSTBOX
    DO WHILE(ASSOCIATED(P))
      Q => P
      P => P % NEXTBOX
      DEALLOCATE(Q % BOX)
      DEALLOCATE(Q)
    ENDDO
    IF (ASSOCIATED(FIRSTBOXLIST, BLP)) THEN
      FIRSTBOXLIST => BLP % NEXTBOXLIST
    ENDIF
    DEALLOCATE(BLP)
  END SUBROUTINE CLEARBOXLIST

  SUBROUTINE NEWBOX(UNIT, M, N, BOXP)
    ! CREATE A NEW BOX
    CHARACTER, POINTER :: BOXP(:,:)
    INTEGER, INTENT(IN) :: UNIT, M, N
    TYPE(BOXNODE), POINTER :: P
    TYPE(BOXLIST), POINTER :: BLP
    ALLOCATE(P)
    ALLOCATE(P % BOX(N, M))
    BLP => GETBOXLIST(UNIT)
    IF (.NOT.ASSOCIATED(BLP % FIRSTBOX)) THEN
      BLP % FIRSTBOX => P
    ELSE
      BLP % LASTBOX % NEXTBOX => P
    END IF
    BLP % LASTBOX => P
    BOXP => P % BOX
    BOXP = ' '
  END SUBROUTINE NEWBOX

  FUNCTION TOSTR(A) RESULT(S)
    ! COPY CHAR ARRAY TO STRING
    CHARACTER, INTENT(IN) :: A(:)
    CHARACTER(SIZE(A)) S
    INTEGER I
    DO I=1,SIZE(A)
      S(I:I) = A(I)
    ENDDO
  END FUNCTION TOSTR

  SUBROUTINE DISPBOXLIST(UNIT, SEP)
    ! DISPLAY THE LIST OF BOXES ASSOCIATED WITH UNIT
    INTEGER, INTENT(IN) :: UNIT
    TYPE(BOXNODE), POINTER :: PFIRST, P
    TYPE(BOXLIST), POINTER :: BLP
    INTEGER K, NLINES, H, W, NS
    CHARACTER(*), INTENT(IN) :: SEP
    BLP => GETBOXLIST(UNIT)
    PFIRST => BLP % FIRSTBOX
    NLINES = 0
    P => PFIRST
    DO WHILE (ASSOCIATED(P))
      NLINES = MAX(NLINES, SIZE(P % BOX, 2))
      P => P % NEXTBOX
    ENDDO
    DO K=1,NLINES
      P => PFIRST
      NS = 0
      DO WHILE (ASSOCIATED(P))
        H = SIZE(P % BOX, 2)
        W = SIZE(P % BOX, 1)
        IF (K <= H) THEN
          SELECT CASE(UNIT)
          CASE(-1)
            CONTINUE
          CASE(-2)
            CALL PUTSTR(SEP(1:NS) // TOSTR(P % BOX(:,K)))
          CASE(-3)
            WRITE(*,    '(2A)', ADVANCE = 'NO') SEP(1:NS), TOSTR(P % BOX(:,K))
          CASE DEFAULT
            WRITE(UNIT, '(2A)', ADVANCE = 'NO') SEP(1:NS), TOSTR(P % BOX(:,K))
          END SELECT
        ELSE
          SELECT CASE(UNIT)
          CASE(-1)
            CONTINUE
          CASE(-2)
            CALL PUTSTR(SEP(1:NS) // REPEAT(' ', W))
          CASE(-3)
            WRITE(*,    '(2A)', ADVANCE = 'NO') SEP(1:NS), REPEAT(' ', W)
          CASE DEFAULT
            WRITE(UNIT, '(2A)', ADVANCE = 'NO') SEP(1:NS), REPEAT(' ', W)
          END SELECT
        END IF
        P => P % NEXTBOX
        NS = LEN(SEP)
      ENDDO
      CALL DISPNEWLINE(UNIT)
    ENDDO
    CALL CLEARBOXLIST(UNIT)
  END SUBROUTINE DISPBOXLIST

  SUBROUTINE DISPNEWLINE(UNIT)
    INTEGER, INTENT(IN) :: UNIT
    SELECT CASE(UNIT)
    CASE(-1); CONTINUE
    CASE(-2); CALL PUTNL
    CASE(-3); WRITE(*,*)
    CASE DEFAULT; WRITE(UNIT,*)
    END SELECT
  END SUBROUTINE DISPNEWLINE

  !   SUBROUTINE PRINT_BOXES
  !     ! PRINT INFO ON ALL BOXES (USED FOR DEBUG PURPOSES)
  !     INTEGER :: K
  !     TYPE(BOXLIST), POINTER :: BL
  !     TYPE(BOXNODE), POINTER :: P
  !     BL => FIRSTBOXLIST
  !     WRITE(*,'("BOXES:")')
  !     DO WHILE (ASSOCIATED(BL))
  !       WRITE(*,'("UNIT=",SS,I0,":")') BL % UNIT
  !       P => BL % FIRSTBOX
  !       K = 1
  !       DO WHILE(ASSOCIATED(P))
  !         WRITE(*,'("  BOX ",SS,I0,", SIZE=(",I0,",",I0,")")') K, SHAPE(P % BOX)
  !         K = K+1
  !         P => P % NEXTBOX
  !       ENDDO
  !       BL => BL % NEXTBOXLIST
  !     ENDDO
  !   END SUBROUTINE PRINT_BOXES

  ! ******************************** END OF BOX-PACKAGE *******************************

  ! THE FOLLOWING ROUTINES ARE DUMMY VERSIONS OF THE SUBROUTINES PUTSTR AND PUTNL
  !     THAT DO NOTHING. IT IS NEEDED TO AVOID AN "UNDEFINED SYMBOL" LINK ERROR
  !     FOR THESE.
  ! THE PURPOSE OF HAVING THESE ROUTINES IS TO MAKE DISPLAYING POSSIBLE IN SITUATIONS
  !     WHERE ORDINARY PRINT- AND WRITE-STATEMENTS DO NOT WORK. THEN THEY SHOULD BE
  !     REPLACED BY ONE DEFINING FUNCTIONAL VERSIONS OF PUTSTR AND PUTNL.
  !
  SUBROUTINE PUTSTR(S)
    CHARACTER(*), INTENT(IN) :: S
    INTEGER LDUMMY, LDUMMY1  ! THESE VARIABLES EXIST TO AVOID UNUSED VARIABLE WARNINGS
    LDUMMY = LEN(S)
    LDUMMY1 = LDUMMY
    LDUMMY = LDUMMY1
  END SUBROUTINE PUTSTR
  !
  SUBROUTINE PUTNL()
  END SUBROUTINE PUTNL
  !
END MODULE ModLib_Display_Auxiliary

!******************************************************************************
