<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="XpfLib - General Package Documentation">
    <meta name="author" content="Niranama" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; XpfGeneral
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha256-tG5mcZUtJsZvyKAxYLVXrmjKBVLd6VpVccqz/r4ypFE=" crossorigin="anonymous"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">XpfGeneral </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr><td><a href='../proc/abortprogram.html'>AbortProgram</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>This subroutine causes the program to halt due to a fatal error.</p></td></tr>
			   <tr><td><a href='../interface/abs.html'>ABS</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ABS <br>
 <strong>Purpose</strong>:  To return the absolute value of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    AbsNum = ABS(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/abs~2.html'>ABS</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ABS <br>
 <strong>Purpose</strong>:  To return the absolute value of the input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = ABS(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/abs~3.html'>ABS</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ABS <br>
 <strong>Purpose</strong>:  To return the absolute value of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    AbsNum = ABS(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/achar.html'>ACHAR</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ACHAR <br>
 <strong>Purpose</strong>:  To return a FvlStr object with length of 1 representing the
      character in the specified position of the ASCII character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Chr = ACHAR(I) <br></p></td></tr>
			   <tr><td><a href='../interface/add.html'>Add</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Add <br>
 <strong>Purpose</strong>:  To perform addition: This = This + Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Add(This, Other)</p></td></tr>
			   <tr><td><a href='../interface/add~2.html'>Add</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Add <br>
 <strong>Purpose</strong>:  To perform addition: This = This + Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Add(This, Other)</p></td></tr>
			   <tr><td><a href='../proc/addu64.html'>AddU64</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To return the sum with carry of X, Y and CarryIn: Sum = X + Y + CarryIn.
 The carry input must be 0 or 1; otherwise the behavior is undefined.
 The carry output is guaranteed to be 0 or 1.</p></td></tr>
			   <tr><td><a href='../interface/addxp~2.html'>AddXp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/addxp.html'>AddXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: AddXp <br>
 <strong>Purpose</strong>:  To perform an addition: OutVal = LhsVal + RhsVal. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutVal = AddXp(LhsVal, RhsVal, Algorithm) <br>
 <strong>Note</strong>: Algorithm must be between 1 and 3.</p></td></tr>
			   <tr><td><a href='../interface/adjustl.html'>ADJUSTL</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ADJUSTL <br>
 <strong>Purpose</strong>:  To adjust the string of FvlStr object to the left, removing
      leading blanks and inserting trailing blanks. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = ADJUSTL(vStrIn) <br></p></td></tr>
			   <tr><td><a href='../interface/adjustr.html'>ADJUSTR</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ADJUSTR <br>
 <strong>Purpose</strong>:  To adjust the string of FvlStr object to the right, removing
      trailing blanks and inserting leading blanks. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = ADJUSTR(vStrIn) <br></p></td></tr>
			   <tr><td><a href='../interface/americanflagsort.html'>AmericanFlagSort</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: AmericanFlagSort <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the
      American-flag algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL AmericanFlagSort(Arr) <br></p></td></tr>
			   <tr><td><a href='../proc/anytype_2_bytearray.html'>AnyType_2_ByteArray</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Subroutine</td><td><p>To convert the given input to an array of 8-bit integers where the input
 can be any type and its size (in bytes) must be known.</p></td></tr>
			   <tr><td><a href='../proc/anytype_2_bytearrptr.html'>AnyType_2_ByteArrPtr</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Subroutine</td><td><p>To convert the given input to a pointer array of 8-bit integers where the input
 can be any type and its size (in bytes) must be known.</p></td></tr>
			   <tr><td><a href='../interface/apint32.html'>ApInt32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Constructor Interface</strong>: ApInt32 <br>
 <strong>Purpose</strong>:  To construct an ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ! construct ApNum from a magnitude array <br>
  ---&gt;    ApNum = ApInt32(Sign, MagLen, MagArray) <br>
  ! construct ApNum from 64-bit intrinsic integer treated as signed <br>
  ---&gt;    ApNum = ApInt32(I64) <br>
  ! construct ApNum from 32-bit intrinsic integer treated as unsigned <br>
  ---&gt;    ApNum = ApInt32(Sign, U32) <br>
  ! construct ApNum from 128-bit real number <br>
  ---&gt;    ApNum = ApInt32(R128) <br>
  ! construct ApNum from a decimal string <br>
  ---&gt;    ApNum = ApInt32('-123456789098765432101122334455667788990012345')</p></td></tr>
			   <tr><td><a href='../interface/apint64.html'>ApInt64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Constructor Interface</strong>: ApInt64 <br>
 <strong>Purpose</strong>:  To construct an ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ! construct ApNum from a magnitude array <br>
  ---&gt;    ApNum = ApInt64(Sign, MagLen, MagArray) <br>
  ! construct ApNum from 64-bit intrinsic integer treated as signed <br>
  ---&gt;    ApNum = ApInt64(I64) <br>
  ! construct ApNum from 32-bit intrinsic integer treated as unsigned <br>
  ---&gt;    ApNum = ApInt64(Sign, U32) <br>
  ! construct ApNum from 128-bit real number <br>
  ---&gt;    ApNum = ApInt64(R128) <br>
  ! construct ApNum from a decimal string <br>
  ---&gt;    ApNum = ApInt64('-123456789098765432101122334455667788990012345')</p></td></tr>
			   <tr><td><a href='../interface/assignment(=).html'>ASSIGNMENT(=)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between the ApInt32 type and a signed integer
      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). <br>
 <strong>Usage</strong>: <br>
  ! convert 64-bit signed integer to the ApInt32 type <br>
  ---&gt;    ApNum = I64 <br>
  ! convert the ApInt32 type to 128-bit signed integer <br>
  ---&gt;    I128 = ApNum</p></td></tr>
			   <tr><td><a href='../interface/assignment(=)~2.html'>ASSIGNMENT(=)</a></td><td><a href='../module/class_assignable.html'>Class_Assignable</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To make a copy of an array of the <em>Assignable</em> type. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    LHS = RHS</p></td></tr>
			   <tr><td><a href='../interface/assignment(=)~3.html'>ASSIGNMENT(=)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between a 128-bit signed integer and
  other signed integers (32- and 64-bit integers). <br>
 <strong>Usage</strong>: <br>
  ! convert 32-bit signed integer to 128-bit signed integer <br>
  ---&gt;    I128 = I32 <br>
  ! convert 128-bit signed integer to 64-bit signed integer <br>
  ---&gt;    I64 = I128</p></td></tr>
			   <tr><td><a href='../interface/assignment(=)~4.html'>ASSIGNMENT(=)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between a 128-bit unsigned integer and
  other unsigned integers (32- and 64-bit integers). <br>
 <strong>Usage</strong>: <br>
  ! convert 32-bit unsigned integer to 128-bit unsigned integer <br>
  ---&gt;    U128 = U32 <br>
  ! convert 128-bit unsigned integer to 64-bit unsigned integer <br>
  ---&gt;    U64 = U128</p></td></tr>
			   <tr><td><a href='../interface/assignment(=)~5.html'>ASSIGNMENT(=)</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between a character string and an other
               (Fortran intrinsic) type via an assignment expression. <br>
 <strong>Usage</strong>: <br>
  ! convert a 64-bit integer number to a character string <br>
  ---&gt;    cStr = I64Num <br>
  ! convert a character string to a quadruple-precision real number <br>
  ---&gt;    RQPNum = cStr <br>
 <strong>Important Note</strong>: The <em>assignment</em> and <em>conversion</em> operations are
           functionally similar but have some subtle differences.  In
           particular for those procedures that convert from a decimal
           string to a number, the <em>assignment</em> procedures will silently
           convert to a proper representation if the input string is
           <em>INVALID</em> whereas the <em>conversion</em> procedures can optionally
           report the error occurred. <br></p></td></tr>
			   <tr><td><a href='../interface/assignment(=)~6.html'>ASSIGNMENT(=)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between a FvlStr object and an other (Fortran
      intrinsic) type via an assignment expression. <br>
 <strong>Usage</strong>: <br>
  ! convert a 64-bit integer number to a FvlStr object <br>
  ---&gt;    vStr = I64Num <br>
  ! convert a FvlStr object to a quadruple-precision real number <br>
  ---&gt;    RQPNum = vStr <br>
 <strong>Important Note</strong>: The <em>assignment</em> and <em>conversion</em> operations are
      functionally similar but have some subtle differences.  In particular
      for those procedures that convert from a decimal string to a number,
      the <em>assignment</em> procedures will silently convert to a proper value
      (representation) if the input string is <em>INVALID</em> whereas the <em>conversion</em>
      procedures can optionally report the error occurred. <br></p><a href="../interface/assignment(=)~6.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../interface/assignment(=)~7.html'>ASSIGNMENT(=)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: ASSIGNMENT(=) <br>
 <strong>Purpose</strong>:  To convert between the ApInt64 type and a signed integer
      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). <br>
 <strong>Usage</strong>: <br>
  ! convert 64-bit signed integer to the ApInt64 type <br>
  ---&gt;    ApNum = I64 <br>
  ! convert the ApInt64 type to 128-bit signed integer <br>
  ---&gt;    I128 = ApNum</p></td></tr>
			   <tr><td><a href='../interface/blankcompresschangecase.html'>BlankCompressChangeCase</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: BlankCompressChangeCase <br>
 <strong>Purpose</strong>:  To first remove all blank characters and then change case of all
               alphabet characters of the specified character string according
               to the given flag. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = BlankCompressChangeCase(InStr, .TRUE.)</p></td></tr>
			   <tr><td><a href='../interface/btest.html'>BTEST</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: BTEST <br>
 <strong>Purpose</strong>:  To check whether the bit at the specified position
               is 0 (False) or 1 (True). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = BTEST(ApNum, Pos)</p></td></tr>
			   <tr><td><a href='../interface/btest~2.html'>BTEST</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: BTEST <br>
 <strong>Purpose</strong>:  To check whether the bit at the specified position is 0 (False) or 1 (True).
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = BTEST(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/btest~3.html'>BTEST</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: BTEST <br>
 <strong>Purpose</strong>:  To check whether the bit at the specified position is 0 (False) or 1 (True).
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = BTEST(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/btest~4.html'>BTEST</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: BTEST <br>
 <strong>Purpose</strong>:  To check whether the bit at the specified position
               is 0 (False) or 1 (True). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = BTEST(ApNum, Pos)</p></td></tr>
			   <tr><td><a href='../proc/bytearray_2_anytype.html'>ByteArray_2_AnyType</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Subroutine</td><td><p>To convert an array of 8-bit integers to the specified output.</p></td></tr>
			   <tr><td><a href='../interface/bytepack.html'>BytePack</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: BytePack <br>
 <strong>Purpose</strong>:  To convert a byte array stored in machine-endian order to an
               (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br>
 <strong>Usage</strong>: <br>
  ! convert a byte array to an integer <br>
  ---&gt;    CALL BytePack(ByteArr, IntVal) <br>
  ! convert a byte array starting at the specified offset to an integer <br>
  ---&gt;    CALL BytePack(ByteArr, Offset, IntVal) <br>
  ! convert a byte array to an integer array <br>
  ---&gt;    CALL BytePack(ByteArr, IntArr) <br>
  ! convert a byte array starting at the specified offset to an integer array <br>
  ---&gt;    CALL BytePack(ByteArr, Offset, IntArr)</p></td></tr>
			   <tr><td><a href='../interface/bytepackbe.html'>BytePackBE</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: BytePackBE <br>
 <strong>Purpose</strong>:  To convert a byte array stored in big-endian order to an
               (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br>
 <strong>Usage</strong>: <br>
  ! convert a byte array to an integer <br>
  ---&gt;    CALL BytePackBE(ByteArr, IntVal) <br>
  ! convert a byte array starting at the specified offset to an integer <br>
  ---&gt;    CALL BytePackBE(ByteArr, Offset, IntVal) <br>
  ! convert a byte array to an integer array <br>
  ---&gt;    CALL BytePackBE(ByteArr, IntArr) <br>
  ! convert a byte array starting at the specified offset to an integer array <br>
  ---&gt;    CALL BytePackBE(ByteArr, Offset, IntArr)</p></td></tr>
			   <tr><td><a href='../interface/bytepackle.html'>BytePackLE</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: BytePackLE <br>
 <strong>Purpose</strong>:  To convert a byte array stored in little-endian order to an
               (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br>
 <strong>Usage</strong>: <br>
  ! convert a byte array to an integer <br>
  ---&gt;    CALL BytePackLE(ByteArr, IntVal) <br>
  ! convert a byte array starting at the specified offset to an integer <br>
  ---&gt;    CALL BytePackLE(ByteArr, Offset, IntVal) <br>
  ! convert a byte array to an integer array <br>
  ---&gt;    CALL BytePackLE(ByteArr, IntArr) <br>
  ! convert a byte array starting at the specified offset to an integer array <br>
  ---&gt;    CALL BytePackLE(ByteArr, Offset, IntArr)</p></td></tr>
			   <tr><td><a href='../interface/byteunpack.html'>ByteUnpack</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ByteUnpack <br>
 <strong>Purpose</strong>:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array
               of integers) to a byte array stored in machine-endian order. <br>
 <strong>Usage</strong>: <br>
  ! convert an integer to a byte array <br>
  ---&gt;    CALL ByteUnpack(IntVal, ByteArr) <br>
  ! convert an integer to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpack(IntVal, ByteArr, Offset) <br>
  ! convert an integer array to a byte array <br>
  ---&gt;    CALL ByteUnpack(IntArr, ByteArr) <br>
  ! convert an integer array to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpack(IntArr, ByteArr, Offset)</p></td></tr>
			   <tr><td><a href='../interface/byteunpackbe.html'>ByteUnpackBE</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ByteUnpackBE <br>
 <strong>Purpose</strong>:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array
               of integers) to a byte array stored in big-endian order. <br>
 <strong>Usage</strong>: <br>
  ! convert an integer to a byte array <br>
  ---&gt;    CALL ByteUnpackBE(IntVal, ByteArr) <br>
  ! convert an integer to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpackBE(IntVal, ByteArr, Offset) <br>
  ! convert an integer array to a byte array <br>
  ---&gt;    CALL ByteUnpackBE(IntArr, ByteArr) <br>
  ! convert an integer array to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpackBE(IntArr, ByteArr, Offset)</p></td></tr>
			   <tr><td><a href='../interface/byteunpackle.html'>ByteUnpackLE</a></td><td><a href='../module/modbase_bytepack.html'>ModBase_BytePack</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ByteUnpackLE <br>
 <strong>Purpose</strong>:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array
               of integers) to a byte array stored in little-endian order. <br>
 <strong>Usage</strong>: <br>
  ! convert an integer to a byte array <br>
  ---&gt;    CALL ByteUnpackLE(IntVal, ByteArr) <br>
  ! convert an integer to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpackLE(IntVal, ByteArr, Offset) <br>
  ! convert an integer array to a byte array <br>
  ---&gt;    CALL ByteUnpackLE(IntArr, ByteArr) <br>
  ! convert an integer array to a byte array starting at the specified offset <br>
  ---&gt;    CALL ByteUnpackLE(IntArr, ByteArr, Offset)</p></td></tr>
			   <tr><td><a href='../proc/calculateblockcount.html'>CalculateBlockCount</a></td><td><a href='../module/class_well32rng.html'>Class_Well32RNG</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/celciustofahrenheit.html'>CelciusToFahrenheit</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert temperature from deg C to deg F</p></td></tr>
			   <tr><td><a href='../interface/changecase.html'>ChangeCase</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ChangeCase <br>
 <strong>Purpose</strong>:  To change case of all alphabet characters of the specified
               character string according to the given flag.  If protected
               regions are specified, only characters in unprotected regions
               are changed. <br>
 <strong>Usage</strong>: <br>
  ! change all alphabet characters to upper cases <br>
  ---&gt;    CALL ChangeCase(String, .TRUE.) <br>
  ! change all alphabet characters only in unprotected regions to lower cases <br>
  ---&gt;    CALL ChangeCase(String, nRegion, lPos, rPos, .FALSE.)</p></td></tr>
			   <tr><td><a href='../interface/changecasecharacter.html'>ChangeCaseCharacter</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ChangeCaseCharacter <br>
 <strong>Purpose</strong>:  To change case of the given character according to flag. <br>
 <strong>Usage</strong>: <br>
  ! if <em>Char</em> is an alphabet character, change it to its upper case <br>
  ---&gt;    CALL ChangeCaseCharacter(Char, .TRUE.)
  ! if <em>Char</em> is an alphabet character, change it to its lower case <br>
  ---&gt;    CALL ChangeCaseCharacter(Char, .FALSE.)
  ! if <em>Char</em> is NOT an alphabet character, nothing done <br>
  ---&gt;    CALL ChangeCaseCharacter(Char, .TRUE.)</p></td></tr>
			   <tr><td><a href='../interface/char.html'>CHAR</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CHAR <br>
 <strong>Purpose</strong>:  To return a FvlStr object with length of 1 representing the
      character in the specified position of the compiler's character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Chr = CHAR(I) <br></p></td></tr>
			   <tr><td><a href='../proc/character_isequal.html'>Character_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/characterdescription.html'>CharacterDescription</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CharacterDescription <br>
 <strong>Purpose</strong>:  To provide a description of the given character. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Description = CharacterDescription('~')</p></td></tr>
			   <tr><td><a href='../interface/charstring.html'>CharString</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CharString <br>
 <strong>Purpose</strong>:  To construct a character string based on specified input. <br>
 <strong>Usage</strong>: <br>
  ! construct a character string from an array of characters <br>
  ---&gt;    cStr = CharString(cArray) <br>
  ! construct a character string from double-precision real number <br>
  ---&gt;    cStr = CharString(R64, IsScientific=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/city_hash32_exp.html'>City_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/city_hash32_opt.html'>City_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/city_hash64_exp.html'>City_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/city_hash64_opt.html'>City_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/cityhash_i32.html'>CityHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/cityhash_i64.html'>CityHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/closeerrorfile.html'>CloseErrorFile</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>This subroutine closes the general error file.</p></td></tr>
			   <tr><td><a href='../interface/closefile.html'>CloseFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: CloseFile <br>
 <strong>Purpose</strong>:  To close the specified file. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL CloseFile(FileIOUnit) <br>
  ---&gt;    CALL CloseFile(FileName))</p></td></tr>
			   <tr><td><a href='../proc/closemiscopenfiles.html'>CloseMiscOpenFiles</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>This subroutine scans potential unit numbers and closes any that are still open.</p></td></tr>
			   <tr><td><a href='../proc/closeopenfiles.html'>CloseOpenFiles</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Subroutine</td><td><p>To scan potential unit numbers and closes any that are still open.</p></td></tr>
			   <tr><td><a href='../proc/cmpxdp_isequal.html'>CmpxDP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../proc/cmpxqp_isequal.html'>CmpxQP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../proc/cmpxsp_isequal.html'>CmpxSP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/compactstring.html'>CompactString</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CompactString <br>
 <strong>Purpose</strong>:  To convert multiple spaces and tabs into a single space,
               delete control characters and removes initial (leading
               and trailing) spaces. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = CompactString(InStr)</p></td></tr>
			   <tr><td><a href='../interface/compare.html'>Compare</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Compare <br>
 <strong>Purpose</strong>:  To compare two ApInt32 numbers and return <br>
  -1 if LHS &lt; RHS, <br>
   0 if LHS == RHS, or <br>
   1 if LHS &gt; RHS. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Compare(LHS, RHS) <br>
  ---&gt;    IF (Compare(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compare~2.html'>Compare</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Compare <br>
 <strong>Purpose</strong>:  To compare two 128-bit signed integers and return <br>
  -1 if LHS &lt; RHS, <br>
   0 if LHS == RHS, or <br>
   1 if LHS &gt; RHS. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Compare(LHS, RHS) <br>
  ---&gt;    IF (Compare(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compare~3.html'>Compare</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Compare <br>
 <strong>Purpose</strong>:  To compare two ApInt64 numbers and return <br>
  -1 if LHS &lt; RHS, <br>
   0 if LHS == RHS, or <br>
   1 if LHS &gt; RHS. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Compare(LHS, RHS) <br>
  ---&gt;    IF (Compare(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compare~4.html'>Compare</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Compare <br>
 <strong>Purpose</strong>:  To compare two signed integers of the same kind and return <br>
  -1 if LHS &lt; RHS <br>
   0 if LHS == RHS <br>
   1 if LHS &gt; RHS <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Compare(LHS, RHS) <br>
  ---&gt;    IF (Compare(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compareunsigned.html'>CompareUnsigned</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CompareUnsigned <br>
 <strong>Purpose</strong>:  To compare two 128-bit unsigned integers and return <br>
  -1 if LHS &lt; RHS, <br>
   0 if LHS == RHS, or <br>
   1 if LHS &gt; RHS. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = CompareUnsigned(LHS, RHS) <br>
  ---&gt;    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compareunsigned~2.html'>CompareUnsigned</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CompareUnsigned <br>
 <strong>Purpose</strong>:  To compare two unsigned integers (of the same kind) and return <br>
  -1 if LHS &lt; RHS <br>
   0 if LHS == RHS <br>
   1 if LHS &gt; RHS <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = CompareUnsigned(LHS, RHS) <br>
  ---&gt;    IF (CompareUnsigned(LHS, RHS) /= 0) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/compressstring.html'>CompressString</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CompressString <br>
 <strong>Purpose</strong>:  To remove spaces, tabs and control characters from the
               character string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = CompressString(InStr) <br>
 <strong>Note</strong>: Unlike the <em>CompactString</em> procedure, the output string
           contains no space between its characters.</p></td></tr>
			   <tr><td><a href='../proc/converttouppercase.html'>ConvertToUpperCase</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>This function returns the Upper Case representation of the InputString.</p></td></tr>
			   <tr><td><a href='../proc/copydata_character.html'>CopyData_Character</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments
 must have the same sizes, ranks and lengths and their types must be <em>CHARACTER</em>.</p></td></tr>
			   <tr><td><a href='../proc/copydata_complex.html'>CopyData_Complex</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments
 must have the same sizes, ranks and kinds and their types must be <em>COMPLEX</em>.</p></td></tr>
			   <tr><td><a href='../proc/copydata_integer.html'>CopyData_Integer</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments
 must have the same sizes, ranks and kinds and their types must be <em>INTEGER</em>.</p></td></tr>
			   <tr><td><a href='../proc/copydata_logical.html'>CopyData_Logical</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments
 must have the same sizes and ranks and their types must be <em>LOGICAL</em>.</p></td></tr>
			   <tr><td><a href='../proc/copydata_real.html'>CopyData_Real</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments
 must have the same sizes, ranks and kinds and their types must be <em>REAL</em>.</p></td></tr>
			   <tr><td><a href='../interface/countcharacters.html'>CountCharacters</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CountCharacters <br>
 <strong>Purpose</strong>:  To count the number of occurrences of character(s) in the
               specified character string for any character appearing in
               the given character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = CountCharacters(String, CharSet)</p></td></tr>
			   <tr><td><a href='../interface/countcharactersprotect.html'>CountCharactersProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CountCharactersProtect <br>
 <strong>Purpose</strong>:  To count the number of occurrences of delimiter(s) in the
               unprotected region(s) of the specified character string
               where a delimiter is any character appearing in the
               given character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = CountCharactersProtect(String, CharSet) <br>
  ---&gt;    Count = CountCharactersProtect(String, CharSet, ExclMrk=.FALSE.) <br></p></td></tr>
			   <tr><td><a href='../interface/countsubstring.html'>CountSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CountSubstring <br>
 <strong>Purpose</strong>:  To count the number of occurrences of the given
               substring in the specified character string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = CountSubstring(String, SubStr) <br>
  ---&gt;    Count = CountSubstring(String, SubStr, Overlap=.TRUE.)</p></td></tr>
			   <tr><td><a href='../interface/countwords.html'>CountWords</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CountWords <br>
 <strong>Purpose</strong>:  To count the number of words (separated by blanks) in the
               specified character string where blanks are characters in
               the <a href="../module/modbase_chrstr.html#variable-set_blanks">
               SET_BLANKS</a> character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = CountWords(String)</p></td></tr>
			   <tr><td><a href='../interface/crapwowhash_i32.html'>CrapWowHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/createintegerrng.html'>CreateIntegerRng</a></td><td><a href='../module/modbase_prgnbuilder.html'>ModBase_PrgnBuilder</a></td><td>Function</td><td><p>To create an instance of the specified <em>Integer</em> random number generator
 as well as to initialize the generator.</p></td></tr>
			   <tr><td><a href='../proc/createlongrng.html'>CreateLongRng</a></td><td><a href='../module/modbase_prgnbuilder.html'>ModBase_PrgnBuilder</a></td><td>Function</td><td><p>To create an instance of the specified <em>Long</em> random number generator
 as well as to initialize the generator.</p></td></tr>
			   <tr><td><a href='../interface/cropblanks.html'>CropBlanks</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: CropBlanks <br>
 <strong>Purpose</strong>:  To remove leading and trailing blanks from the character string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = CropBlanks(InStr) <br>
  ---&gt;    OutStr = CropBlanks(InStr, SpaceOnly=.TRUE.) <br>
 <strong>Note</strong>: CropBlanks(InStr,.TRUE.) is the same as TRIM(ADJUSTL(InStr)).</p></td></tr>
			   <tr><td><a href='../proc/d1mach.html'>D1MACH</a></td><td><a href='../module/modbase_slatec_util.html'>ModBase_SLATEC_Util</a></td><td>Function</td><td><p>To return floating-point machine dependent parameters.</p><a href="../proc/d1mach.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../interface/decrement.html'>Decrement</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Decrement <br>
 <strong>Purpose</strong>:  To decrease value of a 128-bit signed integer by one. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Decrement(I128)</p></td></tr>
			   <tr><td><a href='../interface/decrement~2.html'>Decrement</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Decrement <br>
 <strong>Purpose</strong>:  To decrease value of a 128-bit unsigned integer by one. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Decrement(U128)</p></td></tr>
			   <tr><td><a href='../proc/degreetoradian.html'>DegreeToRadian</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert an angle from degree to radian</p></td></tr>
			   <tr><td><a href='../interface/display.html'>Display</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Display <br>
 <strong>Purpose</strong>:  To write/display the 'ApInt32' number to the screen (or the specified unit). <br>
 <strong>Usage</strong>: <br>
  ! To display (signed) value of ApNum as a decimal string to the screen <br>
  ---&gt;    CALL Display(ApNum) <br>
  ! To display (signed) value of ApNum as a decimal string to the output logical unit <br>
  ---&gt;    CALL Display(ApNum, 11) <br>
  ! To display (signed) value of ApNum as a decimal string to the output logical unit <br>
  with input/output status and message <br>
  ---&gt;    CALL Display(ApNum, 11, IOStat, IOMsg) <br>
  ! To display (signed) values of components of ApNum as a decimal string to the screen <br>
  ---&gt;    CALL Display(ApNum, ShowComponent=.TRUE.) <br>
  ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br>
  ---&gt;    CALL Display(ApNum, Prefix='Signed value of ApNum')</p></td></tr>
			   <tr><td><a href='../interface/display~2.html'>Display</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Display <br>
 <strong>Purpose</strong>:  To write/display the 'SInt128' object to the screen (or the specified unit). <br>
 <strong>Usage</strong>: <br>
  ! To display (signed) value of I128 as a decimal string to the screen <br>
  ---&gt;    CALL Display(I128) <br>
  ! To display (signed) value of I128 as a decimal string to the output logical unit <br>
  ---&gt;    CALL Display(I128, 11) <br>
  ! To display (signed) value of I128 as a decimal string to the output logical unit <br>
  with input/output status and message <br>
  ---&gt;    CALL Display(I128, 11, IOStat, IOMsg) <br>
  ! To display (signed) values of components of I128 as a decimal string to the screen <br>
  ---&gt;    CALL Display(I128, ShowComponent=.TRUE.) <br>
  ! To display (signed) value of I128 as a decimal string to the screen with a prefix string <br>
  ---&gt;    CALL Display(I128, Prefix='Signed value of I128')</p></td></tr>
			   <tr><td><a href='../interface/display~3.html'>Display</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Display <br>
 <strong>Purpose</strong>:  To write/display the 'UInt128' object to the screen (or the specified unit). <br>
 <strong>Usage</strong>: <br>
  ! To display (unsigned) value of U128 as a decimal string to the screen <br>
  ---&gt;    CALL Display(U128) <br>
  ! To display (unsigned) value of U128 as a decimal string to the output logical unit <br>
  ---&gt;    CALL Display(U128, 11) <br>
  ! To display (unsigned) value of U128 as a decimal string to the output logical unit <br>
  ! with input/output status and message <br>
  ---&gt;    CALL Display(U128, 11, IOStat, IOMsg) <br>
  ! To display (signed) values of components of U128 as a decimal string to the screen <br>
  ---&gt;    CALL Display(U128, ShowComponent=.TRUE.) <br>
  ! To display (unsigned) value of U128 as a decimal string to the screen with a prefix string <br>
  ---&gt;    CALL Display(U128, Prefix='Unsigned value of U128')</p></td></tr>
			   <tr><td><a href='../interface/display~4.html'>Display</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Display <br>
 <strong>Purpose</strong>:  To write/display the 'ApInt64' number to the screen (or the specified unit). <br>
 <strong>Usage</strong>: <br>
  ! To display (signed) value of ApNum as a decimal string to the screen <br>
  ---&gt;    CALL Display(ApNum) <br>
  ! To display (signed) value of ApNum as a decimal string to the output logical unit <br>
  ---&gt;    CALL Display(ApNum, 11) <br>
  ! To display (signed) value of ApNum as a decimal string to the output logical unit <br>
  with input/output status and message <br>
  ---&gt;    CALL Display(ApNum, 11, IOStat, IOMsg) <br>
  ! To display (signed) values of components of ApNum as a decimal string to the screen <br>
  ---&gt;    CALL Display(ApNum, ShowComponent=.TRUE.) <br>
  ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br>
  ---&gt;    CALL Display(ApNum, Prefix='Signed value of ApNum')</p></td></tr>
			   <tr><td><a href='../proc/displaycontinueerror.html'>DisplayContinueError</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To display a 'Continued Error' message.</p></td></tr>
			   <tr><td><a href='../proc/displayfatalerror.html'>DisplayFatalError</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To display a 'Fatal Error' message.</p></td></tr>
			   <tr><td><a href='../proc/displaymessage.html'>DisplayMessage</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To display a (informative) message on designated output Files.</p></td></tr>
			   <tr><td><a href='../proc/displaynumberandstring.html'>DisplayNumberAndString</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Subroutine</td><td><p>To display (at set point on screen for screen positioning models) card images
 during program parsing.</p></td></tr>
			   <tr><td><a href='../proc/displaysevereerror.html'>DisplaySevereError</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To display a 'Severe Error' message.</p></td></tr>
			   <tr><td><a href='../proc/displaystring.html'>DisplayString</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Subroutine</td><td><p>To display string on screen during program execution.</p></td></tr>
			   <tr><td><a href='../proc/displaywarningerror.html'>DisplayWarningError</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To display a 'Warning Error' message.</p></td></tr>
			   <tr><td><a href='../interface/divide.html'>Divide</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Divide <br>
 <strong>Purpose</strong>:  To perform a division: This = This / Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Divide(This, Other)</p></td></tr>
			   <tr><td><a href='../interface/divide~2.html'>Divide</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Divide <br>
 <strong>Purpose</strong>:  To perform a division: This = This / Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Divide(This, Other)</p></td></tr>
			   <tr><td><a href='../interface/dividexp.html'>DivideXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: DivideXp <br>
 <strong>Purpose</strong>:  To perform a division: Quotient = Dividend / Divisor. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Quotient = DivideXp(Dividend, Divisor, Algorithm) <br>
 <strong>Note</strong>: Algorithm must be between 1 and 5.</p></td></tr>
			   <tr><td><a href='../interface/divmod.html'>DivMod</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: DivMod <br>
 <strong>Purpose</strong>:  To perform a division of two signed integers (where the
  dividend (numerator) is a 128-bit signed integer and the divisor
  (denominator) can be 32-, 64- or 128-bit signed integer) and
  to return both the quotient and the remainder. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL DivMod(NUMER, DENOM, QUOT, REM)</p></td></tr>
			   <tr><td><a href='../interface/divmodxp.html'>DivModXp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/doesfileexist.html'>DoesFileExist</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To check whether the file associated with the specified name exists or not</p></td></tr>
			   <tr><td><a href='../proc/dumach.html'>DUMACH</a></td><td><a href='../module/modbase_slatec_util.html'>ModBase_SLATEC_Util</a></td><td>Function</td><td><p>To compute the unit roundoff of the machine.</p><a href="../proc/dumach.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../interface/endwith.html'>EndWith</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: EndWith <br>
 <strong>Purpose</strong>:  To check whether the given character string ends with the
               specified substring or not.  Both the string and the substring
               must not have a zero length. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = EndWith(String, Substring) <br>
  ---&gt;    IF (.NOT.EndWith(String, Substring)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/extend_seed.html'>Extend_Seed</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To extend the seed if the length of SeedIn is less than that of SeedOut.</p></td></tr>
			   <tr><td><a href='../proc/fahrenheittocelcius.html'>FahrenheitToCelcius</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert temperature from deg F to deg C</p></td></tr>
			   <tr><td><a href='../interface/farmmk_hash32_exp.html'>FarmMk_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmmk_hash32_opt.html'>FarmMk_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmmkhash_i32.html'>FarmMkHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmmkhash_i32_recur.html'>FarmMkHash_I32_Recur</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmna_hash64_exp.html'>FarmNa_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmna_hash64_opt.html'>FarmNa_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmnahash_i64.html'>FarmNaHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmuo_hash64_exp.html'>FarmUo_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmuo_hash64_opt.html'>FarmUo_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/farmuohash_i64.html'>FarmUoHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fasthash_i32.html'>FastHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/fill_state.html'>Fill_State</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To fill state(s) based on the given seed(s).</p></td></tr>
			   <tr><td><a href='../proc/find_first_nonspace.html'>Find_First_NonSpace</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/find_first_nonzero.html'>Find_First_NonZero</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/find_inorder_predecessor~5.html'>Find_Inorder_Predecessor</a></td><td><a href='../module/class_intrusivebstrees.html'>Class_IntrusiveBSTrees</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/find_inorder_successor~5.html'>Find_Inorder_Successor</a></td><td><a href='../module/class_intrusivebstrees.html'>Class_IntrusiveBSTrees</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../interface/finddelimiters.html'>FindDelimiters</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindDelimiters <br>
 <strong>Purpose</strong>:  To count the number of occurrences of delimiter(s) in the specified
               character string and also return position(s) of the delimiter(s) found.
               A delimiter is any character appearing in the given character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = FindDelimiters(String, CharSet, DPos)</p></td></tr>
			   <tr><td><a href='../interface/finddelimitersprotect.html'>FindDelimitersProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindDelimitersProtect <br>
 <strong>Purpose</strong>:  To count the number of occurrences of delimiter(s) in unprotected
               regions of the specified character string and also return position(s)
               of the delimiter(s) found.  A delimiter is any character appearing
               in the given character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = FindDelimitersProtect(String, CharSet, DPos) <br>
  ---&gt;    Count = FindDelimitersProtect(String, CharSet, DPos, ExclMrk=.FALSE.)</p></td></tr>
			   <tr><td><a href='../proc/finditem.html'>FindItem</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>This function looks up a string in a similar list of
 items and returns the index of the item in the list, if
 found.  This routine is case insensitive -- it uses the
 SameString function to assure that both strings are in
 all upper case.</p></td></tr>
			   <tr><td><a href='../proc/finditeminlist.html'>FindIteminList</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>This function looks up a string in a similar list of
 items and returns the index of the item in the list, if
 found.  This routine is not case insensitive and doesn't need
 for most inputs -- they are automatically turned to UPPERCASE.
 If you need case insensitivity use FindItem.</p></td></tr>
			   <tr><td><a href='../interface/findlowerindex.html'>FindLowerIndex</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindLowerIndex <br>
<strong>Purpose</strong>:  To find index of the lower limit. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Indx = FindLowerIndex(Limits, Val) <br>
 <strong>Note</strong>:  The index is I where Val &gt; Limits(I) and Val &lt;= Limits(I+1). <br></p></td></tr>
			   <tr><td><a href='../interface/findprotectedregions.html'>FindProtectedRegions</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindProtectedRegions <br>
 <strong>Purpose</strong>:  To find the number of protected regions marked by two (single
               or double) quotes and/or by an exclamation mark.  Also, return
               positions of the first and last characters of each region. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    nRegion = FindProtectedRegions(String, lPos, rPos) <br>
  ---&gt;    nRegion = FindProtectedRegions(String, lPos, rPos, ExclMrk=.FALSE.)</p></td></tr>
			   <tr><td><a href='../interface/findseparators.html'>FindSeparators</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindSeparators <br>
 <strong>Purpose</strong>:  To count the number of occurrences of separator(s) in the
               specified character string and also return (the first)
               position(s) of the separator(s) found. <br>
 <strong>Usage</strong>: <br>
  ! a separator is any (single) character in the <em>Separator</em> argument <br>
  ---&gt;    Count = FindSeparators(String, Separator, .TRUE., Pos) <br>
  ! a separator is a character string specified by the <em>Separator</em> argument <br>
  ---&gt;    Count = FindSeparators(String, Separator, .FALSE., Pos)</p></td></tr>
			   <tr><td><a href='../interface/findseparatorsprotect.html'>FindSeparatorsProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindSeparatorsProtect <br>
 <strong>Purpose</strong>:  To count the number of occurrences of separator(s) in the
               specified character string and also return (the first)
               position(s) of the separator(s) found. <br>
 <strong>Usage</strong>: <br>
  ! both quotes and an exclamation mark used to define protected regions.  <br>
  ---&gt;    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos)  ! separator is a single character <br>
  ---&gt;    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos) ! separator is a character string <br>
  ! only quotes used to define protected regions.  <br>
  ---&gt;    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos, ExclMrk=.FALSE.) <br>
  ---&gt;    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos, ExclMrk=.FALSE.)</p></td></tr>
			   <tr><td><a href='../interface/findsubstring.html'>FindSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindSubstring <br>
 <strong>Purpose</strong>:  To count the number of non-overlapping occurrences of the given
               substring in the specified character string and also return
               position(s) of the first character of substring found. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = FindSubstring(String, SubStr, FirstPos)</p></td></tr>
			   <tr><td><a href='../interface/findsubstringprotect.html'>FindSubstringProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FindSubstringProtect <br>
 <strong>Purpose</strong>:  To count the number of non-overlapping occurrences of the given
               substring in unprotected regions of the specified character
               string and also return position(s) of the first character of
               substring found. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Count = FindSubstringProtect(String, SubStr, FirstPos) <br>
  ---&gt;    Count = FindSubstringProtect(String, SubStr, FirstPos, ExclMrk=.FALSE.)</p></td></tr>
			   <tr><td><a href='../proc/fmlib_init.html'>FMLib_Init</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Subroutine</td><td><p>To initialize the FMLIB library.</p></td></tr>
			   <tr><td><a href='../interface/fromstringxp.html'>FromStringXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FromStringXp <br>
 <strong>Purpose</strong>:  To construct the <em>ApInt64</em> number based on the specified decimal
               string.  Valid value of <em>Algorithm</em> is between 1 and 4. <br>
 <strong>Usage</strong>: <br>
 ---&gt; ApNum = FromStringXp('1234567890987654321011223344', Algorithm) <br>
 ---&gt; ApNum = FromStringXp('-987654321012345678900123123', Algorithm, ErrFlag) <br>
 ---&gt; ApNum = FromStringXp(NumStr, 1, ErrMsg=Message) <br>
 ---&gt; ApNum = FromStringXp(NumStr, 4, ErrFlag, ErrMsg)</p></td></tr>
			   <tr><td><a href='../interface/fvlstr.html'>FvlStr</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: FvlStr <br>
 <strong>Purpose</strong>:  To construct a FvlStr object based on specified input. <br>
 <strong>Usage</strong>: <br>
  ! construct a FvlStr object from an array of characters <br>
  ---&gt;    vStr = FvlStr(cArray) <br>
  ! construct a FvlStr object from double-precision real number <br>
  ---&gt;    vStr = FvlStr(R64, IsScientific=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/geterrormessage.html'>GetErrorMessage</a></td><td><a href='../module/class_mathexpparser.html'>Class_MathExpParser</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GetErrorMessage <br>
<strong>Purpose</strong>:  To return an error message corresponding to the specified error code. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    ErrMsg = Parser_ErrorMsg(ErrCode) <br></p></td></tr>
			   <tr><td><a href='../proc/getfileiounit.html'>GetFileIOUnit</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To return a unit number of the file associated with the specified name.</p></td></tr>
			   <tr><td><a href='../proc/getiounits_allopenfile.html'>GetIOUnits_AllOpenFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To return a number of currently opened files and their associated unit numbers.</p></td></tr>
			   <tr><td><a href='../interface/getlen.html'>GETLEN</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GETLEN <br>
 <strong>Purpose</strong>:  To return length of the character string of a FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Length = GETLEN(vStr) <br></p></td></tr>
			   <tr><td><a href='../interface/getlength.html'>GetLength</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GetLength <br>
 <strong>Purpose</strong>:  To return the length of the magnitude array (the number of
               digits counted as the ApNum number). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    MagLen = GetLength(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/getlength~2.html'>GetLength</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GetLength <br>
 <strong>Purpose</strong>:  To return the length of the magnitude array (the number of
               digits counted as the ApNum number). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    MagLen = GetLength(ApNum)</p></td></tr>
			   <tr><td><a href='../proc/getlistofsectionsininput.html'>GetListofSectionsinInput</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Subroutine</td><td><p>This subroutine returns the list of sections as they occurred
 in the Input Data File (IDF).</p></td></tr>
			   <tr><td><a href='../proc/getnewiounit.html'>GetNewIOUnit</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To return a input/output unit number that can exist and is not connected.</p></td></tr>
			   <tr><td><a href='../proc/getnumobjectsfound.html'>GetNumObjectsFound</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>This function returns the number of objects (in input data file)
 found in the current run.  If it can't find the object in list
 of objects, a -1 will be returned.</p></td></tr>
			   <tr><td><a href='../proc/getnumsectionsfound.html'>GetNumSectionsFound</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>This function returns the number of a particular section (in input data file)
 found in the current run.  If it can't find the section in list
 of sections, a -1 will be returned.</p></td></tr>
			   <tr><td><a href='../proc/getnumsectionsininput.html'>GetNumSectionsinInput</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>This function returns the number of sections in the entire input data file
 of the current run.</p></td></tr>
			   <tr><td><a href='../proc/getobjectitem.html'>GetObjectItem</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Subroutine</td><td><p>This subroutine gets the 'number' 'object' from the IDFRecord data structure.</p></td></tr>
			   <tr><td><a href='../proc/getobjectitemfromfile.html'>GetObjectItemfromFile</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Subroutine</td><td><p>This subroutine "gets" the object instance from the data structure.</p></td></tr>
			   <tr><td><a href='../proc/getobjectitemnum.html'>GetObjectItemNum</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Function</td><td><p>Get the occurrence number of an object of type ObjType and name ObjName.</p></td></tr>
			   <tr><td><a href='../interface/getrandomseed32.html'>GetRandomSeed32</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To get a 32-bit integer value representing a seed value.</p></td></tr>
			   <tr><td><a href='../interface/getrandomseed64.html'>GetRandomSeed64</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To get a 64-bit integer value representing a seed value.</p></td></tr>
			   <tr><td><a href='../proc/getseedsizeintegerrng.html'>GetSeedSizeIntegerRng</a></td><td><a href='../module/modbase_prgnbuilder.html'>ModBase_PrgnBuilder</a></td><td>Function</td><td><p>To return the number of seeds required by the specified algorithm.</p></td></tr>
			   <tr><td><a href='../proc/getseedsizelongrng.html'>GetSeedSizeLongRng</a></td><td><a href='../module/modbase_prgnbuilder.html'>ModBase_PrgnBuilder</a></td><td>Function</td><td><p>To return the number of seeds required by the specified algorithm.</p></td></tr>
			   <tr><td><a href='../interface/getslice.html'>GetSlice</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GetSlice <br>
 <strong>Purpose</strong>:  To extract characters from the region between the first and
               last indices (both inclusive) of the given string by taking
               strides of length <em>Stride</em>. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Slice = GetSlice(String, FirstIndx, LastIndx, Stride)</p></td></tr>
			   <tr><td><a href='../interface/getsubstring.html'>GetSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: GetSubstring <br>
 <strong>Purpose</strong>:  To get a substring (specified by the leftmost and rightmost
               indices) of the given character string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Substring = GetSubstring(String, LeftIndx, RightIndx)</p></td></tr>
			   <tr><td><a href='../interface/halfsiphash24_i32.html'>HalfSipHash24_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/halfsiphash_i32.html'>HalfSipHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/handle_erralloc.html'>Handle_ErrAlloc</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To handle allocation error if necessary (i.e. Stat /= 0).</p></td></tr>
			   <tr><td><a href='../proc/handle_errdealloc.html'>Handle_ErrDealloc</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To handle deallocation error if necessary (i.e. Stat /= 0).</p></td></tr>
			   <tr><td><a href='../proc/handle_errlevel.html'>Handle_ErrLevel</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To handle the error occurred according to the specified error level (and the
 configuration mode defined in the "Macro - Basic Definitions.f90" file).</p></td></tr>
			   <tr><td><a href='../proc/handle_erropen.html'>Handle_ErrOpen</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To handle error due to open file operation according to the specified error level (and
 the configuration mode defined in the "Macro - Basic Definitions.f90" file).</p></td></tr>
			   <tr><td><a href='../proc/hash32_ap.html'>Hash32_AP</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the AP hash algorithm by Arash Partow [1].</p></td></tr>
			   <tr><td><a href='../proc/hash32_dek.html'>Hash32_DEK</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the DEK hash algorithm by Donald E. Knuth [1].</p></td></tr>
			   <tr><td><a href='../proc/hash32_djb.html'>Hash32_DJB</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the DJB2 hash algorithm by
 Daniel J. Bernstein [1, 5].</p></td></tr>
			   <tr><td><a href='../proc/hash32_elf.html'>Hash32_ELF</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the PJW hash algorithm (tweaked for
 32-bit processors) as implemented on UNIX-based systems.</p></td></tr>
			   <tr><td><a href='../proc/hash32_fnv1.html'>Hash32_FNV1</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the FNV-1 hash algorithm by Glenn Fowler,
 Landon Curt Noll, and Phong Vo [7].</p></td></tr>
			   <tr><td><a href='../proc/hash32_fnv1a.html'>Hash32_FNV1a</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the FNV-1a hash algorithm by Glenn Fowler,
 Landon Curt Noll, and Phong Vo [7].</p></td></tr>
			   <tr><td><a href='../proc/hash32_js.html'>Hash32_JS</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the JS hash algorithm by Justin Sobel [1].</p></td></tr>
			   <tr><td><a href='../proc/hash32_oat.html'>Hash32_OAT</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the OAT (One-At-a-Time) hash algorithm by
 Bob Jenkins [8].</p></td></tr>
			   <tr><td><a href='../proc/hash32_pjw.html'>Hash32_PJW</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the PJW hash algorithm by Peter J. Weinberger [1, 4].</p></td></tr>
			   <tr><td><a href='../proc/hash32_rs.html'>Hash32_RS</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the RS hash algorithm by Robert Sedgewick [1],
 which is based on the universal hash function in [3].</p></td></tr>
			   <tr><td><a href='../proc/hash32_sdbm.html'>Hash32_SDBM</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the SDBM hash algorithm [1, 5].</p></td></tr>
			   <tr><td><a href='../proc/hash32_tm.html'>Hash32_TM</a></td><td><a href='../module/modbase_simplehash32.html'>ModBase_SimpleHash32</a></td><td>Function</td><td><p>To compute the hash value using the TM hash algorithm by Thomas Mueller [6].</p></td></tr>
			   <tr><td><a href='../proc/hash64_ap.html'>Hash64_AP</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the AP hash algorithm by Arash Partow [1].</p></td></tr>
			   <tr><td><a href='../proc/hash64_dek.html'>Hash64_DEK</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the DEK hash algorithm by Donald E. Knuth [1].</p></td></tr>
			   <tr><td><a href='../proc/hash64_djb.html'>Hash64_DJB</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the DJB2 hash algorithm by
 Daniel J. Bernstein [1, 5].</p></td></tr>
			   <tr><td><a href='../proc/hash64_fnv1.html'>Hash64_FNV1</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the FNV-1 hash algorithm by Glenn Fowler,
 Landon Curt Noll, and Phong Vo [7].</p></td></tr>
			   <tr><td><a href='../proc/hash64_fnv1a.html'>Hash64_FNV1a</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the FNV-1a hash algorithm by Glenn Fowler,
 Landon Curt Noll, and Phong Vo [7].</p></td></tr>
			   <tr><td><a href='../proc/hash64_js.html'>Hash64_JS</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the JS hash algorithm by Justin Sobel [1].</p></td></tr>
			   <tr><td><a href='../proc/hash64_oat.html'>Hash64_OAT</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the OAT (One-At-a-Time) hash algorithm by
 Bob Jenkins [8].</p></td></tr>
			   <tr><td><a href='../proc/hash64_pjw.html'>Hash64_PJW</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the PJW hash algorithm by Peter J. Weinberger [1, 4].</p></td></tr>
			   <tr><td><a href='../proc/hash64_rs.html'>Hash64_RS</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the RS hash algorithm by Robert Sedgewick [1],
 which is based on the universal hash function in [3].</p></td></tr>
			   <tr><td><a href='../proc/hash64_sdbm.html'>Hash64_SDBM</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the SDBM hash algorithm [1, 5].</p></td></tr>
			   <tr><td><a href='../proc/hash64_tm.html'>Hash64_TM</a></td><td><a href='../module/modbase_simplehash64.html'>ModBase_SimpleHash64</a></td><td>Function</td><td><p>To compute the hash value using the TM hash algorithm by Thomas Mueller [6].</p></td></tr>
			   <tr><td><a href='../interface/hextobytes_be.html'>HexToBytes_BE</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: HexToBytes_BE <br>
 <strong>Purpose</strong>:  To convert a hexadecimal string to an array of 8-bit
               integer numbers (stored in big-endian order). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL HexToBytes_BE(HexStr, ByteArr)</p></td></tr>
			   <tr><td><a href='../interface/hextobytes_le.html'>HexToBytes_LE</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: HexToBytes_LE <br>
 <strong>Purpose</strong>:  To convert a hexadecimal string to an array of 8-bit
               integer numbers (stored in little-endian order). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL HexToBytes_LE(HexStr, ByteArr)</p></td></tr>
			   <tr><td><a href='../interface/highestonebit.html'>HighestOneBit</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: HighestOneBit <br>
 <strong>Purpose</strong>:  To return an integer value (same kind as the specified integer value) with at most
  a single one-bit, in the position of the highest-order (leftmost) one-bit in the input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = HighestOneBit(INPUT)</p></td></tr>
			   <tr><td><a href='../proc/html_report_close.html'>HTML_Report_Close</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To properly close the report file.</p></td></tr>
			   <tr><td><a href='../proc/html_report_heading.html'>HTML_Report_Heading</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a heading based on the specified level.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_begin.html'>HTML_Report_List_Begin</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the start of an unordered list that will usually be followed
 by calling HTML_Report_List_Real, HTML_Report_List_Integer,
 HTML_Report_List_String, and/or HTML_Report_List_End routines.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_end.html'>HTML_Report_List_End</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the end of an unordered list that will usually be called
 after calling HTML_Report_List_Begin, HTML_Report_List_Real,
 HTML_Report_List_Integer and/or HTML_Report_List_String routines
 first.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_integer.html'>HTML_Report_List_Integer</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a list based on the given text(s) and an integer number
 The routine assumes that the given number is between the given
 two texts or after the first text if the second text is missing.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_ordered.html'>HTML_Report_List_Ordered</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a list based on the given list array.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_real.html'>HTML_Report_List_Real</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a list based on the given text(s) and a real number.
 The routine assumes that the given number is between the given
 two texts or after the first text if the second text is missing.</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_string.html'>HTML_Report_List_String</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a list based on the given text(s) and a string.
 The routine assumes that the given string is between the given
 two texts or after the first text if the second text is missing. <br>
 Note: the given string will be emphasized by giving different color
       from the other text(s).</p></td></tr>
			   <tr><td><a href='../proc/html_report_list_unordered.html'>HTML_Report_List_Unordered</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a list based on the given list array.</p></td></tr>
			   <tr><td><a href='../proc/html_report_open_exist.html'>HTML_Report_Open_Exist</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To open an existing report file (and write its title).</p></td></tr>
			   <tr><td><a href='../proc/html_report_open_new.html'>HTML_Report_Open_New</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To open a new report file and write its title.</p></td></tr>
			   <tr><td><a href='../proc/html_report_paragraph.html'>HTML_Report_Paragraph</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write a paragraph based on the given text array.</p></td></tr>
			   <tr><td><a href='../proc/html_report_table_begin.html'>HTML_Report_Table_Begin</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the start of a table that will usually be followed
 by calling HTML_Report_Table_Row and HTML_Report_Table_End routines.</p></td></tr>
			   <tr><td><a href='../proc/html_report_table_end.html'>HTML_Report_Table_End</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the start of a table that will usually be called
 after calling HTML_Report_Table_Begin and HTML_Report_Table_Row routines.</p></td></tr>
			   <tr><td><a href='../proc/html_report_table_row.html'>HTML_Report_Table_Row</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the rows of a table.</p></td></tr>
			   <tr><td><a href='../proc/html_report_table_rowinteger.html'>HTML_Report_Table_RowInteger</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the rows of a table with integer data. <br>
 Note: Except for the first cell, all cell data are assumed to be
      integer number.  If cell data will have both real and integer
      numbers, then they should be converted to string first and use
      HTML_Report_Table_Row instead of this routine.</p></td></tr>
			   <tr><td><a href='../proc/html_report_table_rowreal.html'>HTML_Report_Table_RowReal</a></td><td><a href='../module/modbase_html_report.html'>ModBase_HTML_Report</a></td><td>Subroutine</td><td><p>To write the rows of a table with real data. <br>
 Note: Except for the first cell, all cell data are assumed to be
      real number.  If cell data will have both real and integer
      numbers, then they should be converted to string first and use
      HTML_Report_Table_Row instead of this routine.</p></td></tr>
			   <tr><td><a href='../proc/i128_to_r128.html'>I128_To_R128</a></td><td><a href='../module/class_integerrng.html'>Class_IntegerRNG</a></td><td>Function</td><td><p>To convert a 128-bit integer value to a 128-bit real value.</p></td></tr>
			   <tr><td><a href='../proc/i1mach.html'>I1MACH</a></td><td><a href='../module/modbase_slatec_util.html'>ModBase_SLATEC_Util</a></td><td>Function</td><td><p>To return integer machine dependent parameters.</p><a href="../proc/i1mach.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/i32_fromchar.html'>I32_FromChar</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Function</td><td><p>To convert a decimal string to an integer value</p></td></tr>
			   <tr><td><a href='../interface/i32_fromchar_cc_fortnum.html'>I32_FromChar_CC_FortNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_fromchar_cc_fortplus.html'>I32_FromChar_CC_FortPlus</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_fromchar_cc_jsonnum.html'>I32_FromChar_CC_JsonNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_fromchar_lemire_fortplus.html'>I32_FromChar_Lemire_FortPlus</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_fromchar_yy_jsonnum.html'>I32_FromChar_YY_JsonNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_tochar_basic.html'>I32_ToChar_Basic</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_tochar_cc.html'>I32_ToChar_CC</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_tochar_jea.html'>I32_ToChar_JEA</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_tochar_yy.html'>I32_ToChar_YY</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i32_tochar_yyll.html'>I32_ToChar_YYLL</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/i64_fromchar.html'>I64_FromChar</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Function</td><td><p>To convert a decimal string to an integer value</p></td></tr>
			   <tr><td><a href='../interface/i64_fromchar_cc_fortnum.html'>I64_FromChar_CC_FortNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_fromchar_cc_fortplus.html'>I64_FromChar_CC_FortPlus</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_fromchar_cc_jsonnum.html'>I64_FromChar_CC_JsonNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_fromchar_lemire_fortplus.html'>I64_FromChar_Lemire_FortPlus</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_fromchar_yy_jsonnum.html'>I64_FromChar_YY_JsonNum</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_tochar_basic.html'>I64_ToChar_Basic</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_tochar_cc.html'>I64_ToChar_CC</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_tochar_jea.html'>I64_ToChar_JEA</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_tochar_yy.html'>I64_ToChar_YY</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/i64_tochar_yyll.html'>I64_ToChar_YYLL</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/iachar.html'>IACHAR</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IACHAR <br>
 <strong>Purpose</strong>:  To return the character code based on the ASCII character set
      of the specified character of the FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I = IACHAR(vStr, Pos) <br>
 <strong>Note</strong>: A character code is a position of the character in a character set. <br></p></td></tr>
			   <tr><td><a href='../interface/iand.html'>IAND</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND <br>
 <strong>Purpose</strong>:  To perform a logical AND on corresponding bits of two
               ApInt32 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IAND(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../interface/iand~2.html'>IAND</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND <br>
 <strong>Purpose</strong>:  To perform a logical AND on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IAND(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/iand~3.html'>IAND</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND <br>
 <strong>Purpose</strong>:  To perform a logical AND on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IAND(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/iand~4.html'>IAND</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND <br>
 <strong>Purpose</strong>:  To perform a logical AND on corresponding bits of two
               ApInt64 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IAND(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../interface/iand_not.html'>IAND_NOT</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND_NOT <br>
 <strong>Purpose</strong>:  To perform a bitwise AND and NOT on corresponding bits of two
               ApInt32 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IAND_NOT(NumIn1, NumIn2) <br>
 <strong>Note</strong>: IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)).</p></td></tr>
			   <tr><td><a href='../interface/iand_not~2.html'>IAND_NOT</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IAND_NOT <br>
 <strong>Purpose</strong>:  To perform a bitwise AND and NOT on corresponding bits of two
               ApInt64 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IAND_NOT(NumIn1, NumIn2) <br>
 <strong>Note</strong>: IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)).</p></td></tr>
			   <tr><td><a href='../interface/ibchng.html'>IBCHNG</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCHNG <br>
 <strong>Purpose</strong>:  To reverse the bit at the specified position. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBCHNG(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibchng~2.html'>IBCHNG</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCHNG <br>
 <strong>Purpose</strong>:  To reverse the bit at the specified position.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBCHNG(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibchng~3.html'>IBCHNG</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCHNG <br>
 <strong>Purpose</strong>:  To reverse the bit at the specified position.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBCHNG(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibchng~4.html'>IBCHNG</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCHNG <br>
 <strong>Purpose</strong>:  To reverse the bit at the specified position. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBCHNG(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibclr.html'>IBCLR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCLR <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 0. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBCLR(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibclr~2.html'>IBCLR</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCLR <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 0.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBCLR(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibclr~3.html'>IBCLR</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCLR <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 0.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBCLR(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibclr~4.html'>IBCLR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBCLR <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 0. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBCLR(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibits.html'>IBITS</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBITS <br>
 <strong>Purpose</strong>:  To extract a sequence of bits according to the specified input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBITS(IN, Pos, Len)</p></td></tr>
			   <tr><td><a href='../interface/ibits~2.html'>IBITS</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBITS <br>
 <strong>Purpose</strong>:  To extract a sequence of bits according to the specified input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBITS(IN, Pos, Len)</p></td></tr>
			   <tr><td><a href='../interface/ibset.html'>IBSET</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBSET <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBSET(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibset~2.html'>IBSET</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBSET <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 1.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBSET(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibset~3.html'>IBSET</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBSET <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 1.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IBSET(IN, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ibset~4.html'>IBSET</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IBSET <br>
 <strong>Purpose</strong>:  To set the bit at the specified position to 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IBSET(NumIn, Pos)</p></td></tr>
			   <tr><td><a href='../interface/ichar.html'>ICHAR</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ICHAR <br>
 <strong>Purpose</strong>:  To return the character code based on the compiler's character set
      of the specified character of the FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I = ICHAR(vStr, Pos) <br>
 <strong>Note</strong>: A character code is a position of the character in a character set. <br></p></td></tr>
			   <tr><td><a href='../proc/identitymatrix.html'>IdentityMatrix</a></td><td><a href='../module/modbase_mathutil.html'>ModBase_MathUtil</a></td><td>Function</td><td><p>To create identity matrix.</p></td></tr>
			   <tr><td><a href='../interface/ieor.html'>IEOR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IEOR <br>
 <strong>Purpose</strong>:  To perform an exclusive OR on corresponding bits of two
               ApInt32 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IEOR(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../interface/ieor~2.html'>IEOR</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IEOR <br>
 <strong>Purpose</strong>:  To perform an exclusive OR on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IEOR(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/ieor~3.html'>IEOR</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IEOR <br>
 <strong>Purpose</strong>:  To perform an exclusive OR on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IEOR(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/ieor~4.html'>IEOR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IEOR <br>
 <strong>Purpose</strong>:  To perform an exclusive OR on corresponding bits of two
               ApInt64 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IEOR(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../interface/increment.html'>Increment</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Increment <br>
 <strong>Purpose</strong>:  To increase value of a 128-bit signed integer by one. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Increment(I128)</p></td></tr>
			   <tr><td><a href='../interface/increment~2.html'>Increment</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Increment <br>
 <strong>Purpose</strong>:  To increase value of a 128-bit unsigned integer by one. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Increment(U128)</p></td></tr>
			   <tr><td><a href='../interface/index.html'>INDEX</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: INDEX <br>
 <strong>Purpose</strong>:  To return the starting position of a substring within the string
      of a FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Indx = INDEX(vStr, sStr) <br>
  ---&gt;    Indx = INDEX(vStr, sStr, Back=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../proc/index_init.html'>Index_Init</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Subroutine</td><td><p>To initialize indices.</p></td></tr>
			   <tr><td><a href='../interface/inrange.html'>InRange</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: InRange <br>
<strong>Purpose</strong>:  To check if the value is in the specified range or not.
      Return true if it is.  Otherwise, return false. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = InRange(Val, UppLimit, LowLimit) <br>
  ---&gt;    IF (.NOT.InRange(Val, UppLimit, LowLimit)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/insertsubstring.html'>InsertSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: InsertSubstring <br>
 <strong>Purpose</strong>:  To insert a given substring into the character string at a
               specified position. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = InsertSubstring(InStr, Pos, SubStr)</p></td></tr>
			   <tr><td><a href='../proc/int16b_isequal.html'>Int16B_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../proc/int32b_isequal.html'>Int32B_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../proc/int64b_isequal.html'>Int64B_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../proc/int8b_isequal.html'>Int8B_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/introrank.html'>IntroRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/introsort.html">IntroSort</a> interface
  for the technical information of the <em>IntroSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/introsort.html'>IntroSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>IntroSort</em> algorithm is a hybrid algorithm developed by David Musser [1].
  The algorithm starts sorting the given array using the quicksort algorithm
  with the median-of-three partitioning scheme.  It then switches to the heapsort
  algorithm when the recursion depth exceeds its limit (which is dependent on the
  array size).  It also switches to the pair-insertion sort algorithm if the
  (sub)array size falls below a certain threshold (called insertion cutoff). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps">
      Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.
      Software: Practice and Experience. 27(8):983-993. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/introsort~2.html'>IntroSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>IntroSort</em> algorithm is a hybrid algorithm developed by David Musser [1].
  The algorithm starts sorting the given array using the quicksort algorithm
  with the median-of-three partitioning scheme.  It then switches to the heapsort
  algorithm when the recursion depth exceeds its limit (which is dependent on the
  array size).  It also switches to the pair-insertion sort algorithm if the
  (sub)array size falls below a certain threshold (called insertion cutoff). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps">
      Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.
      Software: Practice and Experience. 27(8):983-993. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/ior.html'>IOR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IOR <br>
 <strong>Purpose</strong>:  To perform an inclusive OR on corresponding bits of two
               ApInt32 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IOR(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../interface/ior~2.html'>IOR</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IOR <br>
 <strong>Purpose</strong>:  To perform an inclusive OR on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IOR(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/ior~3.html'>IOR</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IOR <br>
 <strong>Purpose</strong>:  To perform an inclusive OR on corresponding bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = IOR(LHSIN, RHSIN)</p></td></tr>
			   <tr><td><a href='../interface/ior~4.html'>IOR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IOR <br>
 <strong>Purpose</strong>:  To perform an inclusive OR on corresponding bits of two
               ApInt64 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = IOR(NumIn1, NumIn2)</p></td></tr>
			   <tr><td><a href='../proc/is_character_alphanum.html'>Is_Character_AlphaNum</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_ascii.html'>Is_Character_ASCII</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_blank.html'>Is_Character_Blank</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_control.html'>Is_Character_Control</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_digit.html'>Is_Character_Digit</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_exponent.html'>Is_Character_Exponent</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_graphical.html'>Is_Character_Graphical</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_hexdigit.html'>Is_Character_HexDigit</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_in_range.html'>Is_Character_In_Range</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_integer.html'>Is_Character_Integer</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_letter.html'>Is_Character_Letter</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_logical.html'>Is_Character_Logical</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_lowercase_letter.html'>Is_Character_Lowercase_Letter</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_numeric.html'>Is_Character_Numeric</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_octdigit.html'>Is_Character_OctDigit</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_period.html'>Is_Character_Period</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_printable.html'>Is_Character_Printable</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_punctuation.html'>Is_Character_Punctuation</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_sign.html'>Is_Character_Sign</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_uppercase_letter.html'>Is_Character_Uppercase_Letter</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_character_whitespace.html'>Is_Character_WhiteSpace</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/is_little_endian.html'>Is_Little_Endian</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To check if the current machine is little-endian or big-endian.</p></td></tr>
			   <tr><td><a href='../interface/ischaracterinclass.html'>IsCharacterInClass</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsCharacterInClass <br>
 <strong>Purpose</strong>:  To check whether a given character is in the specified class. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsCharacterInClass('A', 'ASCII', FailIndex) <br>
  ---&gt;    IF (.NOT.IsCharacterInClass('5', 'ALPHANUM')) DoSomething</p></td></tr>
			   <tr><td><a href='../proc/isevennumber.html'>IsEvenNumber</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To check if the number is an even number.
 If it is, return true.  Otherwise, return false.</p></td></tr>
			   <tr><td><a href='../interface/isfileopen.html'>IsFileOpen</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsFileOpen <br>
 <strong>Purpose</strong>:  To check whether the specified file is open or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsFileOpen(FileIOUnit) <br>
  ---&gt;    IF (IsFileOpen(FileName)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/ishft.html'>ISHFT</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFT <br>
 <strong>Purpose</strong>:  To perform logical shift of an ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 <br>
  ---&gt;    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224</p></td></tr>
			   <tr><td><a href='../interface/ishft~2.html'>ISHFT</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFT <br>
 <strong>Purpose</strong>:  To perform logical shift with -128 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 <br>
  ---&gt;    OUT = ISHFT(IN, -24)   ! a logical right shift by 24</p></td></tr>
			   <tr><td><a href='../interface/ishft~3.html'>ISHFT</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFT <br>
 <strong>Purpose</strong>:  To perform logical shift with -128 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ISHFT(IN, 53)    ! a logical left shift by 53 <br>
  ---&gt;    OUT = ISHFT(IN, -24)   ! a logical right shift by 24</p></td></tr>
			   <tr><td><a href='../interface/ishft~4.html'>ISHFT</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFT <br>
 <strong>Purpose</strong>:  To perform logical shift of an ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 <br>
  ---&gt;    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224</p></td></tr>
			   <tr><td><a href='../interface/ishftc.html'>ISHFTC</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFTC <br>
 <strong>Purpose</strong>:  To perform circular shift with -128 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 <br>
  ---&gt;    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24</p></td></tr>
			   <tr><td><a href='../interface/ishftc~2.html'>ISHFTC</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ISHFTC <br>
 <strong>Purpose</strong>:  To perform circular shift with -128 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ISHFTC(IN, 53)    ! a circular left shift by 53 <br>
  ---&gt;    OUT = ISHFTC(IN, -24)   ! a circular right shift by 24</p></td></tr>
			   <tr><td><a href='../interface/isnegative.html'>IsNegative</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsNegative <br>
 <strong>Purpose</strong>:  To check whether the ApInt32 number has negative value or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsNegative(ApNum) <br>
  ---&gt;    IF (IsNegative(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/isnegative~2.html'>IsNegative</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsNegative <br>
 <strong>Purpose</strong>:  To check whether the input value is negative or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsNegative(INPUT) <br>
  ---&gt;    IF (IsNegative(INPUT)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/isnegative~3.html'>IsNegative</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsNegative <br>
 <strong>Purpose</strong>:  To check whether the ApInt64 number has negative value or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsNegative(ApNum) <br>
  ---&gt;    IF (IsNegative(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../proc/isoddnumber.html'>IsOddNumber</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To check if the number is an odd number.
 If it is, return true.  Otherwise, return false.</p></td></tr>
			   <tr><td><a href='../interface/isone.html'>IsOne</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsOne <br>
 <strong>Purpose</strong>:  To check whether the ApInt32 number has value of one or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsOne(ApNum) <br>
  ---&gt;    IF (IsOne(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/isone~2.html'>IsOne</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsOne <br>
 <strong>Purpose</strong>:  To check whether the ApInt64 number has value of one or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsOne(ApNum) <br>
  ---&gt;    IF (IsOne(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/ispolytypevalid.html'>IsPolyTypeValid</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IsPolyTypeValid <br>
 <strong>Purpose</strong>:  To check whether the specified input has the same type and their type is valid. <br></p></td></tr>
			   <tr><td><a href='../interface/ispositive.html'>IsPositive</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsPositive <br>
 <strong>Purpose</strong>:  To check whether the ApInt32 number has positive value or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsPositive(ApNum) <br>
  ---&gt;    IF (IsPositive(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/ispositive~2.html'>IsPositive</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsPositive <br>
 <strong>Purpose</strong>:  To check whether the input value is positive or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsPositive(INPUT) <br>
  ---&gt;    IF (IsPositive(INPUT)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/ispositive~3.html'>IsPositive</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsPositive <br>
 <strong>Purpose</strong>:  To check whether the ApInt64 number has positive value or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsPositive(ApNum) <br>
  ---&gt;    IF (IsPositive(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/isranked.html'>IsRanked</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsRanked <br>
 <strong>Purpose</strong>:  To check whether the specified array is ranked in
      the ascending order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsRanked(AVal, AInd) <br>
  ---&gt;    IF (.NOT.IsRanked(AVal, AInd)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/isready.html'>IsReady</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsReady <br>
 <strong>Purpose</strong>:  To check whether the FvlStr object is ready to be used or not.
      Return true if the object's string is allocated.  Otherwise, return false.  <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsReady(vStr) <br>
  ---&gt;    IF (.NOT.IsReady(vStr)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/issortedascend.html'>IsSortedAscend</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsSortedAscend <br>
 <strong>Purpose</strong>:  To check whether the specified array is sorted in
      the desired order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsSortedAscend(A) <br>
  ---&gt;    IF (.NOT.IsSortedAscend(A)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/issorteddescend.html'>IsSortedDescend</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsSortedDescend <br>
 <strong>Purpose</strong>:  To check whether the specified array is sorted in
      the desired order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsSortedDescend(A) <br>
  ---&gt;    IF (.NOT.IsSortedDescend(A)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/isstringincharacterset.html'>IsStringInCharacterSet</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsStringInCharacterSet <br>
 <strong>Purpose</strong>:  To check whether all characters in the character string are
               in the specified character set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsStringInCharacterSet('Ab23Cd', SET_ALPHANUM, FailIndex) <br>
  ---&gt;    IF (.NOT.IsStringInCharacterSet('32.105Q-32', SET_NUMERICS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/isstringinclass.html'>IsStringInClass</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsStringInClass <br>
 <strong>Purpose</strong>:  To check whether a given string is in the specified class. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsStringInClass('AbCd', 'ASCII', FailIndex) <br>
  ---&gt;    IF (.NOT.IsStringInClass('32.105e-32', 'REAL') DoSomething</p></td></tr>
			   <tr><td><a href='../interface/isstringlogical.html'>IsStringLogical</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsStringLogical <br>
 <strong>Purpose</strong>: To check whether a character string is a logical value where
              valid one include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true',
              'false'. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsStringLogical('a') <br>
  ---&gt;    Flag = IsStringLogical('f', LogVal)</p></td></tr>
			   <tr><td><a href='../interface/isstringnumber.html'>IsStringNumber</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsStringNumber <br>
 <strong>Purpose</strong>:  To check whether a character string is a valid number and
               return a flag indicating what kind of number the string is. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumFlag = IsStringNumber('123a31')                        ! return -1 <br>
  ---&gt;    NumFlag = IsStringNumber('123')                           ! return 0 <br>
  ---&gt;    NumFlag = IsStringNumber('1.23')                          ! return 0 <br>
  ---&gt;    NumFlag = IsStringNumber('123', Strict=.TRUE.)            ! return 1 <br>
  ---&gt;    NumFlag = IsStringNumber('1.23', Strict=.TRUE.)           ! return 2 <br>
  ---&gt;    NumFlag = IsStringNumber('(123, 456)')                    ! return 3 <br>
  ---&gt;    NumFlag = IsStringNumber('(12.3, 4.56)', NumVal=CmplxNum) ! return 3 and also get number <br>
 <strong>Technical Notes</strong>: <br>
  A (strict) integer number is a whole number with no decimal point.
  It can have a leading sign and is interpreted as a decimal number.
  It takes a general form of [s]n[n...] where <br>
  - s is a sign; required if negative (-), optional if positive (+). <br>
  - n is a decimal digit (0 through 9). <br>
  A (strict) real number is a number with decimal point or an exponent part.
  The general form of a real number with no exponent part is [s]n[n...] and
  a real number with an exponent part has a general form of [s]n[n...]E[s]nn...
  where  <br>
  - s is a sign; required if negative (-), optional if positive (+). <br>
  - n is a decimal digit (0 through 9). A decimal point must appear if
    the real number has no exponent part. <br>
  - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. <br>
  A complex number is a pair of real or integer numbers, separated by a comma,
  and enclosed in parentheses.  The first number represents the real part and
  the second number represents the imaginary part.</p></td></tr>
			   <tr><td><a href='../interface/iszero.html'>IsZero</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsZero <br>
 <strong>Purpose</strong>:  To check whether the ApInt32 number has value of zero or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsZero(ApNum) <br>
  ---&gt;    IF (IsZero(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/iszero~2.html'>IsZero</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsZero <br>
 <strong>Purpose</strong>:  To check whether the input value is zero or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsZero(INPUT) <br>
  ---&gt;    IF (IsZero(INPUT)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/iszero~3.html'>IsZero</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsZero <br>
 <strong>Purpose</strong>:  To check whether the ApInt64 number has value of zero or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsZero(ApNum) <br>
  ---&gt;    IF (IsZero(ApNum)) DoSomeThing</p></td></tr>
			   <tr><td><a href='../interface/javarank.html'>JavaRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/javasort.html">JavaSort</a> interface
  for the technical information of the <em>JavaSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/javasort.html'>JavaSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>JavaSort</em> algorithm is a hybrid algorithm based on Java's sorting
  algorithm [1].  The algorithm employs the dual-pivot quicksort as the
  main algorithm.  The algorithm is a variant of the <em>IntroSort</em> algorithm
  where the heapsort algorithm is used when the recursion depth exceeds its
  limit and the mixed insertion sort algorithm is utilized when the number
  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,
  the <em>JavaSort</em> algorithm (with a routine that inspects the pattern of the
  specified array) employs a variant of the mergesort algorithm (a merging of
  runs) if the given array is found to be highly structured. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/javasort~2.html'>JavaSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>JavaSort</em> algorithm is a hybrid algorithm based on Java's sorting
  algorithm [1].  The algorithm employs the dual-pivot quicksort as the
  main algorithm.  The algorithm is a variant of the <em>IntroSort</em> algorithm
  where the heapsort algorithm is used when the recursion depth exceeds its
  limit and the mixed insertion sort algorithm is utilized when the number
  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,
  the <em>JavaSort</em> algorithm (with a routine that inspects the pattern of the
  specified array) employs a variant of the mergesort algorithm (a merging of
  runs) if the given array is found to be highly structured. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/juliandate.html'>JulianDate</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: JulianDate <br>
<strong>Purpose</strong>:  To find the appropriate Julian Day value for the given month and day. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Date = JulianDate(DayOfMonth, Month) <br>
  ---&gt;    Date = JulianDate(DayOfMonth, Month, 1) ! leap year set to 1 <br></p></td></tr>
			   <tr><td><a href='../interface/komi_hash64_exp.html'>Komi_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/komi_hash64_opt.html'>Komi_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/komihash_i64.html'>KomiHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/kpatopsi.html'>KPaToPsi</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert pressure from kPa to psi</p></td></tr>
			   <tr><td><a href='../proc/l_shift.html'>L_Shift</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To perform arithmetic/logical left shift. <br>
 Note: this is equivalent to the syntax "&lt;&lt;" in C or Java</p></td></tr>
			   <tr><td><a href='../interface/leadz.html'>LEADZ</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LEADZ <br>
 <strong>Purpose</strong>:  To count the number of leading zero bits of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumLZ = LEADZ(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/leadz~2.html'>LEADZ</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LEADZ <br>
 <strong>Purpose</strong>:  To count the number of leading zero bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumLZ = LEADZ(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/leadz~3.html'>LEADZ</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LEADZ <br>
 <strong>Purpose</strong>:  To count the number of leading zero bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumLZ = LEADZ(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/leadz~4.html'>LEADZ</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LEADZ <br>
 <strong>Purpose</strong>:  To count the number of leading zero bits of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumLZ = LEADZ(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/len_trim.html'>LEN_TRIM</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LEN_TRIM <br>
 <strong>Purpose</strong>:  To return length of the character string of a FvlStr object
      without counting trailing blank characters. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Length = LEN_TRIM(vStr) <br></p></td></tr>
			   <tr><td><a href='../interface/lge.html'>LGE</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LGE <br>
 <strong>Purpose</strong>:  To check whether LHS string is lexically greater than or equal
      to RHS string or not, based on the ASCII collating sequence, even if the
      compiler's default collating sequence is different. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LGE(LHS, RHS) <br>
  ---&gt;    IF (.NOT.LGE(LHS, RHS)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/lgt.html'>LGT</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LGT <br>
 <strong>Purpose</strong>:  To check whether LHS string is lexically greater than
      RHS string or not, based on the ASCII collating sequence, even
      if the compiler's default collating sequence is different. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LGT(LHS, RHS) <br>
  ---&gt;    IF (.NOT.LGT(LHS, RHS)) DoSomething</p></td></tr>
			   <tr><td><a href='../proc/limitvalue.html'>LimitValue</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To check if the value is in the specified range.  If not,
 limit its value to the specified upper or lower bound limit.</p></td></tr>
			   <tr><td><a href='../interface/lle.html'>LLE</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LLE <br>
 <strong>Purpose</strong>:  To check whether LHS string is lexically less than or equal
      to RHS string or not, based on the ASCII collating sequence, even if the
      compiler's default collating sequence is different. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LLE(LHS, RHS) <br>
  ---&gt;    IF (.NOT.LLE(LHS, RHS)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/llt.html'>LLT</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LLT <br>
 <strong>Purpose</strong>:  To check whether LHS string is lexically less than
      RHS string or not, based on the ASCII collating sequence, even
      if the compiler's default collating sequence is different. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LLT(LHS, RHS) <br>
  ---&gt;    IF (.NOT.LLT(LHS, RHS)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/log.html'>LOG</a></td><td><a href='../module/modbase_mathutil.html'>ModBase_MathUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LOG <br>
<strong>Purpose</strong>:  To compute the logarithm of the input for a specified base.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    LogVal = LOG(InVal, Base) <br></p></td></tr>
			   <tr><td><a href='../proc/logical_isequal.html'>Logical_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/lookup3_hash32_exp.html'>Lookup3_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/lookup3_hash32_opt.html'>Lookup3_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/lookup3hash_i32.html'>Lookup3Hash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/lowestonebit.html'>LowestOneBit</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: LowestOneBit <br>
 <strong>Purpose</strong>:  To return an integer value (same kind as the specified integer value) with at most
  a single one-bit, in the position of the lowest-order (rightmost) one-bit in the input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = LowestOneBit(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/lsdsort.html'>LSDSort</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: LSDSort <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the LSD
      string sorting algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL LSDSort(cStrArr) <br>
 <strong>Note</strong>: <br>
  This procedure is only applicable for Fortran character strings. <br></p></td></tr>
			   <tr><td><a href='../proc/machine_integer_parameter.html'>Machine_Integer_Parameter</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To return a integer machine dependent parameter
 depending on the specified index.</p></td></tr>
			   <tr><td><a href='../proc/machine_real_parameter.html'>Machine_Real_Parameter</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To return a floating point machine dependent parameter
 depending on the specified index.</p></td></tr>
			   <tr><td><a href='../interface/makecopy.html'>MakeCopy</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Copy <br>
 <strong>Purpose</strong>:  To make a copy of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ! make a copy of the ApInt32 number <br>
  ---&gt;    DstApNum = MakeCopy(SrcApNum) <br>
  ! make a copy of the ApInt32 number with the specified capacity
  (size of magnitude array) of the destination number <br>
  ---&gt;    DstApNum = MakeCopy(SrcApNum, DstCap)</p></td></tr>
			   <tr><td><a href='../interface/makecopy~2.html'>MakeCopy</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: Copy <br>
 <strong>Purpose</strong>:  To make a copy of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ! make a copy of the ApInt64 number <br>
  ---&gt;    DstApNum = MakeCopy(SrcApNum) <br>
  ! make a copy of the ApInt64 number with the specified capacity
  (size of magnitude array) of the destination number <br>
  ---&gt;    DstApNum = MakeCopy(SrcApNum, DstCap)</p></td></tr>
			   <tr><td><a href='../interface/max.html'>MAX</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MAX <br>
 <strong>Purpose</strong>:  To return the maximum value of the specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = MAX(INP1, INP2) <br>
  ---&gt;    OUTPUT = MAX(INPARR) <br></p></td></tr>
			   <tr><td><a href='../interface/max~2.html'>MAX</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MAX <br>
 <strong>Purpose</strong>:  To return the maximum value of the specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = MAX(INP1, INP2) <br>
  ---&gt;    OUTPUT = MAX(INPARR) <br></p></td></tr>
			   <tr><td><a href='../proc/maxvallocation.html'>MaxValLocation</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To find location of maximum value in an array.</p></td></tr>
			   <tr><td><a href='../interface/memalloc.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_integer.html'>ModBase_MemHandlers_Integer</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~2.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_complex.html'>ModBase_MemHandlers_Complex</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~3.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_logical.html'>ModBase_MemHandlers_Logical</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~4.html'>MemAlloc</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of the specified argument, which is declared as
      an unlimited polymorphic entity with <em>ALLOCATABLE</em>  attribute.  The specified
      argument can be a scalar argument or an array argument with the rank between
      1 and 7.  The procedure also requires the <em>Prototype</em> argument to be used as
      a mold or a source depending on the present of the optional <em>ASize</em> argument. <br>
 <strong>Usage</strong>: <br>
  ! allocate A using Prototype as a source <br>
  ---&gt;    CALL MemAlloc(A, Prototype) <br>
  ! allocate A using Prototype as a mold with starting indices of 1 <br>
  ---&gt;    CALL MemAlloc(A, Prototype, ASize) <br>
  ! allocate A using Prototype as a mold with specified starting indices <br>
  ---&gt;    CALL MemAlloc(A, Prototype, ASize, StartID) <br></p></td></tr>
			   <tr><td><a href='../interface/memalloc~5.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_keystore.html'>ModBase_MemHandlers_KeyStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, ArrMold, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, ArrMold, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, ArrMold, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, ArrMold, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~6.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_misc.html'>ModBase_MemHandlers_Misc</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory for allocatable components. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(UPar, 5, 2) <br>
  ---&gt;    CALL MemAlloc(EqText, 4, 5) <br>
  ---&gt;    CALL MemAlloc(WkSpace, 10, 10)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~7.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_genstore.html'>ModBase_MemHandlers_GenStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~8.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_comparable.html'>ModBase_MemHandlers_Comparable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, ArrMold, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, ArrMold, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, ArrMold, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, ArrMold, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~9.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_assignable.html'>ModBase_MemHandlers_Assignable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, ArrMold, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, ArrMold, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, ArrMold, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, ArrMold, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~10.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_character.html'>ModBase_MemHandlers_Character</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(48, Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(72, Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(48, Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(72, Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(48, Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(72, Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(72, Arr3D, 10, 10, 10, 0, 0, 0) <br></p></td></tr>
			   <tr><td><a href='../interface/memalloc~11.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_real.html'>ModBase_MemHandlers_Real</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../interface/memalloc~12.html'>MemAlloc</a></td><td><a href='../module/modbase_memhandlers_hashable.html'>ModBase_MemHandlers_Hashable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAlloc <br>
 <strong>Purpose</strong>:  To allocate memory of an array. <br>
 <strong>Note</strong>:  For optional starting ID(s), the default value is 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemAlloc(Arr1D, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr1D, 100, ArrMold, StartID=11) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 20, 10, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr2D, 100, 50, ArrMold, StartID1=21, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 50, 50, 50, ArrMold) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 20, 30, 40, ArrMold, StartID2=-10) <br>
  ---&gt;    CALL MemAlloc(Arr3D, 10, 10, 10, ArrMold, 0, 0, 0)</p></td></tr>
			   <tr><td><a href='../proc/memalloc_allocatable.html'>MemAlloc_Allocatable</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To allocate memory of an allocatable entity.</p></td></tr>
			   <tr><td><a href='../proc/memalloc_pointer.html'>MemAlloc_Pointer</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To allocate memory of an pointer entity.</p></td></tr>
			   <tr><td><a href='../interface/memallocptr.html'>MemAllocPtr</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemAllocPtr <br>
 <strong>Purpose</strong>:  To allocate memory of the specified argument, which is declared as
      an unlimited polymorphic entity with <em>POINTER</em>  attribute.  The specified
      argument can be a scalar argument or an array argument with the rank between
      1 and 7.  The procedure also requires the <em>Prototype</em> argument to be used as
      a mold or a source depending on the present of the optional <em>ASize</em> argument. <br>
 <strong>Usage</strong>: <br>
  ! allocate A using Prototype as a source <br>
  ---&gt;    CALL MemAllocPtr(A, Prototype) <br>
  ! allocate A using Prototype as a mold with starting indices of 1 <br>
  ---&gt;    CALL MemAllocPtr(A, Prototype, ASize) <br>
  ! allocate A using Prototype as a mold with specified starting indices <br>
  ---&gt;    CALL MemAllocPtr(A, Prototype, ASize, StartID) <br></p></td></tr>
			   <tr><td><a href='../interface/memfree.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_integer.html'>ModBase_MemHandlers_Integer</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~2.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_complex.html'>ModBase_MemHandlers_Complex</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~3.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_logical.html'>ModBase_MemHandlers_Logical</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~4.html'>MemFree</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of the specified argument, which is declared as
      an unlimited polymorphic entity with either <em>ALLOCATABLE</em> attribute. The
      specified argument can be a scalar argument or an array argument with
      any rank. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(A) <br></p></td></tr>
			   <tr><td><a href='../interface/memfree~5.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_keystore.html'>ModBase_MemHandlers_KeyStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~6.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_misc.html'>ModBase_MemHandlers_Misc</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of allocatable components. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(UPar) <br>
  ---&gt;    CALL MemFree(EqText) <br>
  ---&gt;    CALL MemFree(WkSpace)</p></td></tr>
			   <tr><td><a href='../interface/memfree~7.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_genstore.html'>ModBase_MemHandlers_GenStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~8.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_comparable.html'>ModBase_MemHandlers_Comparable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~9.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_assignable.html'>ModBase_MemHandlers_Assignable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~10.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_character.html'>ModBase_MemHandlers_Character</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~11.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_real.html'>ModBase_MemHandlers_Real</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../interface/memfree~12.html'>MemFree</a></td><td><a href='../module/modbase_memhandlers_hashable.html'>ModBase_MemHandlers_Hashable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an array. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFree(Arr1D) <br>
  ---&gt;    CALL MemFree(Arr2D) <br>
  ---&gt;    CALL MemFree(Arr3D)</p></td></tr>
			   <tr><td><a href='../proc/memfree_allocatable.html'>MemFree_Allocatable</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To free memory of an allocatable entity.</p></td></tr>
			   <tr><td><a href='../proc/memfree_pointer.html'>MemFree_Pointer</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To free memory of a pointer entity.</p></td></tr>
			   <tr><td><a href='../interface/memfreeptr.html'>MemFreePtr</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemFreePtr <br>
 <strong>Purpose</strong>:  To free memory of the specified argument, which is declared as
      an unlimited polymorphic entity with either <em>POINTER</em> attribute. The
      specified argument can be a scalar argument or an array argument with
      any rank. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemFreePtr(A) <br></p></td></tr>
			   <tr><td><a href='../interface/memresize.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_integer.html'>ModBase_MemHandlers_Integer</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~2.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_complex.html'>ModBase_MemHandlers_Complex</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~3.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_logical.html'>ModBase_MemHandlers_Logical</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~4.html'>MemResize</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To re-allocate memory of the specified argument (and preserve its data),
      which is declared as an unlimited polymorphic entity with <em>ALLOCATABLE</em> attribute.
      The specified argument must have already been allocated and it must be an array
      argument with the rank between 1 and 7.  The procedure requires the <em>NewSize</em>
      argument to specify sizes in each dimension of the entity.  It also requires a
      procedure to make a copy of the entity as an argument. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(A, NewSize, CopyProc) <br>
 <strong>Note</strong>: If the concrete type of the entity is one of Fortran intrinsic types, the user
      can use one of the auxiliary procedures (e.g. <em>CopyData_Integer</em> or <em>CopyData_Real</em>)
      provided in this <em>ModBase_PolyCommon</em> module.  If the type of the entity is a derived
      one, the user must provide a user-written routine for that specific derived type.</p></td></tr>
			   <tr><td><a href='../interface/memresize~5.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_keystore.html'>ModBase_MemHandlers_KeyStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~6.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_genstore.html'>ModBase_MemHandlers_GenStore</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~7.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_comparable.html'>ModBase_MemHandlers_Comparable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~8.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_assignable.html'>ModBase_MemHandlers_Assignable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~9.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_character.html'>ModBase_MemHandlers_Character</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~10.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_real.html'>ModBase_MemHandlers_Real</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../interface/memresize~11.html'>MemResize</a></td><td><a href='../module/modbase_memhandlers_hashable.html'>ModBase_MemHandlers_Hashable</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To reallocate memory for an array and preserve its data. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResize(Arr1D, 100) <br>
  ---&gt;    CALL MemResize(Arr2D, 20, 30) <br>
  ---&gt;    CALL MemResize(Arr3D, 50, 20, 100)</p></td></tr>
			   <tr><td><a href='../proc/memresize_allocatable.html'>MemResize_Allocatable</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To re-allocate memory of an allocatable entity and preserve its data.</p></td></tr>
			   <tr><td><a href='../proc/memresize_pointer.html'>MemResize_Pointer</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Subroutine</td><td><p>To re-allocate memory of an pointer entity and preserve its data.</p></td></tr>
			   <tr><td><a href='../interface/memresizeptr.html'>MemResizePtr</a></td><td><a href='../module/modbase_polymemhandlers.html'>ModBase_PolyMemHandlers</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MemResize <br>
 <strong>Purpose</strong>:  To re-allocate memory of the specified argument (and preserve its data),
      which is declared as an unlimited polymorphic entity with <em>POINTER</em> attribute.
      The specified argument must have already been allocated and it must be an array
      argument with the rank between 1 and 7.  The procedure requires the <em>NewSize</em>
      argument to specify sizes in each dimension of the entity.  It also requires a
      procedure to make a copy of the entity as an argument. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MemResizePtr(A, NewSize, CopyProc) <br>
 <strong>Note</strong>: If the concrete type of the entity is one of Fortran intrinsic types, the user
      can use one of the auxiliary procedures (e.g. <em>CopyData_Integer</em> or <em>CopyData_Real</em>)
      provided in this <em>ModBase_PolyCommon</em> module.  If the type of the entity is a derived
      one, the user must provide a user-written routine for that specific derived type.</p></td></tr>
			   <tr><td><a href='../interface/mergerankbottomup.html'>MergeRankBottomUp</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankBottomUp <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankBottomUp(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesortbottomup.html">MergeSortBottomUp</a>
  interface for the technical information of the <em>bottom-up merge sort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankhalfcopy.html'>MergeRankHalfCopy</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankHalfCopy <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm with <em>half-copying merge</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankHalfCopy(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesorthalfcopy.html">MergeSortHalfCopy</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm with <em>half-copying merge</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankorderpack.html'>MergeRankOrderPack</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankOrderPack <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>merge sort</em>
      algorithm based on the '<em>MrgRnk</em>' routine in the <em>OrderPack</em> 2.0
      library by Olagnon [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankOrderPack(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small arrays and the
  Orderpack's merge sort algorithm [1] is employed for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://www.fortran-2000.com/rank/">ORDERPACK 2.0: Unconditional,
      Unique, and Partial Ranking, Sorting, and Permutation Downloadable Fortran90
      source code. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankquadsplit.html'>MergeRankQuadSplit</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankQuadSplit <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankQuadSplit(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesortquadsplit.html">MergeSortQuadSplit</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm with quad split. <br></p></td></tr>
			   <tr><td><a href='../interface/mergeranktopdown.html'>MergeRankTopDown</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankTopDown <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankTopDown(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesorttopdown.html">MergeSortTopDown</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortbottomup.html'>MergeSortBottomUp</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortBottomUp <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortBottomUp(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortbottomup~2.html'>MergeSortBottomUp</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortBottomUp <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortBottomUp(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorthalfcopy.html'>MergeSortHalfCopy</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortHalfCopy <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a fast
      <em>mergesort</em> algorithm based on <em>half-copying merge</em> algorithm
      by C. Juszczak [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortHalfCopy(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm with a <em>half-copying</em> merging [1]
  is employed for large (sub)array(s).  The algorithm also considers
  other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf">
      Juszczak, C. 2007.  Fast mergesort implementation based on half-copying
      merge algorithm. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorthalfcopy~2.html'>MergeSortHalfCopy</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortHalfCopy <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a fast
      <em>mergesort</em> algorithm based on <em>half-copying merge</em> algorithm
      by C. Juszczak [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortHalfCopy(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm with a <em>half-copying</em> merging [1]
  is employed for large (sub)array(s).  The algorithm also considers
  other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf">
      Juszczak, C. 2007.  Fast mergesort implementation based on half-copying
      merge algorithm. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortquadsplit.html'>MergeSortQuadSplit</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortQuadSplit <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortQuadSplit(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] with quad split.  The algorithm
  also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortquadsplit~2.html'>MergeSortQuadSplit</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortQuadSplit <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortQuadSplit(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] with quad split.  The algorithm
  also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorttopdown.html'>MergeSortTopDown</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortTopDown <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortTopDown(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] is employed for large (sub)array(s).
  The algorithm also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorttopdown~2.html'>MergeSortTopDown</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortTopDown <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortTopDown(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] is employed for large (sub)array(s).
  The algorithm also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/metro_hash64_exp.html'>Metro_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/metro_hash64_opt.html'>Metro_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/metrohash_i64.html'>MetroHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/min.html'>MIN</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MIN <br>
 <strong>Purpose</strong>:  To return the minimum value of the specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = MIN(INP1, INP2) <br>
  ---&gt;    OUTPUT = MIN(INPARR) <br></p></td></tr>
			   <tr><td><a href='../interface/min~2.html'>MIN</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MIN <br>
 <strong>Purpose</strong>:  To return the minimum value of the specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = MIN(INP1, INP2) <br>
  ---&gt;    OUTPUT = MIN(INPARR) <br></p></td></tr>
			   <tr><td><a href='../interface/minmax.html'>MinMax</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MinMax <br>
<strong>Purpose</strong>:  To compare values and return the minimum and maximum values. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MinMax(AVal, BVal, MinVal, MaxVal) <br>
  ---&gt;    CALL MinMax(Array, MinVal, MaxVal) <br></p></td></tr>
			   <tr><td><a href='../interface/mirhash_i64.html'>MirHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/mix_lea.html'>Mix_Lea</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To compute Doug Lea's mixing function.</p></td></tr>
			   <tr><td><a href='../interface/mix_murmur.html'>Mix_Murmur</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td><p>To compute the mixing function of the MurmurHash3 hash function.</p></td></tr>
			   <tr><td><a href='../interface/mix_stafford_13.html'>Mix_Stafford_13</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/mod.html'>MOD</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MOD <br>
 <strong>Purpose</strong>:  To return the remainder of a division of two signed integers,
               where the dividend (numerator) is a ApInt32 number and the
               divisor (denominator) can be any signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Remainder = MOD(Dividend, Divisor)</p></td></tr>
			   <tr><td><a href='../interface/mod~2.html'>MOD</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MOD <br>
 <strong>Purpose</strong>:  To return the remainder of a division of two signed integers,
  where the dividend (numerator) is a 128-bit signed integer and the
  divisor (denominator) can be 32-, 64- or 128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    REM = MOD(NUMER, DENOM)</p></td></tr>
			   <tr><td><a href='../interface/mod~3.html'>MOD</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MOD <br>
 <strong>Purpose</strong>:  To return the remainder of a division of two signed integers,
               where the dividend (numerator) is a ApInt64 number and the
               divisor (denominator) can be any signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Remainder = MOD(Dividend, Divisor)</p></td></tr>
			   <tr><td><a href='../interface/modulo.html'>MODULO</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MODULO <br>
 <strong>Purpose</strong>:  To compute the modulo of two ApInt32 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Modulo = MODULO(Dividend, Divisor)</p></td></tr>
			   <tr><td><a href='../interface/modulo~2.html'>MODULO</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MODULO <br>
 <strong>Purpose</strong>:  To compute the modulo of two ApInt64 numbers. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Modulo = MODULO(Dividend, Divisor)</p></td></tr>
			   <tr><td><a href='../interface/modxp.html'>ModXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ModXp <br>
 <strong>Purpose</strong>:  To perform modulation: Remainder = Dividend Mod Divisor. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Remainder = ModXp(Dividend, Divisor, Algorithm) <br>
 <strong>Note</strong>: Algorithm must be between 1 and 5.</p></td></tr>
			   <tr><td><a href='../interface/movebits.html'>MoveBits</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MoveBits <br>
 <strong>Purpose</strong>:  To copy a sequence of bits (a bit field) from one location to another.
  (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS'.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos)</p></td></tr>
			   <tr><td><a href='../interface/movebits~2.html'>MoveBits</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MoveBits <br>
 <strong>Purpose</strong>:  To copy a sequence of bits (a bit field) from one location to another.
  (For more information, see detailed explanation of the intrinsic subroutine 'MVBITS'.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MoveBits(InVal, InPos, Len, OutVal, OutPos)</p></td></tr>
			   <tr><td><a href='../proc/mpfun_init.html'>MPFun_Init</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Subroutine</td><td><p>To initialize the MPFUN library.</p></td></tr>
			   <tr><td><a href='../interface/msdinplacesort.html'>MSDInplaceSort</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MSDInplaceSort <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the
      in-place MSD string sorting algorithm.  Optionally, if all characters
      of the strings are in a particular alphabet set, a user can specify an
      <em>Alphabet</em> data type of that particular alphabet set. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MSDInplaceSort(Arr) <br>
  ---&gt;    CALL MSDInplaceSort(Arr, Alphabet) <br>
 <strong>Usage</strong>: See the <a href="../module/class_alphabets.html">Class_Alphabets</a>
      module for various <em>alphabet</em> data types available to be used with the
      <em>MSDInplaceSort</em> procedure.</p></td></tr>
			   <tr><td><a href='../interface/msdsort.html'>MSDSort</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MSDSort <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the MSD
      string sorting algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MSDSort(Arr) <br></p></td></tr>
			   <tr><td><a href='../interface/multiply.html'>Multiply</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Multiply <br>
 <strong>Purpose</strong>:  To perform multiplication: This = This * Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Multiply(This, Other)</p></td></tr>
			   <tr><td><a href='../interface/multiply~2.html'>Multiply</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Multiply <br>
 <strong>Purpose</strong>:  To perform multiplication: This = This * Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Multiply(This, Other)</p></td></tr>
			   <tr><td><a href='../interface/multiplyxp.html'>MultiplyXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: MultiplyXp <br>
 <strong>Purpose</strong>:  To perform a multiplication: OutVal = LhsVal * RhsVal. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutVal = MultiplyXp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) <br>
 <strong>Note</strong>: Algorithm must be between 1 and 6.</p></td></tr>
			   <tr><td><a href='../interface/mulxp.html'>MulXp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/mumhash_i64.html'>MumHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3_hash128_exp.html'>Murmur3_Hash128_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3_hash128_opt.html'>Murmur3_Hash128_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3_hash32_exp.html'>Murmur3_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3_hash32_opt.html'>Murmur3_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3hash_i128.html'>Murmur3Hash_I128</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/murmur3hash_i32.html'>Murmur3Hash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/mx3hash_i64.html'>Mx3Hash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nm_hash32_exp.html'>NM_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nm_hash32_opt.html'>NM_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmhash_v1_i32.html'>NMHash_V1_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmhash_v2_i32.html'>NMHash_V2_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmx_hash32_exp.html'>NMx_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmx_hash32_opt.html'>NMx_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmxhash_v1_i32.html'>NMxHash_V1_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/nmxhash_v2_i32.html'>NMxHash_V2_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/not.html'>NOT</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: NOT <br>
 <strong>Purpose</strong>:  To return the bitwise logical complement an ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = NOT(NumIn)</p></td></tr>
			   <tr><td><a href='../interface/not~2.html'>NOT</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: NOT <br>
 <strong>Purpose</strong>:  To return the bitwise logical complement of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = NOT(IN)</p></td></tr>
			   <tr><td><a href='../interface/not~3.html'>NOT</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: NOT <br>
 <strong>Purpose</strong>:  To return the bitwise logical complement of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = NOT(IN)</p></td></tr>
			   <tr><td><a href='../interface/not~4.html'>NOT</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: NOT <br>
 <strong>Purpose</strong>:  To return the bitwise logical complement an ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = NOT(NumIn)</p></td></tr>
			   <tr><td><a href='../interface/notinrange.html'>NotInRange</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: NotInRange <br>
<strong>Purpose</strong>:  To check if the value is in the specified range or not.
      Return true if it is NOT.  Otherwise, return false. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = NotInRange(Val, UppLimit, LowLimit) <br>
  ---&gt;    IF (.NOT.NotInRange(Val, UppLimit, LowLimit)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/oneapint32.html'>OneApInt32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/oneapint64.html'>OneApInt64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/openfile.html'>OpenFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To open a file associated with the specified name for both reading and writing.
  A valid (positive) unit number is return if the specified file is opened successfully.
  Otherwise, it is set to -1. <br>
------------------------------------------------------------------------------ <br>
<strong>Important note</strong>: <br>
  Using this routine requires a careful consideration
  according to the technical notes below. <br>
------------------------------------------------------------------------------ <br>
<strong>Technical Notes</strong>: <br>
(1) If the specified file does not exists, a new file will be opened and
  the argument Append is ignored. <br>
(2) If the specified file exists and currently is open, all optional arguments
  are ignored and the unit number associated with it will be returned. <br>
(3) If the specified file exists (but is not open) and Append is not present,
  the existing file will be open with "AsIs" position.  Both DirAcc and RecLen arguments
  are ignored since, for an existing file, existing access mode and format will be retained. <br>
(4) If the specified file exists (but is not open) and Append is present and true,
  the existing file will be opened with "Append" position. Both DirAcc and RecLen arguments
  are ignored since, for an existing file, existing access mode and format will be retained. <br>
(5) If the specified file exists (but is not open) and Append is present and false,
  the existing file will be deleted and a file with the same name will be open as a
  new file. That is the existing one is replaced by the new one. <br>
(5.1) However, If DirAcc is present and true but RecLen is NOT specified, the existing
  file will be left as it is, and the unit number is set to -1.</p></td></tr>
			   <tr><td><a href='../proc/openinputfile.html'>OpenInputFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To open a file associated with the specified name for reading.
 A valid (positive) unit number is return if the specified file
 is opened successfully.  Otherwise, it is set to -1.</p></td></tr>
			   <tr><td><a href='../proc/opennewfile.html'>OpenNewFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To open a new file associated with the specified name for both reading and writing.
 A valid (positive) unit number is return if the specified file is opened successfully.
 Otherwise, it is set to -1.</p></td></tr>
			   <tr><td><a href='../proc/opennewoutputfile.html'>OpenNewOutputFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To open a new file associated with the specified name for writing.
 A valid (positive) unit number is return if the specified file
 is opened successfully.  Otherwise, it is set to -1.</p></td></tr>
			   <tr><td><a href='../proc/openoutputfile.html'>OpenOutputFile</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Function</td><td><p>To open a file associated with the specified name for writing.
  A valid (positive) unit number is return if the specified file
  is opened successfully.  Otherwise, it is set to -1. <br>
------------------------------------------------------------------------------ <br>
<strong>Important note</strong>: <br>
  Using this routine requires a careful consideration
  according to the technical notes below. <br>
------------------------------------------------------------------------------ <br>
<strong>Technical Notes</strong>: <br>
(1) If the specified file does not exists, a new output file will be opened and
  the argument Append is ignored. <br>
(2) If the specified file exists and currently is open, all optional arguments
  are ignored and the unit number associated with it will be returned. <br>
(3) If the specified file exists (but is not open) and Append is not present or false,
  the existing file will be deleted and a file with the same name will be open as a
  new output file. That is the existing one is replaced by the new one. <br>
(3.1) However, If DirAcc is present and true but RecLen is NOT specified, the existing
  file will be left as it is, and the unit number is set to -1. <br>
(4) If the specified file exists (but is not open) and Append is present and true,
  the existing file will be opened for writing where the new data are written after
  existing data. Both DirAcc and RecLen arguments are ignored since, for an existing
  file, existing access mode and format will be retained.</p></td></tr>
			   <tr><td><a href='../interface/operator (.udiv.).html'>OPERATOR (.UDIV.)</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UDIV.) <br>
 <strong>Purpose</strong>:  To return the quotient of a division of two unsigned integers,
  where both input and an output have the same kind <br>
 <strong>Usage</strong>: <br>
  ---&gt;    QUOT = NUMER .UDIV. DENOM</p></td></tr>
			   <tr><td><a href='../interface/operator (.uge.).html'>OPERATOR (.UGE.)</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UGE.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value <br>
  return .TRUE. if LHS &gt;= RHS; otherwise return .FALSE. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .UGE. RHS <br>
  ---&gt;    IF (LHS .UGE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator (.ugt.).html'>OPERATOR (.UGT.)</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UGT.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value <br>
  return .TRUE. if LHS &gt; RHS; otherwise return .FALSE. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .UGT. RHS <br>
  ---&gt;    IF (LHS .UGT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator (.ule.).html'>OPERATOR (.ULE.)</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.ULE.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value <br>
  return .TRUE. if LHS &lt;= RHS; otherwise return .FALSE. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .ULE. RHS <br>
  ---&gt;    IF (LHS .ULE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator (.ult.).html'>OPERATOR (.ULT.)</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.ULT.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value <br>
  return .TRUE. if LHS &lt; RHS; otherwise return .FALSE. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .ULT. RHS <br>
  ---&gt;    IF (LHS .ULT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(.html'>OPERATOR(</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR('//') <br>
 <strong>Purpose</strong>:  To concatenate the first and second strings. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = Str1st '//' Str2nd <br></p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISK).html'>OPERATOR(*)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( * ) <br>
 <strong>Purpose</strong>:  To perform a multiplication of two signed integers (at least one
               of which is a ApInt32 number). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = InNum1 * InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISK)~2.html'>OPERATOR(*)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( * ) <br>
 <strong>Purpose</strong>:  To perform a multiplication of two signed integers
  (at least one of which is a 128-bit signed integer). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = FIRST_IN * SECOND_IN</p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISK)~3.html'>OPERATOR(*)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( * ) <br>
 <strong>Purpose</strong>:  To perform a multiplication of two unsigned integers
  (at least one of which is a 128-bit unsigned integer). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = FIRST_IN * SECOND_IN</p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISK)~4.html'>OPERATOR(*)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( * ) <br>
 <strong>Purpose</strong>:  To perform a multiplication of two signed integers (at least one
               of which is a ApInt64 number). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = InNum1 * InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISKASTERISK).html'>OPERATOR(**)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( ** ) <br>
 <strong>Purpose</strong>:  To perform an exponentiation of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = NumIn**Exp</p></td></tr>
			   <tr><td><a href='../interface/operator(ASTERISKASTERISK)~2.html'>OPERATOR(**)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR( ** ) <br>
 <strong>Purpose</strong>:  To perform an exponentiation of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = NumIn**Exp</p></td></tr>
			   <tr><td><a href='../interface/operator(+).html'>OPERATOR(+)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(+) <br>
 <strong>Purpose</strong>:  To perform a summation of two signed integers (at least one
               of which is a ApInt32 number) or to add a unary plus sign
               to a ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = +InNum <br>
  ---&gt;    OutNum = InNum1 + InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(+)~2.html'>OPERATOR(+)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(+) <br>
 <strong>Purpose</strong>:  To perform a summation of two signed integers
  (at least one of which is a 128-bit signed integer) or
  to add a unary plus sign to a 128-bit signed integer
  (which has no effect on the signed integer). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = +INPUT <br>
  ---&gt;    OUTPUT = FIRST_IN + SECOND_IN</p></td></tr>
			   <tr><td><a href='../interface/operator(+)~3.html'>OPERATOR(+)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(+) <br>
 <strong>Purpose</strong>:  To perform a summation of two unsigned integers
  (at least one of which is a 128-bit unsigned integer) or
  to add a unary plus sign to a 128-bit unsigned integer
  (which has no effect on the unsigned integer). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = +INPUT <br>
  ---&gt;    OUTPUT = FIRST_IN + SECOND_IN</p></td></tr>
			   <tr><td><a href='../interface/operator(+)~4.html'>OPERATOR(+)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(+) <br>
 <strong>Purpose</strong>:  To concatenate the first and second strings. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = Str1st + Str2nd <br></p></td></tr>
			   <tr><td><a href='../interface/operator(+)~5.html'>OPERATOR(+)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(+) <br>
 <strong>Purpose</strong>:  To perform a summation of two signed integers (at least one
               of which is a ApInt64 number) or to add a unary plus sign
               to a ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = +InNum <br>
  ---&gt;    OutNum = InNum1 + InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(-).html'>OPERATOR(-)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(-) <br>
 <strong>Purpose</strong>:  To perform a subtraction of two signed integers (at least one
               of which is a ApInt32 number) or to negate a ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = -InNum <br>
  ---&gt;    OutNum = InNum1 - InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(-)~2.html'>OPERATOR(-)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(-) <br>
 <strong>Purpose</strong>:  To perform a subtraction of two signed integers
  (at least one of which is a 128-bit signed integer) or
  to perform a negation of a 128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = -INPUT <br>
  ---&gt;    OUTPUT = FIRST_IN - SECOND_IN <br>
 <strong>Important Note</strong>:  For subtraction of signed integers (unlike unsigned one),
  value of FIRST_IN can be less than SECOND_IN.</p></td></tr>
			   <tr><td><a href='../interface/operator(-)~3.html'>OPERATOR(-)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(-) <br>
 <strong>Purpose</strong>:  To perform a subtraction of two unsigned integers
  (at least one of which is a 128-bit unsigned integer) or
  to perform a negation of a 128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = -INPUT <br>
  ---&gt;    OUTPUT = FIRST_IN - SECOND_IN <br>
 <strong>Important Note</strong>:  For subtraction of unsigned integers, value of
  FIRST_IN must always be greater than SECOND_IN.  Otherwise, value of
  OUTPUT is NOT valid.</p></td></tr>
			   <tr><td><a href='../interface/operator(-)~4.html'>OPERATOR(-)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(-) <br>
 <strong>Purpose</strong>:  To perform a subtraction of two signed integers (at least one
               of which is a ApInt64 number) or to negate a ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutNum = -InNum <br>
  ---&gt;    OutNum = InNum1 - InNum2</p></td></tr>
			   <tr><td><a href='../interface/operator(.udiv.).html'>OPERATOR(.UDIV.)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UDIV.) <br>
 <strong>Purpose</strong>:  To return the quotient of a division of two unsigned integers,
  where the dividend (numerator) is a 128-bit unsigned integer and the
  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    QUOT = NUMER .UDIV. DENOM</p></td></tr>
			   <tr><td><a href='../interface/operator(.uge.).html'>OPERATOR(.UGE.)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UGE.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value.
  Return .TRUE. if LHS &gt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .UGE. RHS <br>
  ---&gt;    IF (LHS .UGE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(.ugt.).html'>OPERATOR(.UGT.)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.UGT.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value.
  Return .TRUE. if LHS &gt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .UGT. RHS <br>
  ---&gt;    IF (LHS .UGT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(.ule.).html'>OPERATOR(.ULE.)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.ULE.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value.
  Return .TRUE. if LHS &lt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .ULE. RHS <br>
  ---&gt;    IF (LHS .ULE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(.ult.).html'>OPERATOR(.ULT.)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(.ULT.) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value.
  Return .TRUE. if LHS &lt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS .ULT. RHS <br>
  ---&gt;    IF (LHS .ULT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH).html'>OPERATOR(/)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/) <br>
 <strong>Purpose</strong>:  To return the quotient of a division of two signed integers,
               where the dividend (numerator) is a ApInt32 number and the
               divisor (denominator) can be any signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Quotient = Dividend / Divisor</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH)~2.html'>OPERATOR(/)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/) <br>
 <strong>Purpose</strong>:  To return the quotient of a division of two signed integers,
  where the dividend (numerator) is a 128-bit signed integer and the
  divisor (denominator) can be 32-, 64- or 128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    QUOT = NUMER / DENOM</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH)~3.html'>OPERATOR(/)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/) <br>
 <strong>Purpose</strong>:  To return the quotient of a division of two signed integers,
               where the dividend (numerator) is a ApInt64 number and the
               divisor (denominator) can be any signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Quotient = Dividend / Divisor</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH=).html'>OPERATOR(/=)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check if values of two ApInt32 numbers are NOT equal.
  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS .NE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH=)~2.html'>OPERATOR(/=)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check if values of two 128-bit signed integers are not equal.
  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS .NE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH=)~3.html'>OPERATOR(/=)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check if values of two 128-bit unsigned integers are not equal.
  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS .NE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH=)~4.html'>OPERATOR(/=)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check whether two strings are NOT equal or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS .NE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(SLASH=)~5.html'>OPERATOR(/=)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check if values of two ApInt64 numbers are NOT equal.
  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS .NE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt).html'>OPERATOR(<)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value.
  Return .TRUE. if LHS &lt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt; RHS <br>
  ---&gt;    IF (LHS .LT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt)~2.html'>OPERATOR(<)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value.
  Return .TRUE. if LHS &lt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt; RHS <br>
  ---&gt;    IF (LHS .LT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt)~3.html'>OPERATOR(<)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;) <br>
 <strong>Purpose</strong>:  To check whether LHS string is less than RHS string or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt; RHS <br>
  ---&gt;    IF (LHS .LT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt)~4.html'>OPERATOR(<)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value.
  Return .TRUE. if LHS &lt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt; RHS <br>
  ---&gt;    IF (LHS .LT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt=).html'>OPERATOR(<=)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value.
  Return .TRUE. if LHS &lt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt;= RHS <br>
  ---&gt;    IF (LHS .LE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt=)~2.html'>OPERATOR(<=)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value.
  Return .TRUE. if LHS &lt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt;= RHS <br>
  ---&gt;    IF (LHS .LE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt=)~3.html'>OPERATOR(<=)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;=) <br>
 <strong>Purpose</strong>:  To check whether LHS string is less than or equal to
      RHS string or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt;= RHS <br>
  ---&gt;    IF (LHS .LE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(lt=)~4.html'>OPERATOR(<=)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&lt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value.
  Return .TRUE. if LHS &lt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt;= RHS <br>
  ---&gt;    IF (LHS .LE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(==).html'>OPERATOR(==)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check if values of two ApInt32 numbers are equal.
  Return .TRUE. if both values are equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS .EQ. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(==)~2.html'>OPERATOR(==)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check if values of two 128-bit signed integers are equal.
  Return .TRUE. if both values are equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS .EQ. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(==)~3.html'>OPERATOR(==)</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check if values of two 128-bit unsigned integers are equal.
  Return .TRUE. if both values are equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS .EQ. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(==)~4.html'>OPERATOR(==)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check whether two strings are equal or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS .EQ. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(==)~5.html'>OPERATOR(==)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check if values of two ApInt64 numbers are equal.
  Return .TRUE. if both values are equal; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS .EQ. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt).html'>OPERATOR(>)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value.
  Return .TRUE. if LHS &gt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt; RHS <br>
  ---&gt;    IF (LHS .GT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt)~2.html'>OPERATOR(>)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value.
  Return .TRUE. if LHS &gt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt; RHS <br>
  ---&gt;    IF (LHS .GT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt)~3.html'>OPERATOR(>)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;) <br>
 <strong>Purpose</strong>:  To check whether LHS string is greater than RHS string or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt; RHS <br>
  ---&gt;    IF (LHS .GT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt)~4.html'>OPERATOR(>)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value.
  Return .TRUE. if LHS &gt; RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt; RHS <br>
  ---&gt;    IF (LHS .GT. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt=).html'>OPERATOR(>=)</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value.
  Return .TRUE. if LHS &gt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt;= RHS <br>
  ---&gt;    IF (LHS .GE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt=)~2.html'>OPERATOR(>=)</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value.
  Return .TRUE. if LHS &gt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt;= RHS <br>
  ---&gt;    IF (LHS .GE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt=)~3.html'>OPERATOR(>=)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;=) <br>
 <strong>Purpose</strong>:  To check whether LHS string is greater than or equal to
      RHS string or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt;= RHS <br>
  ---&gt;    IF (LHS .GE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/operator(gt=)~4.html'>OPERATOR(>=)</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Operator Overload</strong>: OPERATOR(&gt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value.
  Return .TRUE. if LHS &gt;= RHS; otherwise return .FALSE.. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt;= RHS <br>
  ---&gt;    IF (LHS .GE. RHS) DoSomething</p></td></tr>
			   <tr><td><a href='../proc/output_message.html'>Output_Message</a></td><td><a href='../module/modbase_io_handlers.html'>ModBase_IO_Handlers</a></td><td>Subroutine</td><td><p>To display the specified message on default output (an audit file) or the
  indicated file unit number if specified.</p></td></tr>
			   <tr><td><a href='../proc/pack_i16_a1.html'>Pack_I16_A1</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a2.html'>Pack_I16_A2</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a3.html'>Pack_I16_A3</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a4.html'>Pack_I16_A4</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a5.html'>Pack_I16_A5</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a6.html'>Pack_I16_A6</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i16_a7.html'>Pack_I16_A7</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../proc/pack_i32_a1.html'>Pack_I32_A1</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>SHIFTL</em> and <em>IOR</em> intrinsic
 functions.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a2.html'>Pack_I32_A2</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>SHIFTL</em> intrinsic function
 and an addition operator.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a3.html'>Pack_I32_A3</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>SHIFTL</em> and <em>IOR</em> intrinsic
 functions. <br>
 <em>Note</em>: Although this routine and the <em>Pack_I32_A3</em> routine employ
 the same intrinsic functions, orders of the functions being used
 are somewhat different.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a4.html'>Pack_I32_A4</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>MVBITS</em> intrinsic subroutine.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a5.html'>Pack_I32_A5</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>TRANSFER</em> intrinsic function.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a6.html'>Pack_I32_A6</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>C_LOC</em> and <em>C_F_POINTER</em>
 intrinsic module routines. <br>
 <em>Note</em>:  This routine works best for system-endian order.</p></td></tr>
			   <tr><td><a href='../proc/pack_i32_a7.html'>Pack_I32_A7</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Function</td><td><p>To convert an array of 8-bit integers starting at the offset to
 a 32-bit integer value using the <em>EQUIVALENCE</em> statement. <br>
 <em>Note</em>:  This routine works best for system-endian order.</p></td></tr>
			   <tr><td><a href='../interface/parsebyte.html'>ParseByte</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseByte <br>
 <strong>Purpose</strong>:  To parse a character string as a 8-bit integer number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IntNum = ParseByte(cStr) <br>
  ---&gt;    IntNum = ParseByte(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parsecdouble.html'>ParseCDouble</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseCDouble <br>
 <strong>Purpose</strong>:  To parse a character string as a double-precision complex number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CmpxNum = ParseCDouble(cStr) <br>
  ---&gt;    CmpxNum = ParseCDouble(cStr, ErrFlag, ErrMsg) <br>
 <strong>Note</strong>: A valid string representing a complex number consists of a pair of
           real-number (or integer-number) strings, separated by a comma, and
           enclosed in parentheses.</p></td></tr>
			   <tr><td><a href='../interface/parsecquad.html'>ParseCQuad</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseCQuad <br>
 <strong>Purpose</strong>:  To parse a character string as a quadruple-precision complex number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CmpxNum = ParseCQuad(cStr) <br>
  ---&gt;    CmpxNum = ParseCQuad(cStr, ErrFlag, ErrMsg) <br>
 <strong>Note</strong>: A valid string representing a complex number consists of a pair of
           real-number (or integer-number) strings, separated by a comma, and
           enclosed in parentheses.</p></td></tr>
			   <tr><td><a href='../interface/parsecsingle.html'>ParseCSingle</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseCSingle <br>
 <strong>Purpose</strong>:  To parse a character string as a single-precision complex number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CmpxNum = ParseCSingle(cStr) <br>
  ---&gt;    CmpxNum = ParseCSingle(cStr, ErrFlag, ErrMsg) <br>
 <strong>Note</strong>: A valid string representing a complex number consists of a pair of
           real-number (or integer-number) strings, separated by a comma, and
           enclosed in parentheses.</p></td></tr>
			   <tr><td><a href='../interface/parsei128xp.html'>ParseI128Xp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/parseinteger.html'>ParseInteger</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseInteger <br>
 <strong>Purpose</strong>:  To parse a character string as a 32-bit integer number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IntNum = ParseInteger(cStr) <br>
  ---&gt;    IntNum = ParseInteger(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parselogical.html'>ParseLogical</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseLogical <br>
 <strong>Purpose</strong>:  To parse a character string as a logical value. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Boolean = ParseLogical(cStr) <br></p></td></tr>
			   <tr><td><a href='../interface/parselong.html'>ParseLong</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseLong <br>
 <strong>Purpose</strong>:  To parse a character string as a 64-bit integer number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IntNum = ParseLong(cStr) <br>
  ---&gt;    IntNum = ParseLong(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parserdouble.html'>ParseRDouble</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseRDouble <br>
 <strong>Purpose</strong>:  To parse a character string as a double-precision real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    RealNum = ParseRDouble(cStr) <br>
  ---&gt;    RealNum = ParseRDouble(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parserquad.html'>ParseRQuad</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseRQuad <br>
 <strong>Purpose</strong>:  To parse a character string as a quadruple-precision real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    RealNum = ParseRQuad(cStr) <br>
  ---&gt;    RealNum = ParseRQuad(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parsersingle.html'>ParseRSingle</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseRSingle <br>
 <strong>Purpose</strong>:  To parse a character string as a single-precision real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    RealNum = ParseRSingle(cStr) <br>
  ---&gt;    RealNum = ParseRSingle(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parseshort.html'>ParseShort</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ParseShort <br>
 <strong>Purpose</strong>:  To parse a character string as a 16-bit integer number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IntNum = ParseShort(cStr) <br>
  ---&gt;    IntNum = ParseShort(cStr, ErrFlag, ErrMsg) <br></p></td></tr>
			   <tr><td><a href='../interface/parseu128xp.html'>ParseU128Xp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/partition~8.html'>Partition</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Partition <br>
 <strong>Purpose</strong>:  To partition a character string into two substrings by a
               separator (single character or a multiple-character string).
               The partition occurs at the first occurrence of the separator
               found. <br>
 <strong>Usage</strong>: <br>
  ! <em>SepSub</em> is a multiple-character string separator. <br>
  ---&gt;    CALL Partition(cStr, SepSub, bStr, aStr) <br>
  ! <em>SepSet</em> is a set of characters where a character in the set is a valid <br>
  ! separator.  Also, search the first separator from the back. <br>
  ---&gt;    CALL Partition(cStr, SepSet, bStr, aStr, SepChr, Back=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/pdqrank.html'>PDQRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/pdqsort.html">PDQSort</a> interface
  for the technical information of the <em>PDQSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/pdqsort.html'>PDQSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>PDQSort</em> (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm
  developed by Orson Peters [1].  The algorithm is a variant of the <em>IntroSort</em>
  algorithm with various improvements including median-of-three pivoting scheme,
  <em>BlockQuickSort</em> partitioning scheme to lesson the branch mis-prediction penalties,
  an adaptive sort to deals with an array with certain patterns, and a shuffling
  of array elements to help the heapsort works better. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://arxiv.org/abs/2106.05123">Peters, O.R.L. 2021.
      Pattern-defeating Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/pdqsort~2.html'>PDQSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>PDQSort</em> (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm
  developed by Orson Peters [1].  The algorithm is a variant of the <em>IntroSort</em>
  algorithm with various improvements including median-of-three pivoting scheme,
  <em>BlockQuickSort</em> partitioning scheme to lesson the branch mis-prediction penalties,
  an adaptive sort to deals with an array with certain patterns, and a shuffling
  of array elements to help the heapsort works better. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://arxiv.org/abs/2106.05123">Peters, O.R.L. 2021.
      Pattern-defeating Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/pengyhash_v02_i64.html'>PengyHash_V02_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pengyhash_v03_i64.html'>PengyHash_V03_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pengyv02_hash64_exp.html'>PengyV02_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pengyv02_hash64_opt.html'>PengyV02_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pengyv03_hash64_exp.html'>PengyV03_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/pengyv03_hash64_opt.html'>PengyV03_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/polyabsolute.html'>PolyAbsolute</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Function</td><td><p>To determine the absolute value of A.</p></td></tr>
			   <tr><td><a href='../interface/polyallocate.html'>PolyAllocate</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyAllocate <br>
 <strong>Purpose</strong>:  To allocate memory of the specified allocatable argument. <br></p></td></tr>
			   <tr><td><a href='../proc/polyallocatepointer.html'>PolyAllocatePointer</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To allocate memory of pointer.</p></td></tr>
			   <tr><td><a href='../proc/polyallocatepointer1d.html'>PolyAllocatePointer1D</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To allocate memory of pointer array.</p></td></tr>
			   <tr><td><a href='../proc/polyallocatepointer2d.html'>PolyAllocatePointer2D</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To allocate memory of pointer array.</p></td></tr>
			   <tr><td><a href='../interface/polyassign.html'>PolyAssign</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyAssign <br>
 <strong>Purpose</strong>:  To perform assignment of the specified argument. <br></p></td></tr>
			   <tr><td><a href='../proc/polycompare.html'>PolyCompare</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Function</td><td><p>To compare A and B.</p></td></tr>
			   <tr><td><a href='../proc/polycopydata.html'>PolyCopyData</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To make a copy of the input data.  The <em>OutData</em> and <em>InData</em> arguments must have the
 same sizes, ranks and types.</p></td></tr>
			   <tr><td><a href='../proc/polydivision.html'>PolyDivision</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To perform division: CVal = (Sign)AVal/BVal.</p></td></tr>
			   <tr><td><a href='../proc/polydot.html'>PolyDot</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To perform dot-product multiplication of the specified arguments.</p></td></tr>
			   <tr><td><a href='../interface/polyinvother.html'>PolyInvOther</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyInvOther <br>
 <strong>Purpose</strong>:  To perform an inversion of the specified argument. <br></p></td></tr>
			   <tr><td><a href='../interface/polyinvself.html'>PolyInvSelf</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyInvSelf <br>
 <strong>Purpose</strong>:  To perform an inversion of the specified argument. <br></p></td></tr>
			   <tr><td><a href='../proc/polylogarithm.html'>PolyLogarithm</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To determine the natural logarithm of AVAl or any logarithm if the base
 is specified.  Return the logarithmic value in BVal.</p></td></tr>
			   <tr><td><a href='../interface/polynegate.html'>PolyNegate</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyNegate <br>
 <strong>Purpose</strong>:  To perform negation of the specified argument. <br></p></td></tr>
			   <tr><td><a href='../proc/polynorm2.html'>PolyNorm2</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Function</td><td><p>To determine the Euclidean norm of the specified argument.</p></td></tr>
			   <tr><td><a href='../interface/polyproduct.html'>PolyProduct</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyProduct <br>
 <strong>Purpose</strong>:  To perform multiplication: CVal = (Sign)(AVal*BVal). <br></p></td></tr>
			   <tr><td><a href='../interface/polyresize.html'>PolyResize</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyResize <br>
 <strong>Purpose</strong>:  To re-allocate memory of the specified allocatable argument and
      preserve its data. <br></p></td></tr>
			   <tr><td><a href='../proc/polyresizepointer1d.html'>PolyResizePointer1D</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To re-allocate pointer array and preserve data.</p></td></tr>
			   <tr><td><a href='../proc/polyresizepointer2d.html'>PolyResizePointer2D</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To re-allocate pointer array and preserve data.</p></td></tr>
			   <tr><td><a href='../interface/polyscaleadd.html'>PolyScaleAdd</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyScaleAdd <br>
 <strong>Purpose</strong>:  To perform scaling and addition of one of the followings: <br>
      1. AVal = Alpha<em>(ASign)AVal + Beta</em>(BSign)BVal, or <br>
      2. AVal =       (ASign)AVal + Beta<em>(BSign)BVal, or <br>
      3. AVal = Alpha</em>(ASign)AVal +      (BSign)BVal, or <br>
      4. AVal =       (ASign)AVal +      (BSign)BVal. <br></p></td></tr>
			   <tr><td><a href='../interface/polyscalearray.html'>PolyScaleArray</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyScaleArray <br>
 <strong>Purpose</strong>:  To perform scaling of one of the followings: <br>
      1. AVal = Alpha<em>(Sign)AVal, or <br>
      2. BVal = Alpha</em>(Sign)AVal. <br></p></td></tr>
			   <tr><td><a href='../proc/polyscaleother.html'>PolyScaleOther</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To perform scaling: BVal = Alpha*(Sign)AVal.</p></td></tr>
			   <tr><td><a href='../proc/polyscaleself.html'>PolyScaleSelf</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To perform scaling: AVal = Alpha*(Sign)AVal.</p></td></tr>
			   <tr><td><a href='../interface/polyscalesum.html'>PolyScaleSum</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolyScaleSum <br>
 <strong>Purpose</strong>:  To perform scaling and addition of one of the followings: <br>
      1. CVal = Alpha<em>(ASign)AVal + Beta</em>(BSign)BVal, or <br>
      2. CVal =       (ASign)AVal + Beta<em>(BSign)BVal, or <br>
      3. CVal = Alpha</em>(ASign)AVal +      (BSign)BVal, or <br>
      4. CVal =       (ASign)AVal +      (BSign)BVal. <br></p></td></tr>
			   <tr><td><a href='../interface/polysetone.html'>PolySetOne</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolySetOne <br>
 <strong>Purpose</strong>:  To set value(s) of the specified argument to one. <br></p></td></tr>
			   <tr><td><a href='../interface/polysetzero.html'>PolySetZero</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolySetZero <br>
 <strong>Purpose</strong>:  To set value(s) of the specified argument to zero. <br></p></td></tr>
			   <tr><td><a href='../proc/polysquareroot.html'>PolySquareRoot</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Subroutine</td><td><p>To compute the square root of AVal and return the result in BVal.</p></td></tr>
			   <tr><td><a href='../interface/polyswap.html'>PolySwap</a></td><td><a href='../module/modbase_polyfloatnum.html'>ModBase_PolyFloatNum</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PolySwap <br>
 <strong>Purpose</strong>:  To perform swapping of the specified arguments. <br></p></td></tr>
			   <tr><td><a href='../proc/polyswapdata.html'>PolySwapData</a></td><td><a href='../module/modbase_polycommon.html'>ModBase_PolyCommon</a></td><td>Function</td><td><p>To swap the input data.  The <em>Data1</em> and <em>Data2</em> arguments must have the
 same sizes, ranks and types.</p></td></tr>
			   <tr><td><a href='../interface/popcnt.html'>POPCNT</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPCNT <br>
 <strong>Purpose</strong>:  To count the number of 1 bits in the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumBits = POPCNT(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/popcnt~2.html'>POPCNT</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPCNT <br>
 <strong>Purpose</strong>:  To count the number of 1 bits in the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumBits = POPCNT(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/popcnt~3.html'>POPCNT</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPCNT <br>
 <strong>Purpose</strong>:  To count the number of 1 bits in the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumBits = POPCNT(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/popcnt~4.html'>POPCNT</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPCNT <br>
 <strong>Purpose</strong>:  To count the number of 1 bits in the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumBits = POPCNT(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/poppar.html'>POPPAR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPPAR <br>
 <strong>Purpose</strong>:  To determine the parity of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumPar = POPPAR(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/poppar~2.html'>POPPAR</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPPAR <br>
 <strong>Purpose</strong>:  To determine the parity of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumPar = POPPAR(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/poppar~3.html'>POPPAR</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPPAR <br>
 <strong>Purpose</strong>:  To determine the parity of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumPar = POPPAR(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/poppar~4.html'>POPPAR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: POPPAR <br>
 <strong>Purpose</strong>:  To determine the parity of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumPar = POPPAR(ApNum)</p></td></tr>
			   <tr><td><a href='../proc/processinput.html'>ProcessInput</a></td><td><a href='../module/modbase_ltkinput.html'>ModBase_LTKInput</a></td><td>Subroutine</td><td><p>This subroutine processes the input files.  First, the
 input data dictionary is read and interpreted.  Using the structure
 from the data dictionary, the actual simulation input file is read. <br>
 This file is processed according to the "rules" in the data dictionary
 and stored in a local data structure which will be used during the simulation.</p></td></tr>
			   <tr><td><a href='../proc/psitokpa.html'>PsiToKPa</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert pressure from psi to kPa</p></td></tr>
			   <tr><td><a href='../interface/ptrtostr.html'>PtrToStr</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: PtrToStr <br>
 <strong>Purpose</strong>:  To set a pointer to the string of the FvlStr object.  <br>
 <strong>Usage</strong>: <br>
  ---&gt;    StrPtr =&gt; PtrToStr(vStr) <br>
  ---&gt;    IF (.NOT.ASSOCIATED(PtrToStr(vStr))) DoSomething <br>
 <strong>Important Note</strong>:  This procedure is intended to be used internally only. <br></p></td></tr>
			   <tr><td><a href='../interface/quickmultikeysort.html'>QuickMultiKeySort</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickMultiKeySort <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the
      multi-key quicksort (or 3-way radix quicksort) algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickMultiKeySort(Arr) <br></p></td></tr>
			   <tr><td><a href='../interface/quickrank3way.html'>QuickRank3Way</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRank3Way <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRank3Way(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksort3way.html">QuickSort3Way</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the three-way partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankhoare.html'>QuickRankHoare</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankHoare <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankHoare(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksorthoare.html">QuickSortHoare</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with Hoare's partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankiterative.html'>QuickRankIterative</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankIterative <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankIterative(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortiterative.html">QuickSortIterative</a>
  interface for the technical information of the <em>iterative Quicksort</em>
  algorithm with median-of-three partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankjava.html'>QuickRankJava</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankJava <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankJava(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortjava.html">QuickSortJava</a>
  interface for the technical information of the Java's <em>dual-pivot
  QuickSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/quickranklomuto.html'>QuickRankLomuto</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankLomuto <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankLomuto(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortlomuto.html">QuickSortLomuto</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with Lomuto's partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankmo3.html'>QuickRankMo3</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankMo3 <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the median-of-three (Mo3)
      partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankMo3(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortmo3.html">QuickSortMo3</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the median-of-three partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankstable.html'>QuickRankStable</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankStable <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the <em>stable</em> partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankStable(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortstable.html">QuickSortStable</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the stable partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankvowels.html'>QuickRankVowels</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankVowels <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm based on the <em>QuickSort Version 3</em>
      (the professional version) by R.A. Vowels. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankVowels(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortvowels.html">QuickSortVowels</a>
  interface for the technical information of the <em>Vowels' QuickSort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/quicksort3way.html'>QuickSort3Way</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSort3Way <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSort3Way(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Bentley and McIlroy's three-way partitioning
  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses
  a tail recursion (instead of a pure recursion) to minimize the recursive
  depth and make sure at most O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksort3way~2.html'>QuickSort3Way</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSort3Way <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSort3Way(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Bentley and McIlroy's three-way partitioning
  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses
  a tail recursion (instead of a pure recursion) to minimize the recursive
  depth and make sure at most O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksorthoare.html'>QuickSortHoare</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortHoare <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortHoare(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Hoare's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksorthoare~2.html'>QuickSortHoare</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortHoare <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortHoare(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Hoare's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortiterative.html'>QuickSortIterative</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortIterative <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortIterative(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>iterative</em> quicksort algorithm with median-of-three partitioning
  scheme is employed for large (sub)array(s).  The implementation of the
  iterative quicksort algorithm is based mainly on the <em>Sort</em> subroutine
  of Numerical Recipes in Fortran 90 [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://numerical.recipes/oldverswitcher.html">Numerical
      Recipes Books Online. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortiterative~2.html'>QuickSortIterative</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortIterative <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortIterative(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>iterative</em> quicksort algorithm with median-of-three partitioning
  scheme is employed for large (sub)array(s).  The implementation of the
  iterative quicksort algorithm is based mainly on the <em>Sort</em> subroutine
  of Numerical Recipes in Fortran 90 [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://numerical.recipes/oldverswitcher.html">Numerical
      Recipes Books Online. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortjava.html'>QuickSortJava</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortJava <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortJava(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>dual-pivot</em> quicksort algorithm is employed for large (sub)array(s).
  The implementation of the dual-pivot quicksort algorithm is based mainly
  on Java's sorting algorithm [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortjava~2.html'>QuickSortJava</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortJava <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortJava(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>dual-pivot</em> quicksort algorithm is employed for large (sub)array(s).
  The implementation of the dual-pivot quicksort algorithm is based mainly
  on Java's sorting algorithm [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortlomuto.html'>QuickSortLomuto</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortLomuto <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortLomuto(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortlomuto~2.html'>QuickSortLomuto</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortLomuto <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortLomuto(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortmo3.html'>QuickSortMo3</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortMo3 <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortMo3(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with median-of-three partitioning scheme [1] is
  employed for large (sub)array(s).  Unlike other <em>QuickSort</em> procedures,
  the algorithm for <em>QuickSortMo3</em> procedures uses a pure recursion instead
  of a tail recursion since it appears experimentally that the pure recursion
  provides a better performance for this particular implementation of the
  median-of-three partitioning scheme. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortmo3~2.html'>QuickSortMo3</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortMo3 <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortMo3(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with median-of-three partitioning scheme [1] is
  employed for large (sub)array(s).  Unlike other <em>QuickSort</em> procedures,
  the algorithm for <em>QuickSortMo3</em> procedures uses a pure recursion instead
  of a tail recursion since it appears experimentally that the pure recursion
  provides a better performance for this particular implementation of the
  median-of-three partitioning scheme. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortstable.html'>QuickSortStable</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with a stable partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid <em>stable</em> algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with a stable partitioning scheme is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion
  (instead of a pure recursion) to minimize the recursive depth and make
  sure at most O(log(n)) space is used [1]. <br>
  It is important to note that although the pair-insertion sort algorithm
  should conceptually be a stable algorithm, its implementation in this
  library seems to be <em>unstable</em>.  Therefore, for all <em>hybrid stable</em>
  algorithms, the insertion sort is used in place of the pair-insertion
  sort although the pair-insertion sort typically provides better overall
  performance. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortstable~2.html'>QuickSortStable</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with a stable partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid <em>stable</em> algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with a stable partitioning scheme is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion
  (instead of a pure recursion) to minimize the recursive depth and make
  sure at most O(log(n)) space is used [1]. <br>
  It is important to note that although the pair-insertion sort algorithm
  should conceptually be a stable algorithm, its implementation in this
  library seems to be <em>unstable</em>.  Therefore, for all <em>hybrid stable</em>
  algorithms, the insertion sort is used in place of the pair-insertion
  sort although the pair-insertion sort typically provides better overall
  performance. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortvowels.html'>QuickSortVowels</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortVowels <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm based on the <em>QuickSort Version 3</em> (the professional version)
      by R.A. Vowels [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortVowels(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm based on the <em>QuickSort Version 3</em> (the professional
  version) by R.A. Vowels [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html">
      Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,
      Unicomp. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortvowels~2.html'>QuickSortVowels</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortVowels <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm based on the <em>QuickSort Version 3</em> (the professional version)
      by R.A. Vowels [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortVowels(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm based on the <em>QuickSort Version 3</em> (the professional
  version) by R.A. Vowels [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html">
      Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,
      Unicomp. </a> <br></p></td></tr>
			   <tr><td><a href='../proc/ra_shift.html'>RA_Shift</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To perform arithmetic right shift. <br>
 Note: this is equivalent to the syntax "&gt;&gt;" in C or Java.</p></td></tr>
			   <tr><td><a href='../proc/radiantodegree.html'>RadianToDegree</a></td><td><a href='../module/modbase_conversion.html'>ModBase_Conversion</a></td><td>Function</td><td><p>To convert an angle from radian to degree</p></td></tr>
			   <tr><td><a href='../interface/randnumapint32.html'>RandNumApInt32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/randnumapint64.html'>RandNumApInt64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/randomgen.html'>RandomGen</a></td><td><a href='../module/modbase_mathutil.html'>ModBase_MathUtil</a></td><td>Function</td><td><p>To generate random number.</p></td></tr>
			   <tr><td><a href='../interface/rank_insensitive.html'>Rank_Insensitive</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Rank_Insensitive <br>
 <strong>Purpose</strong>:  To rank an array of strings in an ascending order using the specified
      ranking procedure where the strings are treated as case-insensitive strings.
      An applicable user-supplied procedure or any applicable ranking procedure (e.g.
      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in
      the <a href="../module/modbase_ranking.html">ModBase_Ranking</a> module can be
      used as an argument. <br>
 <strong>Usage</strong>: <br>
  ! rank an array of Fortran intrinsic character strings <br>
  ---&gt;    CALL Rank_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br>
  ! rank an array of FvlStr objects <br>
  ---&gt;    CALL Rank_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br>
 <strong>Note</strong>: <br>
  The <em>Wise_RankChar</em> and <em>Wise_RankComp</em> are examples of applicable ranking procedures
  for Fortran intrinsic character strings and FvlStr objects, respectively. <br></p></td></tr>
			   <tr><td><a href='../interface/read(formatted).html'>READ(FORMATTED)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: READ(FORMATTED) <br>
 <strong>Purpose</strong>:  To read a character sequence from a connected formatted unit
      into the FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ! using the list-directed format input <br>
  ---&gt;    READ(UNIT=IOUnit, FMT=<em>) vStr <br>
  ---&gt;    READ(UNIT=IOUnit, FMT=</em>, IOSTAT=IOStat, IOMSG=IOMsg) vStr <br>
  ! using the DT edit descriptor <br>
  ---&gt;    READ(UNIT=IOUnit, FMT='(DT)') vStr <br>
  ---&gt;    READ(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr <br></p></td></tr>
			   <tr><td><a href='../interface/read(unformatted).html'>READ(UNFORMATTED)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: READ(UNFORMATTED) <br>
 <strong>Purpose</strong>:  To read a character sequence from a connected unformatted unit
      into the FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    READ(UNIT=IOUnit) vStr <br></p></td></tr>
			   <tr><td><a href='../interface/realdp_fromstring_fastfloat.html'>RealDP_FromString_FastFloat</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realdp_fromstring_lemire.html'>RealDP_FromString_Lemire</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realdp_fromstring_libc.html'>RealDP_FromString_LibC</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realdp_fromstring_yy.html'>RealDP_FromString_YY</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/realdp_isequal.html'>RealDP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/realdp_tostring_dragonbox.html'>RealDP_ToString_DragonBox</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realdp_tostring_ryu.html'>RealDP_ToString_Ryu</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realdp_tostring_schubfach.html'>RealDP_ToString_Schubfach</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_fromstring_fastfloat.html'>RealQP_FromString_FastFloat</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_fromstring_lemire.html'>RealQP_FromString_Lemire</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_fromstring_libc.html'>RealQP_FromString_LibC</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_fromstring_yy.html'>RealQP_FromString_YY</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/realqp_isequal.html'>RealQP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/realqp_tostring_dragonbox.html'>RealQP_ToString_DragonBox</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_tostring_ryu.html'>RealQP_ToString_Ryu</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realqp_tostring_schubfach.html'>RealQP_ToString_Schubfach</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_fromstring_fastfloat.html'>RealSP_FromString_FastFloat</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_fromstring_lemire.html'>RealSP_FromString_Lemire</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_fromstring_libc.html'>RealSP_FromString_LibC</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_fromstring_yy.html'>RealSP_FromString_YY</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/realsp_isequal.html'>RealSP_IsEqual</a></td><td><a href='../module/class_genstore.html'>Class_GenStore</a></td><td>Function</td><td><p>To check whether two GenStore objects are equal or not.</p></td></tr>
			   <tr><td><a href='../interface/realsp_tostring_dragonbox.html'>RealSP_ToString_DragonBox</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_tostring_ryu.html'>RealSP_ToString_Ryu</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/realsp_tostring_schubfach.html'>RealSP_ToString_Schubfach</a></td><td><a href='../module/modbase_charconv.html'>ModBase_CharConv</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/removecharacters.html'>RemoveCharacters</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: RemoveCharacters <br>
 <strong>Purpose</strong>:  To remove characters from the character string depending on
               specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = RemoveCharacters(InStr, CharSet) <br>
  ---&gt;    OutStr = RemoveCharacters(InStr, CharSet, Option=2)</p></td></tr>
			   <tr><td><a href='../interface/removecharactersprotect.html'>RemoveCharactersProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: RemoveCharactersProtect <br>
 <strong>Purpose</strong>:  To remove characters from the character string depending on
               specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = RemoveCharactersProtect(InStr, CharSet) <br>
  ---&gt;    OutStr = RemoveCharactersProtect(InStr, CharSet, Option=2) <br>
  ---&gt;    OutStr = RemoveCharactersProtect(InStr, CharSet, ExclMrk=.FALSE.) <br>
  ---&gt;    OutStr = RemoveCharactersProtect(InStr, CharSet, 3, .FALSE.)</p></td></tr>
			   <tr><td><a href='../interface/removesubstring.html'>RemoveSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: RemoveSubstring <br>
 <strong>Purpose</strong>:  To remove the substring from the character string based on
               specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = RemoveSubstring(InStr, SubStr) <br>
  ---&gt;    OutStr = RemoveSubstring(InStr, SubStr, FirstOnly=.TRUE.) <br>
  ---&gt;    OutStr = RemoveSubstring(InStr, sLen, sCount, sPos) <br>
  ---&gt;    OutStr = RemoveSubstring(InStr, lPos, rPos) <br></p></td></tr>
			   <tr><td><a href='../interface/removesubstringprotect.html'>RemoveSubstringProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: RemoveSubstringProtect <br>
 <strong>Purpose</strong>:  To remove the substring from the unprotected regions of the
               character string based on specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = RemoveSubstringProtect(InStr, SubStr) <br>
  ---&gt;    OutStr = RemoveSubstringProtect(InStr, SubStr, ExclMrk=.FALSE.) <br>
  ---&gt;    OutStr = RemoveSubstringProtect(InStr, SubStr, FirstOnly=.TRUE.) <br>
  ---&gt;    OutStr = RemoveSubstringProtect(InStr, SubStr, .FALSE., .TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/repeat.html'>REPEAT</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: REPEAT <br>
 <strong>Purpose</strong>:  To concatenate several copies of the string of the specified
      FvlStr object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = REPEAT(vStrIn, nCopies) <br></p></td></tr>
			   <tr><td><a href='../interface/replacesubstring.html'>ReplaceSubstring</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ReplaceSubstring <br>
 <strong>Purpose</strong>:  To replace all occurrences of the original substring found
               in the given character string with the new substring based
               on specified input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = ReplaceSubstring(InStr, OldSub, NewSub) <br>
  ---&gt;    OutStr = ReplaceSubstring(InStr, NewSub, OldLen, OldCount, OldPos)</p></td></tr>
			   <tr><td><a href='../interface/replacesubstringprotect.html'>ReplaceSubstringProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ReplaceSubstringProtect <br>
 <strong>Purpose</strong>:  To replace all occurrences of the original substring found
               in unprotected regions of the given character string with
               the new substring. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub) <br>
  ---&gt;    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub, ExclMrk=.FALSE.)</p></td></tr>
			   <tr><td><a href='../interface/replacesubstringrecursive.html'>ReplaceSubstringRecursive</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ReplaceSubstringRecursive <br>
 <strong>Purpose</strong>:  To replace all occurrences of the original substring found
               in the given character string with the new substring in
               a recursive way. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutStr = ReplaceSubstringRecursive(InStr, OldSub, NewSub) <br>
 <strong>Example</strong>: <br>
  <em>Input</em>: cStrIn = 'abbbbb', oStr = 'ab', nStr = 'a' <br>
  <em>Output</em> - non-recursive: cStrOut = 'abbbb' <br>
  <em>Output</em> - recursive: cStrOut = 'ab'</p></td></tr>
			   <tr><td><a href='../proc/reporterror.html'>ReportError</a></td><td><a href='../module/class_error_info.html'>Class_Error_Info</a></td><td>Subroutine</td><td><p>To report and/or set the specified error information.</p></td></tr>
			   <tr><td><a href='../interface/reversebits.html'>ReverseBits</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ReverseBits <br>
 <strong>Purpose</strong>:  To return an integer value (same kind as the specified integer value) obtained by
   reversing the order of the bits in the two's complement binary representation of the input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = ReverseBits(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/reversebytes.html'>ReverseBytes</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ReverseBits <br>
 <strong>Purpose</strong>:  To return an integer value (same kind as the specified integer value) obtained by
   reversing the order of the bytes in the two's complement binary representation of the input. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUTPUT = ReverseBytes(INPUT)</p></td></tr>
			   <tr><td><a href='../proc/rl_shift.html'>RL_Shift</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To perform logical right shift. <br>
 Note: this is equivalent to the syntax "&gt;&gt;&gt;" in C for signed integer or Java
       and it is equivalent to the syntax "&gt;&gt;" in C for unsigned integer.</p></td></tr>
			   <tr><td><a href='../interface/rustrank.html'>RustRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>RustSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/rustsort.html">RustSort</a> interface
  for the technical information of the <em>RustSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/rustsort.html'>RustSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>RustSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>RustSort</em> algorithm is a hybrid stable algorithm based on the Rust's
  mergesort algorithm [1].  The algorithm can be considered as a simplified
  <em>TimSort</em> algorithm where the galloping mode is not utilized.  Similar to
  the <em>Timsort</em> algorithm, the <em>RustSort</em> algorithm employs the insertion sort
  for small arrays and the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159">
      Rust's mergesort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/rustsort~2.html'>RustSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>RustSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>RustSort</em> algorithm is a hybrid stable algorithm based on the Rust's
  mergesort algorithm [1].  The algorithm can be considered as a simplified
  <em>TimSort</em> algorithm where the galloping mode is not utilized.  Similar to
  the <em>Timsort</em> algorithm, the <em>RustSort</em> algorithm employs the insertion sort
  for small arrays and the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159">
      Rust's mergesort. </a> <br></p></td></tr>
			   <tr><td><a href='../proc/samestring.html'>SameString</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>This function returns true if the two strings are equal (case insensitively).</p></td></tr>
			   <tr><td><a href='../interface/scan.html'>SCAN</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SCAN <br>
 <strong>Purpose</strong>:  To scan the string of a FvlStr object for any character in a set
      of characters and return the position of the first character found in the
      string that is in the specified set depending on the scanning direction. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Pos = SCAN(vStr, ChrSet) <br>
  ---&gt;    Pos = SCAN(vStr, ChrSet, Back=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/scramblewell.html'>ScrambleWell</a></td><td><a href='../module/class_baserng.html'>Class_BaseRNG</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/setstoponerror.html'>SetStopOnError</a></td><td><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></td><td>Subroutine</td><td><p>To set StopOnError flag (module variable).</p></td></tr>
			   <tr><td><a href='../proc/settimelimit.html'>SetTimeLimit</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>To set the limit of the hour to be between 0 and 24.</p></td></tr>
			   <tr><td><a href='../interface/shifta.html'>SHIFTA</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTA <br>
 <strong>Purpose</strong>:  To perform arithmetic right shift with 0 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = SHIFTA(IN, 33)</p></td></tr>
			   <tr><td><a href='../interface/shifta63down.html'>ShiftA63Down</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftA63Down <br>
 <strong>Purpose</strong>:  To perform arithmetic right shift by 63 or less. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftA63Down(IN, 53)</p></td></tr>
			   <tr><td><a href='../interface/shifta64.html'>ShiftA64</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftA64 <br>
 <strong>Purpose</strong>:  To perform arithmetic right shift by 64. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftA64(IN)</p></td></tr>
			   <tr><td><a href='../interface/shifta64up.html'>ShiftA64Up</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftA64Up <br>
 <strong>Purpose</strong>:  To perform arithmetic right shift by 64 or more (&lt;= 128) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftA64Up(IN, 84)</p></td></tr>
			   <tr><td><a href='../interface/shiftaonce.html'>ShiftAOnce</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftAOnce <br>
 <strong>Purpose</strong>:  To perform arithmetic right shift by 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftAOnce(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftl.html'>SHIFTL</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTL <br>
 <strong>Purpose</strong>:  To perform logical left shift where ShiftPos is non-negative. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = SHIFTL(NumIn, 157)</p></td></tr>
			   <tr><td><a href='../interface/shiftl~2.html'>SHIFTL</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTL <br>
 <strong>Purpose</strong>:  To perform logical left shift with 0 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = SHIFTL(IN, 127)</p></td></tr>
			   <tr><td><a href='../interface/shiftl~3.html'>SHIFTL</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTL <br>
 <strong>Purpose</strong>:  To perform logical left shift with 0 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = SHIFTL(IN, 127)</p></td></tr>
			   <tr><td><a href='../interface/shiftl~4.html'>SHIFTL</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTL <br>
 <strong>Purpose</strong>:  To perform logical left shift where ShiftPos is non-negative. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = SHIFTL(NumIn, 157)</p></td></tr>
			   <tr><td><a href='../interface/shiftl63down.html'>ShiftL63Down</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL63Down <br>
 <strong>Purpose</strong>:  To perform logical left shift by 63 or less. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL63Down(IN, 11)</p></td></tr>
			   <tr><td><a href='../interface/shiftl63down~2.html'>ShiftL63Down</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL63Down <br>
 <strong>Purpose</strong>:  To perform logical left shift by 63 or less. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL63Down(IN, 11)</p></td></tr>
			   <tr><td><a href='../interface/shiftl64.html'>ShiftL64</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL64 <br>
 <strong>Purpose</strong>:  To perform logical left shift by 64. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL64(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftl64~2.html'>ShiftL64</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL64 <br>
 <strong>Purpose</strong>:  To perform logical left shift by 64. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL64(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftl64up.html'>ShiftL64Up</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL64Up <br>
 <strong>Purpose</strong>:  To perform logical left shift by 64 or more (&lt;= 128). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL64Up(IN, 111)</p></td></tr>
			   <tr><td><a href='../interface/shiftl64up~2.html'>ShiftL64Up</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftL64Up <br>
 <strong>Purpose</strong>:  To perform logical left shift by 64 or more (&lt;= 128). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftL64Up(IN, 111)</p></td></tr>
			   <tr><td><a href='../interface/shiftlonce.html'>ShiftLOnce</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftLOnce <br>
 <strong>Purpose</strong>:  To perform logical left shift by 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftLOnce(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftlonce~2.html'>ShiftLOnce</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftLOnce <br>
 <strong>Purpose</strong>:  To perform logical left shift by 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftLOnce(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftr.html'>SHIFTR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTR <br>
 <strong>Purpose</strong>:  To perform logical right shift where ShiftPos is non-negative. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = SHIFTR(NumIn, 141)</p></td></tr>
			   <tr><td><a href='../interface/shiftr~2.html'>SHIFTR</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTR <br>
 <strong>Purpose</strong>:  To perform logical right shift with 0 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = SHIFTR(IN, 33)</p></td></tr>
			   <tr><td><a href='../interface/shiftr~3.html'>SHIFTR</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTR <br>
 <strong>Purpose</strong>:  To perform logical right shift with 0 &lt;= ShiftPos &lt;= 128.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = SHIFTR(IN, 33)</p></td></tr>
			   <tr><td><a href='../interface/shiftr~4.html'>SHIFTR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SHIFTR <br>
 <strong>Purpose</strong>:  To perform logical right shift where ShiftPos is non-negative. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumOut = SHIFTR(NumIn, 141)</p></td></tr>
			   <tr><td><a href='../interface/shiftr63down.html'>ShiftR63Down</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR63Down <br>
 <strong>Purpose</strong>:  To perform logical right shift by 63 or less. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR63Down(IN, 53)</p></td></tr>
			   <tr><td><a href='../interface/shiftr63down~2.html'>ShiftR63Down</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR63Down <br>
 <strong>Purpose</strong>:  To perform logical right shift by 63 or less. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR63Down(IN, 53)</p></td></tr>
			   <tr><td><a href='../interface/shiftr64.html'>ShiftR64</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR64 <br>
 <strong>Purpose</strong>:  To perform logical right shift by 64. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR64(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftr64~2.html'>ShiftR64</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR64 <br>
 <strong>Purpose</strong>:  To perform logical right shift by 64. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR64(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftr64up.html'>ShiftR64Up</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR64Up <br>
 <strong>Purpose</strong>:  To perform logical right shift by 64 or more (&lt;= 128). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR64Up(IN, 84)</p></td></tr>
			   <tr><td><a href='../interface/shiftr64up~2.html'>ShiftR64Up</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftR64Up <br>
 <strong>Purpose</strong>:  To perform logical right shift by 64 or more (&lt;= 128). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftR64Up(IN, 84)</p></td></tr>
			   <tr><td><a href='../interface/shiftronce.html'>ShiftROnce</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftROnce <br>
 <strong>Purpose</strong>:  To perform logical right shift by 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftROnce(IN)</p></td></tr>
			   <tr><td><a href='../interface/shiftronce~2.html'>ShiftROnce</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ShiftROnce <br>
 <strong>Purpose</strong>:  To perform logical right shift by 1. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OUT = ShiftROnce(IN)</p></td></tr>
			   <tr><td><a href='../interface/signum.html'>SigNum</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SigNum <br>
 <strong>Purpose</strong>:  To return the sign of the specified input where the return value is <br>
  -1 if the specified value is negative <br>
   0 if the specified value is zero <br>
   1 if the specified value is positive <br>
 <strong>Usage</strong>: <br>
  ---&gt;    SignFlag = SigNum(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/sint128.html'>SInt128</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Constructor Interface</strong>: SInt128 <br>
 <strong>Purpose</strong>:  To construct a 128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ! construct I128 (with negative value) from 32-bit intrinsic integer treated as unsigned <br>
  ---&gt;    I128 = SInt128(U32, Negative=.TRUE.) <br>
  ! construct I128 from 64-bit intrinsic integer treated as signed <br>
  ---&gt;    I128 = SInt128(I64) <br>
  ! construct I128 from 128-bit real number <br>
  ---&gt;    I128 = SInt128(R128) <br>
  ! construct I128 from a decimal string <br>
  ---&gt;    I128 = UInt128('-1234567890987654321011223344')</p></td></tr>
			   <tr><td><a href='../interface/siphash24_i64.html'>SipHash24_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/siphash_i128.html'>SipHash_I128</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/sortascend_insensitive.html'>SortAscend_Insensitive</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: SortAscend_Insensitive <br>
 <strong>Purpose</strong>:  To sort an array of strings in an ascending order using the specified
      ranking procedure where the strings are treated as case-insensitive strings.
      An applicable user-supplied procedure or any applicable ranking procedure (e.g.
      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in
      the <a href="../module/modbase_ranking.html">ModBase_Ranking</a> module can be
      used as an argument. <br>
 <strong>Usage</strong>: <br>
  ! sort an array of Fortran intrinsic character strings <br>
  ---&gt;    CALL SortAscend_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br>
  ! sort an array of FvlStr objects <br>
  ---&gt;    CALL SortAscend_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br>
 <strong>Note</strong>: <br>
  The <em>Wise_RankChar</em> and <em>Wise_RankComp</em> are examples of applicable ranking procedures
  for Fortran intrinsic character strings and FvlStr objects, respectively. <br></p></td></tr>
			   <tr><td><a href='../interface/sortdescend_insensitive.html'>SortDescend_Insensitive</a></td><td><a href='../module/modbase_stringsorts.html'>ModBase_StringSorts</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: SortDescend_Insensitive <br>
 <strong>Purpose</strong>:  To sort an array of strings in a descending order using the specified
      ranking procedure where the strings are treated as case-insensitive strings.
      An applicable user-supplied procedure or any applicable ranking procedure (e.g.
      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in
      the <a href="../module/modbase_ranking.html">ModBase_Ranking</a> module can be
      used as an argument. <br>
 <strong>Usage</strong>: <br>
  ! sort an array of Fortran intrinsic character strings <br>
  ---&gt;    CALL SortDescend_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br>
  ! sort an array of FvlStr objects <br>
  ---&gt;    CALL SortDescend_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br>
 <strong>Note</strong>: <br>
  The <em>Wise_RankChar</em> and <em>Wise_RankComp</em> are examples of applicable ranking procedures
  for Fortran intrinsic character strings and FvlStr objects, respectively. <br></p></td></tr>
			   <tr><td><a href='../interface/split.html'>Split</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Split <br>
 <strong>Purpose</strong>:  To split a character string into multiple substrings by a
               separator (single character or a multiple-character string). <br>
 <strong>Usage</strong>: <br>
  ! <em>SepSub</em> is a multiple-character string separator. <br>
  ---&gt;    CALL Split(cStr, SepSub, qStr) <br>
  ! <em>SepSet</em> is a set of characters where a character in the set is a valid separator. <br>
  ---&gt;    CALL Split(cStr, SepSet, qStr, SepChr) <br></p></td></tr>
			   <tr><td><a href='../interface/splitprotect.html'>SplitProtect</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: SplitProtect <br>
 <strong>Purpose</strong>:  To split a character string into multiple substrings by a
               separator (single character or a multiple-character string)
               found in unprotected region(s). <br>
 <strong>Usage</strong>: <br>
  ! <em>SepSub</em> is a multiple-character string separator. <br>
  ---&gt;    CALL SplitProtect(cStr, SepSub, qStr) <br>
  ! <em>SepSet</em> is a set of characters where a character in the set is a valid separator. <br>
  ---&gt;    CALL SplitProtect(cStr, SepSet, qStr, SepChr) <br>
  ! The exclamation mark is NOT used to define the protected regions. <br>
  ---&gt;    CALL SplitProtect(cStr, SepSub, qStr, ExclMrk=.FALSE.) <br></p></td></tr>
			   <tr><td><a href='../interface/spooky_hash128_exp.html'>Spooky_Hash128_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/spooky_hash128_opt.html'>Spooky_Hash128_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/spookyhash_i128.html'>SpookyHash_I128</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/sqr.html'>SQR</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SQR <br>
 <strong>Purpose</strong>:  To compute the square of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumSqr = SQR(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/sqr~2.html'>SQR</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SQR <br>
 <strong>Purpose</strong>:  To compute the square of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumSqr = SQR(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/startwith.html'>StartWith</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: StartWith <br>
 <strong>Purpose</strong>:  To check whether the given character string starts with the
               specified substring or not.  Both the string and the substring
               must not have a zero length. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = StartWith(String, Substring) <br>
  ---&gt;    IF (.NOT.StartWith(String, Substring)) DoSomething</p></td></tr>
			   <tr><td><a href='../interface/subtract.html'>Subtract</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Subtract <br>
 <strong>Purpose</strong>:  To perform subtraction: This = This - Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Subtract(This, Other) <br>
 <strong>Important Note</strong>:  For subtraction of signed integers (unlike unsigned one),
  value of This can be less than Other.</p></td></tr>
			   <tr><td><a href='../interface/subtract~2.html'>Subtract</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Subtract <br>
 <strong>Purpose</strong>:  To perform subtraction: This = This - Other. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Subtract(This, Other) <br>
 <strong>Important Note</strong>:  For subtraction of unsigned integers, value of This
  must always be greater than Other.  Otherwise, value of the returned
  This is NOT valid.</p></td></tr>
			   <tr><td><a href='../interface/subtractxp.html'>SubtractXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SubtractXp <br>
 <strong>Purpose</strong>:  To perform a subtraction: OutVal = LhsVal - RhsVal. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    OutVal = SubtractXp(LhsVal, RhsVal, Algorithm) <br>
 <strong>Note</strong>: Algorithm must be between 1 and 3.</p></td></tr>
			   <tr><td><a href='../proc/subu64.html'>SubU64</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To return the difference of X, Y and BorrowIn: Diff = X - Y - BorrowIn.
 The borrow input must be 0 or 1; otherwise the behavior is undefined.
 The borrow output is guaranteed to be 0 or 1.</p></td></tr>
			   <tr><td><a href='../interface/subxp.html'>SubXp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/superfasthash_i32.html'>SuperFastHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/swap.html'>Swap</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Swap <br>
 <strong>Purpose</strong>:  To swap values of two FvlStr objects or two arrays
      of FvlStr objects. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Swap(vStrA, vStrB) <br>
  ---&gt;    CALL Swap(vStrArrA, vStrArrB) <br></p></td></tr>
			   <tr><td><a href='../interface/swap~2.html'>Swap</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: Swap <br>
<strong>Purpose</strong>:  To swap values. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Swap(AVal, BVal) <br></p></td></tr>
			   <tr><td><a href='../interface/swaparray.html'>SwapArray</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: SwapArray <br>
<strong>Purpose</strong>:  To swap values of two arrays with specified staring and ending indices. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL SwapArray(IBegin, IEnd, XArr, YArr) <br></p></td></tr>
			   <tr><td><a href='../proc/swapbytearray.html'>SwapByteArray</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Subroutine</td><td><p>To swap elements of the specified byte array.</p></td></tr>
			   <tr><td><a href='../interface/swapbytes.html'>SwapBytes</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: SwapBytes <br>
 <strong>Purpose</strong>:  To perform swapping of bytes of an integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Output = SwapBytes(Input)</p></td></tr>
			   <tr><td><a href='../proc/swaptwobytes.html'>SwapTwoBytes</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Subroutine</td><td><p>To swap element I and element J of the specified byte array.</p></td></tr>
			   <tr><td><a href='../interface/timrank.html'>TimRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/timsort.html">TimSort</a> interface
  for the technical information of the <em>TimSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/timsort.html'>TimSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>TimSort</em> algorithm is a hybrid stable algorithm developed by Tim
  Peters [1].  The algorithm is an adaptive, natural mergesort that works
  well for many kinds of partially ordered arrays.  As implemented here,
  the <em>Timsort</em> algorithm employs the insertion sort for small arrays and
  the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://bugs.python.org/file4451/timsort.txt">Timsort by
      Tim Peters. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/timsort~2.html'>TimSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>TimSort</em> algorithm is a hybrid stable algorithm developed by Tim
  Peters [1].  The algorithm is an adaptive, natural mergesort that works
  well for many kinds of partially ordered arrays.  As implemented here,
  the <em>Timsort</em> algorithm employs the insertion sort for small arrays and
  the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://bugs.python.org/file4451/timsort.txt">Timsort by
      Tim Peters. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/tobytes.html'>ToBytes</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ToBytes <br>
 <strong>Purpose</strong>:  To convert an ApInt32 number to a 8-bit integer magnitude
  array and its sign. <br>
 <strong>Usage</strong>: <br>
  ---&gt; CALL ToBytes(ApNum, MagArray, Sign)</p></td></tr>
			   <tr><td><a href='../interface/tobytes~2.html'>ToBytes</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ToBytes <br>
 <strong>Purpose</strong>:  To convert an ApInt64 number to a 8-bit integer magnitude
  array and its sign. <br>
 <strong>Usage</strong>: <br>
  ---&gt; CALL ToBytes(ApNum, MagArray, Sign)</p></td></tr>
			   <tr><td><a href='../interface/tocharstar.html'>ToCharStar</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: ToCharStar <br>
 <strong>Purpose</strong>:  To convert a FvlStr object to an assumed-length character string.  <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL ToCharStar(vStr, cStr) <br>
 <strong>Important Note</strong>:  This procedure is intended to be used internally only. <br></p></td></tr>
			   <tr><td><a href='../interface/tochrarralloc.html'>ToChrArrAlloc</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToChrArrAlloc <br>
 <strong>Purpose</strong>:  To convert a character string to an allocatable array
               of characters. <br>
 <strong>Usage</strong>: <br>
  ! convert a character string to a character array <br>
  ---&gt;    cArray = ToChrArrAlloc(cStr) <br>
  ! convert a character string to a character array with a null character <br>
  ---&gt;    cArray = ToChrArrAlloc(cStr, IsCString=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/tochrarrfixed.html'>ToChrArrFixed</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToChrArrFixed <br>
 <strong>Purpose</strong>:  To convert a character string to an explicit-shape array
               of characters. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    cArray = ToChrArrFixed(cStr)</p></td></tr>
			   <tr><td><a href='../interface/tocstring.html'>ToCString</a></td><td><a href='../module/modbase_chrstr.html'>ModBase_ChrStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToCString <br>
 <strong>Purpose</strong>:  To convert a character string to a 'C' style string, which is an
               explicit-shape array of characters with a null character added. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    cArray = ToCString(cStr)</p></td></tr>
			   <tr><td><a href='../interface/todecstring.html'>ToDecString</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecString <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to
  a decimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecString(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/todecstring~2.html'>ToDecString</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecString <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to
  a decimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecString(I128)</p></td></tr>
			   <tr><td><a href='../interface/todecstring~3.html'>ToDecString</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecString <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a decimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecString(U128)</p></td></tr>
			   <tr><td><a href='../interface/todecstring~4.html'>ToDecString</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecString <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to
  a decimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecString(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/todecstrsigned.html'>ToDecStrSigned</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecStrSigned <br>
 <strong>Purpose</strong>:  To convert a signed integer to a decimal string <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecStrSigned(I64)</p></td></tr>
			   <tr><td><a href='../interface/todecstrunsigned.html'>ToDecStrUnsigned</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToDecStrUnsigned <br>
 <strong>Purpose</strong>:  To convert an unsigned integer to a decimal string <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToDecStrUnsigned(U32)</p></td></tr>
			   <tr><td><a href='../interface/todecstrxp.html'>ToDecStrXp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/todecstrxp~2.html'>ToDecStrXp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tohexstr_be.html'>ToHexStr_BE</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexStr_BE <br>
 <strong>Purpose</strong>:  To convert an array of 8-bit integer numbers (stored in
               big-endian order) to a hexadecimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    HexStr = ToHexStr_BE(ByteArr)</p></td></tr>
			   <tr><td><a href='../interface/tohexstr_le.html'>ToHexStr_LE</a></td><td><a href='../module/modbase_byteutil.html'>ModBase_ByteUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexStr_LE <br>
 <strong>Purpose</strong>:  To convert an array of 8-bit integer numbers (stored in
               little-endian order) to a hexadecimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    HexStr = ToHexStr_LE(ByteArr)</p></td></tr>
			   <tr><td><a href='../interface/tohexstring.html'>ToHexString</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexString <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to
  a hexadecimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToHexString(I128)</p></td></tr>
			   <tr><td><a href='../interface/tohexstring~2.html'>ToHexString</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexString <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a hexadecimal string. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToHexString(U128)</p></td></tr>
			   <tr><td><a href='../interface/tohexstrsigned.html'>ToHexStrSigned</a></td><td><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexStrSigned <br>
 <strong>Purpose</strong>:  To convert a signed integer to a hexadecimal string <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToHexStrSigned(I32)</p></td></tr>
			   <tr><td><a href='../interface/tohexstrunsigned.html'>ToHexStrUnsigned</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToHexStrUnsigned <br>
 <strong>Purpose</strong>:  To convert an unsigned integer to a hexadecimal string <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToHexStrUnsigned(U32)</p></td></tr>
			   <tr><td><a href='../interface/toi128.html'>ToI128</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I128 = ToI128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/toi128~2.html'>ToI128</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I128 = ToI128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/toi128xp.html'>ToI128Xp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/toi32.html'>ToI32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I32 = ToI32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/toi32~2.html'>ToI32</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI32 <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to a
  32-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I32 = ToI32(U128)</p></td></tr>
			   <tr><td><a href='../interface/toi32~3.html'>ToI32</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I32 = ToI32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/toi64.html'>ToI64</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I64 = ToI64(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/toi64~2.html'>ToI64</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI64 <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a 64-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I64 = ToI64(U128)</p></td></tr>
			   <tr><td><a href='../interface/toi64~3.html'>ToI64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToI64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit signed integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    I64 = ToI64(ApNum)</p></td></tr>
			   <tr><td><a href='../proc/tolowercase.html'>ToLowerCase</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../interface/tor128.html'>ToR128</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R128 = ToR128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor128~2.html'>ToR128</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR128 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to
  a 128-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R128 = ToR128(I128)</p></td></tr>
			   <tr><td><a href='../interface/tor128~3.html'>ToR128</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR128 <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a 128-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R128 = ToR128(U128)</p></td></tr>
			   <tr><td><a href='../interface/tor128~4.html'>ToR128</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R128 = ToR128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor128xp.html'>ToR128Xp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tor128xp~2.html'>ToR128Xp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tor32.html'>ToR32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R32 = ToR32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor32~2.html'>ToR32</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR32 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to
  a 32-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R32 = ToR32(I128)</p></td></tr>
			   <tr><td><a href='../interface/tor32~3.html'>ToR32</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR32 <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a 32-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R32 = ToR32(U128)</p></td></tr>
			   <tr><td><a href='../interface/tor32~4.html'>ToR32</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R32 = ToR32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor32xp.html'>ToR32Xp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tor32xp~2.html'>ToR32Xp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tor64.html'>ToR64</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R64 = ToR64(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor64~2.html'>ToR64</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR64 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to
  a 64-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R64 = ToR64(I128)</p></td></tr>
			   <tr><td><a href='../interface/tor64~3.html'>ToR64</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR64 <br>
 <strong>Purpose</strong>:  To convert a 128-bit unsigned integer to
  a 64-bit floating point (real) number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R64 = ToR64(U128)</p></td></tr>
			   <tr><td><a href='../interface/tor64~4.html'>ToR64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToR64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit real number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    R64 = ToR64(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tor64xp.html'>ToR64Xp</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tor64xp~2.html'>ToR64Xp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tostringxp.html'>ToStringXp</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToStringXp <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a decimal
               string.  Valid value of <em>Algorithm</em> is between 1 and 7. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Str = ToStringXp(ApNum, Algorithm)</p></td></tr>
			   <tr><td><a href='../interface/tou128.html'>ToU128</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U128 = ToU128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tou128~2.html'>ToU128</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU128 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to a
  128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U128 = ToU128(I128)</p></td></tr>
			   <tr><td><a href='../interface/tou128~3.html'>ToU128</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU128 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U128 = ToU128(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tou128xp.html'>ToU128Xp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/tou32.html'>ToU32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U32 = ToU32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tou32~2.html'>ToU32</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU32 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to a
  32-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U32 = ToU32(I128)</p></td></tr>
			   <tr><td><a href='../interface/tou32~3.html'>ToU32</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU32 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  32-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U32 = ToU32(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tou64.html'>ToU64</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U64 = ToU64(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tou64~2.html'>ToU64</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU64 <br>
 <strong>Purpose</strong>:  To convert a 128-bit signed integer to a
  64-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U64 = ToU64(I128)</p></td></tr>
			   <tr><td><a href='../interface/tou64~3.html'>ToU64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToU64 <br>
 <strong>Purpose</strong>:  To convert an arbitrary-precision signed integer to a
  64-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U64 = ToU64(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/tounsignedinteger.html'>ToUnsignedInteger</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToUnsignedInteger <br>
 <strong>Purpose</strong>:  To perform unsigned conversion from lower-precision unsigned integer
  to 32-bit unsigned integer <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U32 = ToUnsignedInteger(U8)</p></td></tr>
			   <tr><td><a href='../interface/tounsignedlong.html'>ToUnsignedLong</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: ToUnsignedLong <br>
 <strong>Purpose</strong>:  To perform unsigned conversion from lower-precision unsigned integer
  to 64-bit unsigned integer <br>
 <strong>Usage</strong>: <br>
  ---&gt;    U64 = ToUnsignedLong(U32)</p></td></tr>
			   <tr><td><a href='../proc/touppercase.html'>ToUpperCase</a></td><td><a href='../module/modbase_charutil.html'>ModBase_CharUtil</a></td><td>Function</td><td></td></tr>
			   <tr><td><a href='../interface/trailz.html'>TRAILZ</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: TRAILZ <br>
 <strong>Purpose</strong>:  To count the number of trailing zero bits of the ApInt32 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumTZ = TRAILZ(ApNum)</p></td></tr>
			   <tr><td><a href='../interface/trailz~2.html'>TRAILZ</a></td><td><a href='../module/modbase_sint128.html'>ModBase_SInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: TRAILZ <br>
 <strong>Purpose</strong>:  To count the number of trailing zero bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumTZ = TRAILZ(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/trailz~3.html'>TRAILZ</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: TRAILZ <br>
 <strong>Purpose</strong>:  To count the number of trailing zero bits of the input.
  (For more information, see detailed explanation of the intrinsic function.) <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumTZ = TRAILZ(INPUT)</p></td></tr>
			   <tr><td><a href='../interface/trailz~4.html'>TRAILZ</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: TRAILZ <br>
 <strong>Purpose</strong>:  To count the number of trailing zero bits of the ApInt64 number. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    NumTZ = TRAILZ(ApNum)</p></td></tr>
			   <tr><td><a href='../proc/transposematrix.html'>TransposeMatrix</a></td><td><a href='../module/modbase_mathutil.html'>ModBase_MathUtil</a></td><td>Function</td><td><p>To transpose matrix.</p></td></tr>
			   <tr><td><a href='../interface/trim.html'>TRIM</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: TRIM <br>
 <strong>Purpose</strong>:  To return the argument with trailing blanks removed. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    vStrOut = TRIM(vStrIn) <br></p></td></tr>
			   <tr><td><a href='../proc/trimsigdigits.html'>TrimSigDigits</a></td><td><a href='../module/modbase_miscutil.html'>ModBase_MiscUtil</a></td><td>Function</td><td><p>This function accepts a number as a parameter as well as the number of
 significant digits after the decimal point to report and returns a string
 that is appropriate.</p></td></tr>
			   <tr><td><a href='../interface/tsiphash_i64.html'>TSipHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/uaddxp.html'>UAddXp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/udivmod.html'>UDivMod</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: UDivMod <br>
 <strong>Purpose</strong>:  To perform a division of two unsigned integers (where the
  dividend (numerator) is a 128-bit unsigned integer and the divisor
  (denominator) can be 32-, 64- or 128-bit unsigned integer) and
  to return both the quotient and the remainder. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL UDivMod(NUMER, DENOM, QUOT, REM)</p></td></tr>
			   <tr><td><a href='../interface/udivmod~2.html'>UDivMod</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: UDivMod <br>
 <strong>Purpose</strong>:  To perform a division of two unsigned integers and then return both
  the quotient and the remainder where both input and output have the same kind <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL UDivMod(NUMER, DENOM, QUOT, REM)</p></td></tr>
			   <tr><td><a href='../interface/udivmodxp.html'>UDivModXp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/uint128.html'>UInt128</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Constructor Interface</strong>: UInt128 <br>
 <strong>Purpose</strong>:  To construct a 128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ! construct U128 from 32-bit signed integer <br>
  ---&gt;    U128 = UInt128(I32) <br>
  ! construct U128 from 64-bit intrinsic integer treated as unsigned <br>
  ---&gt;    U128 = UInt128(I64, AsUnsigned=.TRUE.) <br>
  ! construct U128 from 128-bit real number <br>
  ---&gt;    U128 = UInt128(R128) <br>
  ! construct U128 from a decimal string <br>
  ---&gt;    U128 = UInt128('1234567890987654321011223344')</p></td></tr>
			   <tr><td><a href='../interface/umod.html'>UMOD</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: UMOD <br>
 <strong>Purpose</strong>:  To return the remainder of a division of two unsigned integers,
  where the dividend (numerator) is a 128-bit unsigned integer and the
  divisor (denominator) can be 32-, 64- or 128-bit unsigned integer. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    REM = UMOD(NUMER, DENOM)</p></td></tr>
			   <tr><td><a href='../interface/umod~2.html'>UMOD</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: UMOD <br>
 <strong>Purpose</strong>:  To return the remainder of a division of two unsigned integers,
  where both input and an output have the same kind <br>
 <strong>Usage</strong>: <br>
  ---&gt;    REM = UMOD(NUMER, DENOM)</p></td></tr>
			   <tr><td><a href='../proc/umul128.html'>UMul128</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To compute 128-bit result of multiplication of two 64-bit unsigned integers.</p></td></tr>
			   <tr><td><a href='../proc/umul128_n_add.html'>UMul128_N_Add</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To multiply two 64-bit unsigned integers and add a value (A*B + C), and
return the 128-bit result as U128Hi, U128Lo.</p></td></tr>
			   <tr><td><a href='../proc/umul128_n_shift.html'>UMul128_N_Shift</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Function</td><td><p>To multiply two 64-bit unsigned integers, and then shift
the 128-bit result by ShrPos =&gt; SHIFTR(A*B, ShrPos). <br>
Note: ShrPos should be in the range [64, 128].</p></td></tr>
			   <tr><td><a href='../proc/umul128_upper64.html'>UMul128_Upper64</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Function</td><td><p>To compute upper 64 bits of multiplication of two 64-bit unsigned integers</p></td></tr>
			   <tr><td><a href='../proc/umul192_lower128.html'>UMul192_Lower128</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To compute lower 128 bits of multiplication of a 64-bit unsigned integer and
a 128-bit unsigned integer.</p></td></tr>
			   <tr><td><a href='../proc/umul192_upper128.html'>UMul192_Upper128</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To compute upper 128 bits of multiplication of a 64-bit unsigned integer and
a 128-bit unsigned integer.</p></td></tr>
			   <tr><td><a href='../proc/umul96_lower64.html'>UMul96_Lower64</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Function</td><td><p>To compute lower 64 bits of multiplication of a 32-bit unsigned integer and
a 64-bit unsigned integer.</p></td></tr>
			   <tr><td><a href='../proc/umul96_upper64.html'>UMul96_Upper64</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Function</td><td><p>To compute upper 64 bits of multiplication of a 32-bit unsigned integer and
a 64-bit unsigned integer.</p></td></tr>
			   <tr><td><a href='../proc/umulbasic.html'>UMulBasic</a></td><td><a href='../module/modbase_uintutil.html'>ModBase_UIntUtil</a></td><td>Subroutine</td><td><p>To multiply 64-bit unsigned integer arrays and return
 the result using grade-school algorithm.</p></td></tr>
			   <tr><td><a href='../interface/umulxp.html'>UMulXp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/usubxp.html'>USubXp</a></td><td><a href='../module/modbase_uint128.html'>ModBase_UInt128</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/verify.html'>VERIFY</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: VERIFY <br>
 <strong>Purpose</strong>:  To verify that a set of characters contains all the characters
      in the string of a FvlStr object by identifying the first character in
      the string that is not in the set and to return the position of the
      first character found in the string that is NOT in the specified set
      depending on the scanning direction. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Pos = VERIFY(vStr, ChrSet) <br>
  ---&gt;    Pos = VERIFY(vStr, ChrSet, Back=.TRUE.) <br></p></td></tr>
			   <tr><td><a href='../interface/water_hash32_exp.html'>Water_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/water_hash32_opt.html'>Water_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/waterhash_i32.html'>WaterHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/waterhash_i32_new.html'>WaterHash_I32_New</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wiserank.html'>WiseRank</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/wisesort.html">WiseSort</a> interface
  for the technical information of the <em>WiseSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/wiserankstable.html'>WiseRankStable</a></td><td><a href='../module/modbase_ranking.html'>ModBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseRankStable <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseRankStable(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/wisesortstable.html">WiseSortStable</a> interface
  for the technical information of the <em>WiseSort-Stable</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesort.html'>WiseSort</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>WiseSort</em> algorithm is a hybrid algorithm originated in this library
  (<em>XpfLib</em>).  The algorithm sorts the given array using a variety of sorting
  algorithms based on the pattern of the data.  First, it carefully and wisely
  inspects the specified array by checking if there is any pattern in the given
  array.  Next, it decides which sorting algorithm is most suitable for the array.
  It then sorts the array using the chosen algorithm. <br>
  The selection of a sorting algorithm is based on the following facts. <br>
  - An <em>Insertion sort</em> algorithm usually performs well for an array with
    small size. <br>
  - If the data is already sorted, no sorting algorithm is needed. <br>
  - If the data is already sorted but in an order opposite to the desired one,
    a reversion of the array is the most optimal sorting algorithm. <br>
  - A quicksort algorithm typically performs well for a totally randomized array. <br>
  - A mergesort algorithm generally performs well for a mostly ordered array. <br>
  Based on the aforementioned facts, the <em>WiseSort</em> algorithm utilizes various
  sorting algorithms including: <br>
  1. <em>Pair-insertion-sort-based</em> algorithms consisting of <br>
    - guarded version for a left-most sub-array or the whole array with small size, <br>
    - unguarded version for a non-left-most sub-array with small size. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered
      array (i.e. an array having a very long ordered run, either in ascending or
      descending order). <br>
      For this particular implementation, it is found that Rust's mergesort performs
      very well for an array when more than 50% of the first or last elements of the
      array are already sorted. <br>
  3. <em>Quick-sort-based</em> algorithms where various partitioning schemes are employed
      including: <br>
    - Hoare's partitioning scheme for a NOT highly structured array, i.e. a
      partly-ordered and partly-randomized array (an array having not very long
      and not very short ordered runs), <br>
    - Median-of-three partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements), <br>
    - Ninther (median of medians or pseudo-median of nine) partitioning scheme for
      worst-case situations (when the quicksort algorithm converges too slowly, it
      switches from Hoare's or median-of-three partitioning scheme to the ninther
      partitioning scheme), <br>
    - Three-way (or Dutch's national flag) partitioning scheme for an array with
      many equal elements (when the quick sort algorithm detects that many elements
      are equal, it switches from Hoare's or median-of-three partitioning scheme to
      the three-way partitioning scheme). <br>
  As previously mentioned, the selection of an appropriate algorithm is based on
  a careful and wise inspection of the given array.  The routine responsible for
  this task will try to predict a suitable algorithm for any given array according
  to its pattern found.  The following list provides an overview of the routine. <br>
    - The routine will mostly try to scan just a very few runs and quit very quickly.
      Only, the highly structured array (the one sorted by Java's merge runs) is
      entirely scanned since all the runs are needed by the selected algorithm. <br>
    - If the routine detects that the current run is in an order opposite to the
      desired one, it will only reverse the run if necessary (i.e. the chosen
      algorithm will benefit from the reversion of the run). <br>
    - The prediction of a proper algorithm is quite accurate for most known cases.
      However, there are certain known cases that the routine may not choose
      the <em>BEST</em> algorithm.  For example, if highly-order parts of the given array
      are in the middle while randomized parts are in the beginning and in the end,
      the routine will typically select a quick sort algorithm.  However, if the
      highly-ordered parts are long enough (e.g. more than 50% of the array size),
      Rust/TimSort algorithms might be better algorithms.  For these certain cases,
      nonetheless, it is not worth scanning the whole array just so we can choose
      the <em>BEST</em> algorithm because the overhead will surely be very expensive. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesort~2.html'>WiseSort</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>WiseSort</em> algorithm is a hybrid algorithm originated in this library
  (<em>XpfLib</em>).  The algorithm sorts the given array using a variety of sorting
  algorithms based on the pattern of the data.  First, it carefully and wisely
  inspects the specified array by checking if there is any pattern in the given
  array.  Next, it decides which sorting algorithm is most suitable for the array.
  It then sorts the array using the chosen algorithm. <br>
  The selection of a sorting algorithm is based on the following facts. <br>
  - An <em>Insertion sort</em> algorithm usually performs well for an array with
    small size. <br>
  - If the data is already sorted, no sorting algorithm is needed. <br>
  - If the data is already sorted but in an order opposite to the desired one,
    a reversion of the array is the most optimal sorting algorithm. <br>
  - A quicksort algorithm typically performs well for a totally randomized array. <br>
  - A mergesort algorithm generally performs well for a mostly ordered array. <br>
  Based on the aforementioned facts, the <em>WiseSort</em> algorithm utilizes various
  sorting algorithms including: <br>
  1. <em>Pair-insertion-sort-based</em> algorithms consisting of <br>
    - guarded version for a left-most sub-array or the whole array with small size, <br>
    - unguarded version for a non-left-most sub-array with small size. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered
      array (i.e. an array having a very long ordered run, either in ascending or
      descending order). <br>
      For this particular implementation, it is found that Rust's mergesort performs
      very well for an array when more than 50% of the first or last elements of the
      array are already sorted. <br>
  3. <em>Quick-sort-based</em> algorithms where various partitioning schemes are employed
      including: <br>
    - Hoare's partitioning scheme for a NOT highly structured array, i.e. a
      partly-ordered and partly-randomized array (an array having not very long
      and not very short ordered runs), <br>
    - Median-of-three partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements), <br>
    - Ninther (median of medians or pseudo-median of nine) partitioning scheme for
      worst-case situations (when the quicksort algorithm converges too slowly, it
      switches from Hoare's or median-of-three partitioning scheme to the ninther
      partitioning scheme), <br>
    - Three-way (or Dutch's national flag) partitioning scheme for an array with
      many equal elements (when the quick sort algorithm detects that many elements
      are equal, it switches from Hoare's or median-of-three partitioning scheme to
      the three-way partitioning scheme). <br>
  As previously mentioned, the selection of an appropriate algorithm is based on
  a careful and wise inspection of the given array.  The routine responsible for
  this task will try to predict a suitable algorithm for any given array according
  to its pattern found.  The following list provides an overview of the routine. <br>
    - The routine will mostly try to scan just a very few runs and quit very quickly.
      Only, the highly structured array (the one sorted by Java's merge runs) is
      entirely scanned since all the runs are needed by the selected algorithm. <br>
    - If the routine detects that the current run is in an order opposite to the
      desired one, it will only reverse the run if necessary (i.e. the chosen
      algorithm will benefit from the reversion of the run). <br>
    - The prediction of a proper algorithm is quite accurate for most known cases.
      However, there are certain known cases that the routine may not choose
      the <em>BEST</em> algorithm.  For example, if highly-order parts of the given array
      are in the middle while randomized parts are in the beginning and in the end,
      the routine will typically select a quick sort algorithm.  However, if the
      highly-ordered parts are long enough (e.g. more than 50% of the array size),
      Rust/TimSort algorithms might be better algorithms.  For these certain cases,
      nonetheless, it is not worth scanning the whole array just so we can choose
      the <em>BEST</em> algorithm because the overhead will surely be very expensive. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesortstable.html'>WiseSortStable</a></td><td><a href='../module/modbase_sortdescend.html'>ModBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  Similar to the <em>WiseSort</em> algorithm, the <em>WiseSort-Stable</em> algorithm is
  a hybrid algorithm originated in this library(<em>XpfLib</em>).  Unlike the
  <em>WiseSort</em> algorithm, which is an unstable algorithm, the <em>WiseSort-Stable</em>
  algorithm (as the name implied) is a stable algorithm that sorts the given
  array using a variety of <em>stable</em> sorting algorithms.  Similar to the <em>WiseSort</em>
  algorithm, the <em>WiseSort-Stable</em> algorithm first inspects the specified
  array by checking if there is any pattern in the given array and then decides
  which stable sorting algorithm is most suitable for the array.  It then sorts
  the array using the chosen algorithm. <br>
  The selection of a stable sorting algorithm is based on the same facts given
  in the <em>WiseSort</em> section; hence, the <em>WiseSort-Stable</em> algorithm employs
  various stable sorting algorithms including: <br>
  1. <em>Insertion sort</em> algorithm (guarded version only) for a small-size (sub)array. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered
      array (an array having a very long ordered run, either in ascending or
      descending order), <br>
    - Merge sort with half-copying for a small-size array or a partially randomized
      array (an array with one not-too-short and not-too-long run and many very-very
      short runs). <br>
  3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements). <br>
  4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array
      with many not-too-short and not-too-long runs). <br>
  Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm
      that switches to the mergesort with half-copying algorithm for the smaller
      sub-array after the stable partitioning process while it recurs on the larger
      sub-array. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesortstable~2.html'>WiseSortStable</a></td><td><a href='../module/modbase_sortascend.html'>ModBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  Similar to the <em>WiseSort</em> algorithm, the <em>WiseSort-Stable</em> algorithm is
  a hybrid algorithm originated in this library(<em>XpfLib</em>).  Unlike the
  <em>WiseSort</em> algorithm, which is an unstable algorithm, the <em>WiseSort-Stable</em>
  algorithm (as the name implied) is a stable algorithm that sorts the given
  array using a variety of <em>stable</em> sorting algorithms.  Similar to the <em>WiseSort</em>
  algorithm, the <em>WiseSort-Stable</em> algorithm first inspects the specified
  array by checking if there is any pattern in the given array and then decides
  which stable sorting algorithm is most suitable for the array.  It then sorts
  the array using the chosen algorithm. <br>
  The selection of a stable sorting algorithm is based on the same facts given
  in the <em>WiseSort</em> section; hence, the <em>WiseSort-Stable</em> algorithm employs
  various stable sorting algorithms including: <br>
  1. <em>Insertion sort</em> algorithm (guarded version only) for a small-size (sub)array. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered
      array (an array having a very long ordered run, either in ascending or
      descending order), <br>
    - Merge sort with half-copying for a small-size array or a partially randomized
      array (an array with one not-too-short and not-too-long run and many very-very
      short runs). <br>
  3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements). <br>
  4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array
      with many not-too-short and not-too-long runs). <br>
  Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm
      that switches to the mergesort with half-copying algorithm for the smaller
      sub-array after the stable partitioning process while it recurs on the larger
      sub-array. <br></p></td></tr>
			   <tr><td><a href='../interface/write(formatted).html'>WRITE(FORMATTED)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WRITE(FORMATTED) <br>
 <strong>Purpose</strong>:  To write a character string of the FvlStr object to a connected
      formatted unit. <br>
 <strong>Usage</strong>: <br>
  ! using the list-directed format output <br>
  ---&gt;    WRITE(UNIT=IOUnit, FMT=<em>) vStr <br>
  ---&gt;    WRITE(UNIT=IOUnit, FMT=</em>, IOSTAT=IOStat, IOMSG=IOMsg) vStr <br>
  ! using the DT edit descriptor <br>
  ---&gt;    WRITE(UNIT=IOUnit, FMT='(DT)') vStr <br>
  ---&gt;    WRITE(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr <br></p></td></tr>
			   <tr><td><a href='../interface/write(unformatted).html'>WRITE(UNFORMATTED)</a></td><td><a href='../module/class_fvlstr.html'>Class_FvlStr</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WRITE(UNFORMATTED) <br>
 <strong>Purpose</strong>:  To write a character string of the FvlStr object to a connected
      unformatted unit. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    WRITE(UNIT=IOUnit) vStr <br></p></td></tr>
			   <tr><td><a href='../interface/wy_hash64_exp.html'>Wy_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wy_hash64_opt.html'>Wy_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wyf3_hash64_exp.html'>WyF3_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wyf3_hash64_opt.html'>WyF3_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wyhash_f3_i64.html'>WyHash_F3_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/wyhash_i64.html'>WyHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../proc/xermsg.html'>XERMSG</a></td><td><a href='../module/modbase_slatec_util.html'>ModBase_SLATEC_Util</a></td><td>Subroutine</td><td><p>To process and display error information.</p><a href="../proc/xermsg.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/xerrwd.html'>XERRWD</a></td><td><a href='../module/modbase_slatec_util.html'>ModBase_SLATEC_Util</a></td><td>Subroutine</td><td><p>To process and display error information.</p></td></tr>
			   <tr><td><a href='../interface/xx3_hash128_exp.html'>XX3_Hash128_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx3_hash128_opt.html'>XX3_Hash128_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx3_hash64_exp.html'>XX3_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx3_hash64_opt.html'>XX3_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx3hash_i128.html'>XX3Hash_I128</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx3hash_i64.html'>XX3Hash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx_hash32_exp.html'>XX_Hash32_Exp</a></td><td><a href='../module/modbase_experimentalhash32.html'>ModBase_ExperimentalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx_hash32_opt.html'>XX_Hash32_Opt</a></td><td><a href='../module/modbase_optimalhash32.html'>ModBase_OptimalHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx_hash64_exp.html'>XX_Hash64_Exp</a></td><td><a href='../module/modbase_experimentalhash64.html'>ModBase_ExperimentalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xx_hash64_opt.html'>XX_Hash64_Opt</a></td><td><a href='../module/modbase_optimalhash64.html'>ModBase_OptimalHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xxhash_i32.html'>XXHash_I32</a></td><td><a href='../module/modbase_referencehash32.html'>ModBase_ReferenceHash32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/xxhash_i64.html'>XXHash_I64</a></td><td><a href='../module/modbase_referencehash64.html'>ModBase_ReferenceHash64</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/zeroapint32.html'>ZeroApInt32</a></td><td><a href='../module/class_apint32.html'>Class_ApInt32</a></td><td>Interface</td><td></td></tr>
			   <tr><td><a href='../interface/zeroapint64.html'>ZeroApInt64</a></td><td><a href='../module/class_apint64.html'>Class_ApInt64</a></td><td>Interface</td><td></td></tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>XpfGeneral was developed by Niranama<br>&copy; 2024 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>