<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="XpfLib - General Package Documentation">
    <meta name="author" content="Niranama" >
    <link rel="icon" href="../favicon.png">

    <title>Class_IntrusiveHashTree &ndash; XpfGeneral</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha256-tG5mcZUtJsZvyKAxYLVXrmjKBVLd6VpVccqz/r4ypFE=" crossorigin="anonymous"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">XpfGeneral </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/absint.html">Abstract Interfaces</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/types.html">Derived Types</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
  <div class="row">
    <h1>Class_IntrusiveHashTree
      <small>Module</small>
      
    </h1>
      <div class="container p-2 mb-4 bg-light border rounded-3">
    <div class="row align-items-center justify-content-between" id="info-bar">
      <div class="col">
        <ul class="list-inline" style="margin-bottom:0px;display:inline">

            <li class="list-inline-item" id="statements"><i class="fa fa-list-ol"></i>
              <a data-bs-toggle="tooltip"
                 data-bs-placement="bottom" data-html="true"
                 title=" 0.1% of total for modules and submodules.">371 statements</a>
            </li>

            <li class="list-inline-item" id="source-file">
              <i class="fa fa-code"></i>
              <a href="../src/Class - IntrusiveHashTree.f90"> Source File</a>
            </li>
        </ul>
      </div>
      <div class="col">
        <nav aria-label="breadcrumb">
          <ol class="breadcrumb justify-content-end mb-0">
                <li class="breadcrumb-item"><a href='../sourcefile/class - intrusivehashtree.f90.html'>Class - IntrusiveHashTree.f90</a></li>
            <li class="breadcrumb-item active" aria-current="page">Class_IntrusiveHashTree</li>
          </ol>
        </nav>
      </div>
    </div>
  </div>
  <script>
    $(function () {
    $('[data-bs-toggle="tooltip"]').tooltip()
    })
  </script>

  </div>

  <div class="row">
    <div class="col-md-3">
        <div id="sidebar">
      <h3>Contents</h3>
  
  
  
  
  
  
  
  
  
  
      <div class="card mb-4">
      <a data-bs-toggle="collapse" href="#types-0"
         aria-expanded="false" aria-controls="types-0">
         <h4 class="card-header bg-primary text-white">Derived Types</h4>
      </a>
      <div id="types-0" class="collapse">
        <div class="list-group list-group-flush">
            <a class="list-group-item" href="../module/class_intrusivehashtree.html#type-hashtreenode">HashTreeNode</a>
            <a class="list-group-item" href="../module/class_intrusivehashtree.html#type-intrusivehashtree">IntrusiveHashTree</a>
        </div>
      </div>
    </div>

  
  
  
  
  
  
  
  
  


  </div>

    </div>

    <div class="col-md-9" id='text'>
      <p><strong>PURPOSE OF THIS MODULE</strong>: <br>
  This module contains the <em>IntrusiveHashTree</em> type, the <em>HashTreeNode</em> type and
  their related routines.  The <em>IntrusiveHashTree</em> type is a container type that
  employs a separate-chaining hash table implementation to provide common operations
  for an unordered symbol table while the <em>HashTreeNode</em> type is a node type intended
  to be used in conjunction with the <em>IntrusiveHashTree</em> type. <br>
  As an intrusive container, the <em>IntrusiveHashTree</em> type requires a user to define
  a new node type that extends the <em>HashTreeNode</em> type, which is a subtype of the
  <a href="../module/Class_IntrusiveBSTrees.html#type-bstode">BSTNode</a> type.  The
  new node type must contain a key (or more than one) as its additional component(s).
  The new node type may contain one or more associated values as its other component(s).
  The user is also required to implement all procedures deferred by the <em>HashTreeNode</em>
  type and its parent types.  In particular, the <em>CompareTo</em> and <em>ComputeHashValue</em>
  deferred procedures should be dependent on the key component(s) only. <br>
  Unlike intrusive list-based and tree-based types, which can be used instantly by
  inserting objects into a container, the <em>IntrusiveHashTree</em> type requires an explicit
  construction via the <em>Construct</em> method before using other provided operations. <br></p>
<br>          <div class="card mb-4">
      <h3 class="card-header card-title bg-light">Uses</h3>
      <div class="card-body">
        <ul class="list-group list-group-flush">
            <li class="list-group-item">
              <ul class="list-inline">
                  <li class="list-inline-item"><a href='../module/modbase_common.html'>ModBase_Common</a></li>
                  <li class="list-inline-item"><a href='http://fortranwiki.org/fortran/show/iso_c_binding'>iso_c_binding</a></li>
                  <li class="list-inline-item"><a href='../module/modbase_error_handlers.html'>ModBase_Error_Handlers</a></li>
                  <li class="list-inline-item"><a href='http://fortranwiki.org/fortran/show/iso_fortran_env'>iso_fortran_env</a></li>
                  <li class="list-inline-item"><a href='../module/modbase_sintutil.html'>ModBase_SIntUtil</a></li>
                  <li class="list-inline-item"><a href='../module/class_intrusivebstrees.html'>Class_IntrusiveBSTrees</a></li>
              </ul>
            </li>
        </ul>
      </div>
    </div>

      
      <br>






        <section>
          <h2>Derived Types</h2>
              <div class="card">
    <div class="card-header codesum">
      <span class="anchor" id="type-hashtreenode"></span>
      <h3>
        type, public, extends(<a href='../type/bstnode.html'>BSTNode</a>)&nbsp;::&nbsp;
        <a href='../type/hashtreenode.html'>HashTreeNode</a>
        
      </h3>
    </div>
    <div class="card-body">
      <p>The <em>HashTreeNode</em> type is a binary-search-tree node type intended to be
 used in conjunction with the <em>IntrusiveHashTree</em> type.  Similar to other
 intrusive containers, the <em>IntrusiveHashTree</em> type requires a user to
 define a new (concrete) node type that extends the <em>HashTreeNode</em> type
 where the new node type contains a key and its associated value as its
 components. <br>
 The following code snippet illustrates how to define a new node type.
<br>
<Pre><Code style="color:MidnightBlue;">
  TYPE, EXTENDS(HashTreeNode) :: AssociativeNode
      CHARACTER(LEN=:), ALLOCATABLE   :: Key      ! stored string key
      INTEGER                         :: Value1   ! stored integer value
      REAL                            :: Value2   ! stored real value
  END TYPE
  </Code></Pre></p><a href="../type/hashtreenode.html" class="pull-right"><emph>Read more&hellip;</emph></a>




        <h4>Type-Bound Procedures</h4>
        <table class="table table-striped varlist">
          <tbody>
              <tr>
                <td>  procedure(CopyObj), public, deferred ::
  <strong><a href='../type/assignable.html#boundprocedure-copyassign~2'>CopyAssign</a></strong></td>
                <td><p><em>CopyAssign</em> is a binding name of the <em>CopyObj</em> deferred procedure. <br>
 Use the assignment expression in place of the <em>CopyAssign</em> method
 to make a copy of an <em>Assignable</em> object.</p></td>
              </tr>
              <tr>
                <td>  procedure(CloneObj), public, deferred ::
  <strong><a href='../type/assignable.html#boundprocedure-makeclone~2'>MakeClone</a></strong></td>
                <td><p><em>MakeClone</em> is a binding name of the <em>CloneObj</em> deferred procedure. <br>
 Use the <em>GetClone</em> method in place of the <em>MakeClone</em> method
 to create and return a copy of an <em>Assignable</em> object.</p></td>
              </tr>
              <tr>
                <td>  procedure(EqualObj), public, deferred ::
  <strong><a href='../type/assignable.html#boundprocedure-isequalto~2'>IsEqualTo</a></strong></td>
                <td><p><em>IsEqualTo</em> is a binding name of the <em>EqualObj</em> deferred procedure. <br></p></td>
              </tr>
              <tr>
                <td>  procedure(FreeObj), public, deferred ::
  <strong><a href='../type/assignable.html#boundprocedure-freememory~3'>FreeMemory</a></strong></td>
                <td><p><em>FreeMemory</em> is a binding name of the <em>FreeObj</em> deferred procedure. <br>
 Use the <em>MemFree</em> method in place of the <em>FreeMemory</em> method to free
 memory the <em>Assignable</em> object if the object contains allocatable and/or
 pointer component(s).</p></td>
              </tr>
              <tr>
                <td>  procedure(TypeName), public, deferred ::
  <strong><a href='../type/assignable.html#boundprocedure-gettypename~2'>GetTypeName</a></strong></td>
                <td><p><em>GetTypeName</em> is a binding name of the <em>TypeName</em> deferred procedure. <br>
 Use the <em>GetName</em> method in place of the <em>GetTypeName</em> method to get
 the name of the <em>concrete</em> type of an <em>Assignable</em> object (i.e. name
 of a concrete subtype of an <em>Assignable</em> abstract type).</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-assignment%28%3D%29~23'>ASSIGNMENT(=)</a></strong> => <a href='../type/stringbuilder.html#boundprocedure-copyassign~3'>CopyAssign</a></td>
                <td><p><strong>Operator Overload</strong>: ASSIGNMENT(=)  <br>
 <strong>Purpose</strong>:  To copy a source object to a destination object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    DstObj = SrcObj</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-memfree~23'>MemFree</a></strong> => <a href='../type/stringbuilder.html#boundprocedure-freememory~4'>FreeMemory</a></td>
                <td><p><strong>Type-Bound Subroutine</strong>: MemFree <br>
 <strong>Purpose</strong>:  To free memory of an <em>Assignable</em> object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Obj%MemFree()</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-getclone~58'>GetClone</a></strong> => <a href='../type/stringbuilder.html#boundprocedure-makeclone~3'>MakeClone</a></td>
                <td><p><strong>Type-Bound Subroutine</strong>: GetClone <br>
 <strong>Purpose</strong>:  To create and return a copy of an <em>Assignable</em> object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL SrcObj%GetClone(DstObj)</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-getname~125'>GetName</a></strong> => <a href='../type/stringbuilder.html#boundprocedure-gettypename~3'>GetTypeName</a></td>
                <td><p><strong>Type-Bound Function</strong>: GetName <br>
 <strong>Purpose</strong>:  To get the <em>concrete</em> type name of an <em>Assignable</em> object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    TypeName = Obj%GetName()</p></td>
              </tr>
              <tr>
                <td>  procedure(CompareObj), public, deferred ::
  <strong><a href='../type/comparable.html#boundprocedure-compareto~6'>CompareTo</a></strong></td>
                <td><p><em>CompareTo</em> is a binding name of the <em>CompareObj</em> deferred procedure.
 Use relational operators provided in place of the <em>CompareTo</em> method
 to compare two <em>Comparable</em> objects.</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28%3D%3D%29~7'>OPERATOR(==)</a></strong> => Comparable_EqualTo</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(==) <br>
 <strong>Purpose</strong>:  To check if the LHS value is equal to the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS == RHS <br>
  ---&gt;    IF (LHS == RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28SLASH%3D%29~7'>OPERATOR(/=)</a></strong> => Comparable_NotEqualTo</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(/=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is NOT equal to the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS /= RHS <br>
  ---&gt;    IF (LHS /= RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28lt%29~7'>OPERATOR(<)</a></strong> => Comparable_LessThan</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(&lt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt; RHS <br>
  ---&gt;    IF (LHS &lt; RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28gt%29~7'>OPERATOR(>)</a></strong> => Comparable_GreaterThan</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(&gt;) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt; RHS <br>
  ---&gt;    IF (LHS &gt; RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28lt%3D%29~7'>OPERATOR(<=)</a></strong> => Comparable_LessEqual</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(&lt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is less than or equal to the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &lt;= RHS <br>
  ---&gt;    IF (LHS &lt;= RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-operator%28gt%3D%29~7'>OPERATOR(>=)</a></strong> => Comparable_GreaterEqual</td>
                <td><p><strong>Operator Overload</strong>: OPERATOR(&gt;=) <br>
 <strong>Purpose</strong>:  To check if the LHS value is greater than or equal to the RHS value <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LHS &gt;= RHS <br>
  ---&gt;    IF (LHS &gt;= RHS) DoSomething</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-getleft'>GetLeft</a></strong> => BSTNode_GetLeftNode</td>
                <td><p><strong>Type-Bound Function</strong>: GetLeft <br>
 <strong>Purpose</strong>:  To get a pointer to the left node of the current node. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    LeftNode =&gt; CurrNode%GetLeft()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-getright'>GetRight</a></strong> => BSTNode_GetRightNode</td>
                <td><p><strong>Type-Bound Function</strong>: GetRight <br>
 <strong>Purpose</strong>:  To get a pointer to the right node of the current node. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    RightNode =&gt; CurrNode%GetRight()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-getsize~47'>GetSize</a></strong> => BSTNode_GetSize</td>
                <td><p><strong>Type-Bound Function</strong>: GetSize <br>
 <strong>Purpose</strong>:  To get number of nodes in subtree rooted by this node. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Size = CurrNode%GetSize()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-freepointers~2'>FreePointers</a></strong> => BSTNode_FreePointers</td>
                <td><p><strong>Type-Bound Subroutine</strong>: FreePointers <br>
 <strong>Purpose</strong>:  To nullify the pointer components of the node. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL CurrNode%FreePointers()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-setnew~4'>SetNew</a></strong> => BSTNode_SetNew</td>
                <td><p><strong>Type-Bound Subroutine</strong>: SetNew <br>
 <strong>Purpose</strong>:  To set the node as a new node in the tree container. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Node%SetNew()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-reset~27'>Reset</a></strong> => BSTNode_Reset</td>
                <td><p><strong>Type-Bound Subroutine</strong>: Reset <br>
 <strong>Purpose</strong>:  To reset the node to its initialized state. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Node%Reset()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-copymembers'>CopyMembers</a></strong> => BSTNode_CopyMembers</td>
                <td><p><strong>Type-Bound Subroutine</strong>: CopyMembers <br>
 <strong>Purpose</strong>:  To copy members of the source to the destination.  This method
               is provided to help user implement deferred procedure(s) required
               by an object in the <em>Assignable</em> class. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL DstNode%CopyMembers(SrcNode)</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/bstnode.html#boundprocedure-equalto~2'>EqualTo</a></strong> => BSTNode_EqualTo</td>
                <td><p><strong>Type-Bound Function</strong>: EqualTo <br>
 <strong>Purpose</strong>:  To compare whether all members of both objects are equal or not.
               This method is provided to help user implement deferred procedure(s)
               required by an object in the <em>Assignable</em> class. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = LhsNode%EqualTo(RhsNode) <br>
  ---&gt;    IF (.NOT.LhsNode%EqualTo(RhsNode)) DoSomething</p></td>
              </tr>
              <tr>
                <td>  procedure(HashKey), public, deferred ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-computehashvalue~5'>ComputeHashValue</a></strong></td>
                <td><p><em>ComputeHashValue</em> is a binding name of the <em>HashKey</em> deferred procedure. <br>
 Use the <em>HashCode</em> method in place of the <em>ComputeHashValue</em> method to
 compute hash code of the key component of the <em>HashTreeNode</em> object.</p></td>
              </tr>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/hashtreenode.html#boundprocedure-hashcode~277'>HashCode</a></strong> => ComputeHashValue</td>
                <td><p><strong>Type-Bound Function</strong>: HashCode <br>
 <strong>Purpose</strong>:  To compute hash code of the key component of the <em>HashTreeNode</em> object. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    HashCode = Obj%HashCode()</p></td>
              </tr>
          </tbody>
        </table>
    </div>
  </div>

              <div class="card">
    <div class="card-header codesum">
      <span class="anchor" id="type-intrusivehashtree"></span>
      <h3>
        type, public&nbsp;::&nbsp;
        <a href='../type/intrusivehashtree.html'>IntrusiveHashTree</a>
        
      </h3>
    </div>
    <div class="card-body">
      <p>The <em>IntrusiveHashTree</em> type is an intrusive container type that employs a
 separate-chaining hash table implementation to provide common operations for
 an unordered symbol table.  The separate-chaining technique combines a balanced
 binary-search tree with a hash table to solve the collision problem.  <br>
 The <em>IntrusiveHashTree</em> type employs an array of the <em>IntrusiveRBTree</em> type
 as its component (i.e. using an array of balanced trees as its buckets) to store
 <em>HashTreeNode</em> objects.  Although the <em>IntrusiveHashTree</em> type handles a memory
 management of its working trees, these working trees (as intrusive containers)
 only provide a linking/unlinking task for common balanced-tree operations.  This
 means that the memory management task of the inserted <em>HashTreeNode</em> objects
 is essentially handled by a user who is an owner of those inserted objects. <br>
 As a symbol table, the <em>IntrusiveHashTree</em> type does not allow duplicated keys;
 therefore, if an inserted key node has a key equal to that of a key node stored
 in the table, the stored key node is replaced by the inserted key node.  <br>
 In order to avoid large balanced trees (due to many keys hashed to the same indices),
 the <em>IntrusiveHashTree</em> type employs the dynamic-array technique to resize the
 balanced-tree array.  As a result, the <em>IntrusiveHashTree</em> type requires an explicit
 construction via the <em>Construct</em> method before using other provided operations.
 When the <em>Destruct</em> method is called, the hash table also needs to be re-construct
 because this method essentially deallocates the working array.  <br></p>



        <h4>Finalizations Procedures</h4>
        <table class="table table-striped varlist">
          <tbody>
              <tr>
                <td>final :: <strong>HashTable_Finalize</strong></td>
                <td><p>To perform finalization of the object.</p></td>
              </tr>
          </tbody>
        </table>

        <h4>Type-Bound Procedures</h4>
        <table class="table table-striped varlist">
          <tbody>
              <tr>
                <td>  generic, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-construct~66'>Construct</a></strong> => HashTable_CreateEmpty, HashTable_CreateByArray</td>
                <td><p><strong>Type-Bound Subroutine</strong>: Construct <br>
 <strong>Purpose</strong>:  To construct a new empty table with default or specified capacity, or
               a new non-empty table from an array of key nodes. <br>
 <strong>Usage</strong>: <br>
  ! construct an empty table <br>
  ---&gt;    CALL Table%Construct()          ! use default initial capacity <br>
  ---&gt;    CALL Table%Construct(InitCap)   ! specify initial capacity <br>
  ! construct a non-empty table from an array of 25 key nodes <br>
  ---&gt;    CALL Table%Construct(25, KeyNodes) <br></p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-destruct~55'>Destruct</a></strong> => HashTable_Destroy</td>
                <td><p><strong>Type-Bound Subroutine</strong>: Destruct <br>
 <strong>Purpose</strong>:  To remove all key nodes from the table, free memory of the allocatable
               component, and reset all other components.<br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Table%Destruct() <br>
 <strong>Note</strong>:  This method is NOT equivalent to the <em>Clear</em> method where the allocatable
            component is NOT deallocated.</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-insert~37'>Insert</a></strong> => HashTable_Insert</td>
                <td><p><strong>Type-Bound Subroutine</strong>: Insert <br>
 <strong>Purpose</strong>:  To insert the specified key node into the table. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Table%Insert(KeyNode) <br></p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-remove~44'>Remove</a></strong> => HashTable_Remove</td>
                <td><p><strong>Type-Bound Function</strong>: Remove <br>
 <strong>Purpose</strong>:  To remove a stored key node that has the key component equal to that
               of the specified key node.  Also, return a flag indicating whether
               a stored key node is successfully removed or not.  <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Table%Remove(KeyNode) <br>
  ---&gt;    IF (.NOT.Table%Remove(KeyNode)) DoSomething</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-clear~45'>Clear</a></strong> => HashTable_Clear</td>
                <td><p><strong>Type-Bound Subroutine</strong>: Clear <br>
 <strong>Purpose</strong>:  To remove all stored key nodes from the table. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL Table%Clear()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-startfirst~46'>StartFirst</a></strong> => HashTable_Move2FirstNode</td>
                <td><p><strong>Type-Bound Function</strong>: StartFirst <br>
 <strong>Purpose</strong>:  To start the <em>forward</em> iteration and return a flag
               indicating whether the table is empty or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IsEmpty = Table%StartFirst() <br>
  ---&gt;    IsEmpty = Table%StartFirst(FirstNode)</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-moveforward~48'>MoveForward</a></strong> => HashTable_Move2NextNode</td>
                <td><p><strong>Type-Bound Function</strong>: MoveForward <br>
 <strong>Purpose</strong>:  To move <em>forward</em> to the next iteration and return a flag
               indicating whether the cursor has reached the end of the
               table or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    IsTheEnd = Table%MoveForward() <br>
  ---&gt;    IsTheEnd = Table%MoveForward(NextNode) <br></p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-getsize~58'>GetSize</a></strong> => HashTable_GetSize</td>
                <td><p><strong>Type-Bound Function</strong>: GetSize <br>
 <strong>Purpose</strong>:  To get size of the table (number of total nodes stored). <br>
 <strong>Usage</strong>: <br>
  ---&gt;    TableSize = Table%GetSize()</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-isempty~121'>IsEmpty</a></strong> => HashTable_IsEmpty</td>
                <td><p><strong>Type-Bound Function</strong>: IsEmpty <br>
 <strong>Purpose</strong>:  To check whether the table is empty or not. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Table%IsEmpty() <br>
  ---&gt;    IF (.NOT.Table%IsEmpty()) DoSomeThing</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-contain~25'>Contain</a></strong> => HashTable_Contain</td>
                <td><p><strong>Type-Bound Function</strong>: Contain <br>
 <strong>Purpose</strong>:  To find a stored key node that has the key component equal to
               that of specified key node.  Return a flag indicating whether
               such node is found or not.  <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Table%Contain(KeyNode) <br>
  ---&gt;    IF (.NOT.Table%Contain(KeyNode)) DoSomething</p></td>
              </tr>
              <tr>
                <td>  procedure, public ::
  <strong><a href='../type/intrusivehashtree.html#boundprocedure-findnode~2'>FindNode</a></strong> => HashTable_FindNode</td>
                <td><p><strong>Type-Bound Function</strong>: FindNode <br>
 <strong>Purpose</strong>:  To find the specified key node in the table.  Return true if
               the specified key node is found.  Otherwise, return false. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = Table%FindNode(KeyNode, StoredNode) <br>
  ---&gt;    IF (.NOT.Table%FindNode(KeyNode)) DoSomething</p></td>
              </tr>
          </tbody>
        </table>
    </div>
  </div>

        </section>
        <br>





    </div>
  </div>

      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>XpfGeneral was developed by Niranama<br>&copy; 2024 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>